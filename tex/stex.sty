%%
%% This is file `stex.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% stex.dtx  (with options: `package')
%% 
\RequirePackage{expl3,l3keys2e,ltxcmds}
\ProvidesExplPackage{stex}{2022/09/14}{3.3.0}{sTeX package}
\RequirePackage{stex-logo} % externalized for backwards-compatibility reasons
\RequirePackage{standalone}

\message{^^J*~This~is~sTeX~version~3.3.0~*^^J}
\keys_define:nn { stex } {
  debug      .str_set_x:N  = \c_stex_debug_clist ,
  lang       .clist_set:N  = \c_stex_languages_clist ,
  mathhub    .tl_set_x:N   = \mathhub ,
  usesms     .bool_set:N   = \c_stex_persist_mode_bool ,
  writesms   .bool_set:N   = \c_stex_persist_write_mode_bool ,
  checkterms .bool_set:N   = \c_stex_check_terms_bool ,
  image      .bool_set:N   = \c_tikzinput_image_bool,
  unknown    .code:n       = {}
}
\exp_args:NNo \clist_set:Nn \c_stex_debug_clist \c_stex_debug_clist
\ProcessKeysOptions { stex }
\input{stex-en.ldf}
\cs_new_protected:Nn \stex_kpsewhich:Nn {\group_begin:
  \catcode`\ =12
  \sys_get_shell:nnN { kpsewhich ~ #2 } { } \l_tmpa_tl
  \tl_gset_eq:NN \l_tmpa_tl \l_tmpa_tl
  \group_end:
  \exp_args:NNo\str_set:Nn #1 {\l_tmpa_tl}
  \tl_trim_spaces:N #1
}
\sys_if_platform_windows:TF{
  \cs_new_protected:Nn \stex_get_env:Nnn {\group_begin:
    \escapechar=-1\catcode`\\=12
    \stex_kpsewhich:Nn-1{-expand-var~\c_percent_str#3\c_percent_str}
    \exp_args:NNx\use:nn\group_end:{
      \str_set:Nn\exp_not:N#1{#1}
    }
  }
}{
  \cs_new_protected:Nn \stex_get_env:Nnn {
    \stex_kpsewhich:Nn #1 {-var-value~#2}
  }
}
\cs_new_protected:Nn \stex_get_env:Nn {
  \stex_get_env:Nnn #1{#2}{#2}
}
\cs_new_protected:Nn \stex_debug:nn {
  \clist_if_in:NnTF \c_stex_debug_clist { all }{
    \__stex_debug_:nn{#1}{#2}
  }{
    \clist_if_in:NnT \c_stex_debug_clist { #1 }{}{
      \__stex_debug_:nn{#1}{#2}
    }
  }
}

\cs_new_protected:Nn \__stex_debug_:nn {
  \msg_set:nnn{stex}{debug / #1}{
    \\Debug~#1:~#2\\
  }
  \msg_none:nn{stex}{debug / #1}
}

\cs_new_protected:Nn \_stex_fatal_error:n {
  \msg_error:nn{stex}{#1}\input{Fatal~Error!!}
}
\cs_new_protected:Nn \_stex_fatal_error:nnn {
  \msg_error:nnn{stex}{#1}{#2}{#3}\input{Fatal~Error!!}
}
\cs_generate_variant:Nn \_stex_fatal_error:nnn {nxx}
\stex_get_env:Nn\__stex_debug_env_str{STEX_DEBUG}
\str_if_empty:NF\__stex_debug_env_str {
  \clist_set:No \c_stex_debug_clist {\__stex_debug_env_str}
}
\cs_undefine:N\__stex_debug_env_str

\exp_args:NNo \clist_if_in:NnTF \c_stex_debug_clist {\tl_to_str:n{all}} {
    \msg_redirect_module:nnn{ stex }{ none }{ term }
    \stex_debug:nn{all}{Logging~everything!}
}{
  \clist_map_inline:Nn \c_stex_debug_clist {
    \msg_redirect_name:nnn{ stex }{ debug / #1 }{ term }
    \stex_debug:nn{#1}{Logging~#1}
  }
}
\exp_args:NNx \prop_const_from_keyval:Nn \c_stex_languages_prop { \tl_to_str:n {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}}

\exp_args:NNx \prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop { \tl_to_str:n {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}}
\str_new:N \l_stex_current_language_str
\cs_new_protected:Nn \stex_set_language:n {
  \str_set:Nn \l_stex_current_language_str { #1 }
  \prop_if_in:NnTF \c_stex_languages_prop {#1} {
    \cs_if_eq:NNTF\@onlypreamble\@notprerr{
      \ltx@ifpackageloaded{babel}{
        \exp_args:Nx\selectlanguage{
          \prop_item:Nn \c_stex_languages_prop {#1}
        }
      }{}
    }{
      \str_if_eq:nnTF {#1} {tr} {
        \RequirePackage[turkish,shorthands=:!]{babel}
      }{
        \RequirePackage[\prop_item:Nn \c_stex_languages_prop {#1}]{babel}
      }
    }
  }{
    \msg_error:nnx{stex}{error/unknownlanguage}{#1}
  }
}
\cs_generate_variant:Nn \stex_set_language:n {x,o}
\cs_new_protected:Nn \_stex_current_language: {
  \seq_get_right:NN \g_stex_current_file \l_tmpa_str
  \seq_set_split:NnV \l_tmpa_seq . \l_tmpa_str
  \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str % = ".tex"
  \exp_args:No \str_if_eq:nnF \l_tmpa_str {tex} {
    \exp_args:No \str_if_eq:nnF \l_tmpa_str {dtx} {
      \exp_args:No \str_if_eq:nnF \l_tmpa_str {ltx} {
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq \l_tmpa_str
      }
    }
  }
  \seq_pop_left:NN \l_tmpa_seq \l_tmpa_str % <filename>
  \seq_if_empty:NF \l_tmpa_seq { %remaining element should be [<something>.]language
    \seq_pop_right:NN \l_tmpa_seq \l__stex_lang_str
    \str_if_eq:NNF \l__stex_lang_str \l_stex_current_language_str {
      \stex_set_language:o \l__stex_lang_str
    }
    \stex_debug:nn{lang} {Language~\l_stex_current_language_str~
      inferred~from~file~name}
  }
}
\cs_new_protected:Nn \stex_pseudogroup:nn {
  \exp_args:Nnx \use:nn {#1}{#2}
}
\cs_new:Nn \stex_pseudogroup_restore:N {
  \tl_if_exist:NTF #1 {
    \tl_set:Nn \exp_not:N #1 { \exp_args:No \exp_not:n #1 }
  }{
    \cs_undefine:N \exp_not:N #1
  }
}
\cs_new_protected:Nn \stex_pseudogroup_with:nn {
  \tl_map_inline:nn{#1}{
    \cs_set_eq:cN{__stex_groups_\tl_to_str:n{##1}}##1
  }
  #2
  \tl_map_inline:nn{#1}{
    \cs_set_eq:Nc##1{__stex_groups_\tl_to_str:n{##1}}
    \cs_undefine:c{__stex_groups_\tl_to_str:n{##1}}
  }
}
\seq_new:N \l__stex_groups_ids_seq
\cs_new_protected:Nn \stex_metagroup_new:n {
    \str_set:cx{l__stex_groups_#1_int} {\int_use:N\currentgrouplevel}
    \seq_put_right:Nn \l__stex_groups_ids_seq {#1}
}
\cs_generate_variant:Nn \stex_metagroup_new:n {o}
\prg_new_conditional:Nnn \__stex_groups_exists:n {TF} {
    \str_if_exist:cTF{l__stex_groups_#1_int}
        \prg_return_true: \prg_return_false:
}

\cs_new_protected:Nn \stex_metagroup_do_in:nn {
    \__stex_groups_exists:nTF{#1}{
        \__stex_groups_do_in:nn{#1}{#2}
    }{
      \msg_error:nnn{stex}{error/metagroup/missing}{#1}
    }
}
\cs_generate_variant:Nn \stex_metagroup_do_in:nn {nx}

\cs_new_protected:Nn \__stex_groups_do_in:nn {
  \exp_args:Nnx\stex_debug:nn{metagroup}{adding~to~\detokenize{#1}}
  \tl_set:Nn\__stex_groups_tmp{#2}
  \exp_args:Nx \int_compare:nNnF {\use:c{l__stex_groups_#1_int}}
      = \currentgrouplevel {
      \tl_if_exist:cTF{g__stex_groups_#1_\the\currentgrouplevel _content}{
        \exp_args:Nno \tl_gput_right:cn{{g__stex_groups_#1_\the\currentgrouplevel _content}}
      }{
        \exp_args:Nno \tl_gset:cn{{g__stex_groups_#1_\the\currentgrouplevel _content}}
      }\__stex_groups_tmp
      \bool_if_exist:cF {l__stex_groups_\the\currentgrouplevel _bool} {
          \group_insert_after:N \__stex_groups_do:
          \bool_set_true:c {l__stex_groups_\the\currentgrouplevel _bool}
      }
  }
  \__stex_groups_tmp
}

\cs_new_protected:Nn \__stex_groups_do: {
    \seq_map_inline:Nn \l__stex_groups_ids_seq {
        \tl_if_exist:cT{g__stex_groups_##1_\int_eval:n{\currentgrouplevel+1}_content}{
            \exp_args:NNno \exp_args:Nno \__stex_groups_do_in:nn{##1}{
                \csname g__stex_groups_##1_\int_eval:n{\currentgrouplevel+1}_content\endcsname
            }
            \cs_undefine:c{g__stex_groups_##1_\int_eval:n{\currentgrouplevel+1}_content}
        }
        \bool_if_exist:cF {l__stex_groups_\int_eval:n\currentgrouplevel _bool} {
            \group_insert_after:N \__stex_groups_do:
            \bool_set_true:c {l__stex_groups_\int_eval:n\currentgrouplevel _bool}
        }
    }
}
\bool_new:N \_stex_html_do_output_bool
\bool_set_true:N \_stex_html_do_output_bool

\prg_new_conditional:Nnn \stex_if_do_html: {p,T,F,TF} {
  \bool_if:nTF \_stex_html_do_output_bool
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_suppress_html:n {
  \stex_pseudogroup:nn{
    \bool_set_false:N \_stex_html_do_output_bool
    #1
  }{
    \stex_if_do_html:T {
      \bool_set_true:N \_stex_html_do_output_bool
    }
  }
}
\ifcsname if@rustex\endcsname\else
  \expandafter\newif\csname if@rustex\endcsname
  \@rustexfalse
\fi
\ifcsname if@latexml\endcsname\else
  \expandafter\newif\csname if@latexml\endcsname
  \@latexmlfalse
\fi
\tl_if_exist:NF\stex@backend{
  \if@rustex
    \def\stex@backend{rustex}
  \else
    \if@latexml
      \def\stex@backend{latexml}
    \else
      \cs_if_exist:NTF\HCode{
        \def\stex@backend{tex4ht}
      }{
        \def\stex@backend{pdflatex}
      }
    \fi
  \fi
}
\input{stex-backend-\stex@backend.cfg}

\newif\ifstexhtml
\stex_html_backend:TF\stexhtmltrue\stexhtmlfalse
\cs_new_protected:Nn \_stex_html_checkempty:n {
  \tl_set:Nn \l_stex_html_arg_tl { #1 }
  \tl_if_empty:NT \l_stex_html_arg_tl {
    \tl_set_eq:NN \l_stex_html_arg_tl \c_stex_html_emptyarg_tl
  }
}

\cs_new_protected:Nn \stex_deactivate_macro:Nn {
  \tl_set_eq:cN{\tl_to_str:n{#1}~-~orig}#1
  \tl_set:Nn#1{
    \msg_error:nnnn{stex}{error/deactivated-macro}{\detokenize{#1}}{#2}
  }
}
\cs_new_protected:Nn \stex_reactivate_macro:N {
  \exp_after:wN\let\exp_after:wN#1\csname \detokenize{#1}~-~orig\endcsname
}
\protected\def\ignorespacesandpars{
  \begingroup\catcode13=10\relax
  \@ifnextchar\par{
    \endgroup\expandafter\ignorespacesandpars\@gobble
  }{
    \endgroup
  }
}
\cs_new_nopar:Nn \stex_keys_define:nnnn {
  \tl_gset:cn {__stex_aux_keys_#1_pre_tl}{#2}
  \tl_gset:cn {__stex_aux_keys_#1_def_tl}{#3}
  \tl_if_empty:nF{#4}{
    \clist_map_inline:nn{#4}{
      \tl_set_eq:Nc \l__stex_aux_tl {__stex_aux_keys_##1_pre_tl}
      \tl_gput_left:co{__stex_aux_keys_#1_pre_tl} \l__stex_aux_tl
      \tl_set_eq:Nc \l__stex_aux_tl {__stex_aux_keys_##1_def_tl}
      \tl_gput_left:cn{__stex_aux_keys_#1_def_tl} ,
      \tl_gput_left:co{__stex_aux_keys_#1_def_tl} \l__stex_aux_tl
    }
  }
  \tl_set_eq:Nc \l__stex_aux_tl {__stex_aux_keys_#1_def_tl}
  \exp_args:Nnx \stex_debug:nn{keys}{
    Setting~keys~for~#1:^^J
    \meaning \l__stex_aux_tl
  }
  \exp_args:Nno \keys_define:nn {stex / #1} {\l__stex_aux_tl}
}
\cs_new_nopar:Nn \stex_keys_set:nn {
  \use:c{__stex_aux_keys_#1_pre_tl}
  \keys_set:nn {stex / #1} { #2 }
}
\stex_keys_define:nnnn{archive file}{
  \str_clear:N \l_stex_key_archive_str
  \str_clear:N \l_stex_key_file_str
}{
  archive .str_set_x:N = \l_stex_key_archive_str ,
  file    .str_set_x:N = \l_stex_key_file_str
}{}

\stex_keys_define:nnnn{id}{
  \str_clear:N \l_stex_key_id_str
}{
  id .str_set_x:N = \l_stex_key_id_str
}{}

\stex_keys_define:nnnn{title}{
  \tl_clear:N \l_stex_key_title_tl
}{
  title .tl_set:N = \l_stex_key_title_tl
}{}

\stex_keys_define:nnnn{style}{
  \str_clear:N \l_stex_key_style_str
}{
  style .str_set_x:N = \l_stex_key_style_str
}{}

\stex_keys_define:nnnn{deprecate}{
  \str_clear:N \l_stex_key_deprecate_str
}{
  deprecate     .str_set_x:N  = \l_stex_key_deprecate_str
}{}

\cs_new_protected:Nn \_stex_do_deprecation:n {
  \str_if_empty:NF \l_stex_key_deprecate_str {
    \msg_warning:nnxx{stex}{warning/deprecated}{#1}{\l_stex_key_deprecate_str}
  }
}
\cs_new_protected:Nn \stex_new_stylable_cmd:nnnnn {
  \exp_after:wN \newcommand \cs:w stexstyle#1 \cs_end:[2][]{
    \__stex_aux_patch:nnn{#1}{##1}{##2}
  }
  \exp_after:wN \NewDocumentCommand\cs:w #1\cs_end:{#2}{
    \cs_set:Npn \stex_style_apply: {
      \__stex_aux_apply_patch:n{#1}
    }
    #3
  }
  \tl_set:cn {__stex_aux_style_#1:} { #4 }
  \tl_set:cn {__stex_aux_style_#1:} { #5 }
}

\cs_new_protected:Nn \__stex_aux_apply_patch:n {
  \tl_if_empty:NTF \thisstyle {
    \use:c{__stex_aux_style_#1:}
  }{
    \tl_if_exist:cTF{__stex_aux_style_#1_\thisstyle :}{
      \use:c{__stex_aux_style_#1_\thisstyle :}
    }{
      \use:c{__stex_aux_style_#1:}
    }
  }
}

\cs_new_protected:Nn \__stex_aux_patch:nnn {
  \str_if_empty:nTF {#2}{
    \tl_set:cn{__stex_aux_style_#1:}{#3}
  }{
    \tl_set:cn{__stex_aux_style_#1_#2:}{#3}
  }
}

\cs_new_protected:Nn \stex_new_stylable_env:nnnnnn {
  \exp_after:wN \newcommand \cs:w stexstyle#1 \cs_end:[3][]{
    \__stex_aux_patch:nnnn{#1}{##1}{##2}{##3}
  }
  \NewDocumentEnvironment{s#1}{#2}{
    \cs_set:Npn \stex_style_apply: {
      \__stex_aux_apply_patch_begin:n{#1}
    }
    #3
  }{
    \cs_set:Npn \stex_style_apply: {
      \__stex_aux_apply_patch_end:n{#1}
    }
    #4
  }
  \tl_set:cn {__stex_aux_style_#1_start:} { #5 }
  \tl_set:cn {__stex_aux_style_#1_end:} { #6 }
}

\cs_new_protected:Nn \__stex_aux_patch:nnnn {
  \str_if_empty:nTF {#2}{
    \tl_set:cn{__stex_aux_style_#1_start:}{#3}
    \tl_set:cn{__stex_aux_style_#1_end:}{#4}
  }{
    \tl_set:cn{__stex_aux_style_#1_#2_start:}{#3}
    \tl_set:cn{__stex_aux_style_#1_#2_end:}{#4}
  }
}

\cs_new_protected:Nn \__stex_aux_apply_patch_begin:n {
  \tl_set_eq:NN \thistitle \l_stex_key_title_tl
  \tl_set_eq:NN \thisstyle \l_stex_key_style_str
  \tl_set_eq:NN \thisid \l_stex_key_id_str
  \tl_if_empty:NTF \thisstyle {
    \use:c{__stex_aux_style_#1_start:}
  }{
    \tl_if_exist:cTF{__stex_aux_style_#1_\thisstyle _start:}{
      \use:c{__stex_aux_style_#1_\thisstyle _start:}
    }{
      \use:c{__stex_aux_style_#1_start:}
    }
  }
}

\cs_new_protected:Nn \__stex_aux_apply_patch_end:n {
  \tl_if_empty:NTF \thisstyle {
    \use:c{__stex_aux_style_#1_end:}
  }{
    \tl_if_exist:cTF{__stex_aux_style_#1_\thisstyle _end:}{
      \use:c{__stex_aux_style_#1_\thisstyle _end:}
    }{
      \use:c{__stex_aux_style_#1_end:}
    }
  }
}
\prg_new_conditional:Nnn \stex_str_if_ends_with:nn {p,T,F,TF} {
  \exp_args:Ne \str_if_eq:nnTF {
    \str_range:nnn{#1}{- \str_count:n{#2}}{-1}
  }{#2}\prg_return_true: \prg_return_false:
}
\cs_new:Npn \__stex_aux_start:#1\__stex_aux_end: {\exp_not:n{#1}}
\cs_new_protected:Nn \__stex_aux_end: {}
\cs_new:Nn \stex_macro_body:N {
  \exp_args:Nne\use:nn{\exp_after:wN \__stex_aux_start: #1}{
    \__stex_aux_args:e {\cs_parameter_spec:N #1}\__stex_aux_end:
  }
}

\cs_new:Nn \__stex_aux_args:n {
  \tl_if_empty:nF{#1}{
      {##\exp_args:Ne \tl_head:n {\tl_tail:n {#1}}}
      \__stex_aux_args:e {\exp_args:Ne\tl_tail:n{\tl_tail:n{#1}}}
  }
}
\cs_generate_variant:Nn \__stex_aux_args:n {e}
\cs_new:Nn \stex_macro_definition:N {
  \__stex_aux_prefix:e {\cs_prefix_spec:N #1}
  \def\exp_not:N #1
  \__stex_aux_params:e {\cs_parameter_spec:N #1}
  {
    \stex_macro_body:N #1
  }
}

\cs_new:Nn \__stex_aux_prefix:n {
  \tl_if_empty:nF{#1}{
    \str_if_eq:eeTF {
      \tl_range:nnn{#1}{1}{10}~
    }{\tl_to_str:n{\protected}}{
      \protected
      \__stex_aux_prefix_long:e {
          \str_range:nnn{#1}{11}{-1}
      }
    }{
      \__stex_aux_prefix_long:n {#1}
    }
  }
}
\cs_generate_variant:Nn \__stex_aux_prefix:n {e}

\cs_new:Nn \__stex_aux_prefix_long:n {
  \tl_if_empty:nF{#1}{
    \str_if_eq:eeT {
      \tl_range:nnn{#1}{1}{10}~
    }{\tl_to_str:n{\long}}{\long}
  }
}
\cs_generate_variant:Nn \__stex_aux_prefix_long:n {e}

\cs_new:Nn \__stex_aux_params:n {
  \tl_if_empty:nF{#1}{
    \exp_args:NNe \str_if_eq:VnTF \c_hash_str {\tl_head:n{#1}}{
      ####
    }{
      \tl_head:n{#1}
    }
    \__stex_aux_params:e {\tl_tail:n{#1}}
  }
}
\cs_generate_variant:Nn \__stex_aux_params:n {e}
\stex_get_env:Nn\__stex_persist_env_str{STEX_USESMS}
\str_if_empty:NF\__stex_persist_env_str{
  \exp_args:No \str_if_eq:nnF \__stex_persist_env_str{false}{
    \bool_set_true:N \c_stex_persist_mode_bool
  }
}
\stex_get_env:Nn\__stex_persist_env_str{STEX_WRITESMS}
\str_if_empty:NF\__stex_persist_env_str{
  \exp_args:No \str_if_eq:nnF \__stex_persist_env_str{false}{
    \bool_set_true:N \c_stex_persist_write_mode_bool
    \bool_set_false:N \c_stex_persist_mode_bool
  }
}
\cs_undefine:N \__stex_persist_env_str

\cs_set:Npn \stex_persist:n #1 {}
\cs_set:Npn \stex_persist:x #1 {}
\cs_set:Npn \stex_persist:o #1 {}

\bool_if:NT \c_stex_persist_write_mode_bool {
  \iow_new:N \c__stex_persist_iow
  \iow_open:Nn \c__stex_persist_iow{\jobname.sms}
  \AtEndDocument{
    \iow_close:N \c__stex_persist_iow
  }
  \cs_new_protected:Nn \stex_persist:n {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \regex_replace_all:nnN { \cP\# } { \cO\# } \l_tmpa_tl
    \regex_replace_all:nnN { \  } { \~ } \l_tmpa_tl
    \exp_args:NNo \iow_now:Nn \c__stex_persist_iow \l_tmpa_tl
  }
  \cs_generate_variant:Nn \stex_persist:n {x,o}
}

\cs_set_protected:Nn \stex_read_persist: {
  \bool_if:NT \c_stex_persist_mode_bool {
    % TODO
      \input{\jobname.sms}
    % TODO
  }
}
\cs_new_protected:Nn \stex_file_set:Nn {
  \str_if_empty:nTF {#2} { \seq_clear:N #1 }{
    \exp_args:NNno \seq_set_split:Nnn #1 / { \tl_to_str:n{#2} }
  }
}
\cs_generate_variant:Nn \stex_file_set:Nn {No, Nx}
\sys_if_platform_windows:TF{
  \cs_new_protected:Npn \__stex_path_win_take:nnw #1#2#3 \__stex_path_: {
    \str_set:Nn \l__stex_path_win_drive {#1#2}
    \str_set:Nn \l__stex_path_str{#3}
  }
  \cs_new_protected:Nn \stex_file_resolve:Nn {
    \str_set:Nn \l__stex_path_str {#2}
    \str_clear:N \l__stex_path_win_drive
    \exp_args:NNo \str_replace_all:Nnn \l__stex_path_str \c_backslash_str /
    \exp_args:Nx \tl_if_eq:nnT {\str_item:Nn \l__stex_path_str 2} : {
      \exp_after:wN \__stex_path_win_take:w \l__stex_path_str \__stex_path_:
    }
    \stex_file_set:No #1 \l__stex_path_str
    \__stex_path_canonicalize:N #1
    \str_if_empty:NF \l__stex_path_win_drive {
      \seq_put_left:No #1 \l__stex_path_win_drive
    }
    \stex_debug:nn{files}{Set~\tl_to_str:n{#1}~to~\stex_file_use:N #1}
  }
}{
  \cs_new_protected:Nn \stex_file_resolve:Nn {
    \str_set:Nn \l__stex_path_str {#2}
    \stex_file_set:No #1 \l__stex_path_str
    \__stex_path_canonicalize:N #1
    \stex_debug:nn{files}{Set~\tl_to_str:n{#1}~to~\stex_file_use:N #1}
  }
}
\cs_generate_variant:Nn \stex_file_resolve:Nn {No, Nx}

\cs_new_protected:Nn \__stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_pop:NN #1 \l__stex_path_str
    \seq_clear:N \l__stex_path_seq
    \str_if_empty:NTF \l__stex_path_str {
      \seq_map_function:NN #1 \__stex_path_dodots:n
      \seq_put_left:Nn \l__stex_path_seq {}
    }{
      \seq_push:No #1 \l__stex_path_str
      \seq_map_function:NN #1 \__stex_path_dodots:n
    }
    \seq_set_eq:NN #1 \l__stex_path_seq
  }
}

\cs_new_protected:Nn \__stex_path_dodots:n {
  \str_if_empty:nF{#1}{
    \str_if_eq:nnF {#1} {.} {
      \str_if_eq:nnTF {#1} {..} {
        \seq_if_empty:NF \l__stex_path_seq {
          \seq_pop_right:NN \l__stex_path_seq \l__stex_path_str
        }
      }{
        \seq_put_right:Nn \l__stex_path_seq {#1}
      }
    }
  }
}

\sys_if_platform_windows:TF {
  \prg_new_conditional:Nnn \stex_file_absolute:N {p, T, F, TF} {
    \seq_if_empty:NTF \prg_return_false: {
      \tl_set:Nx \l__stex_path_maybewin_str {\seq_item:Nn #1 1}
      \exp_args:No \tl_if_empty:nTF \l__stex_path_maybewin \prg_return_true: {
        \exp_args:Nx \tl_if_eq:nnTF {\str_item:Nn \l__stex_path_maybewin 2} :
          \prg_return_true: \prg_return_false:
      }
    }
  }
}{
  \prg_new_conditional:Nnn \stex_file_absolute:N {p, T, F, TF} {
    \seq_if_empty:NTF \prg_return_false: {
      \exp_args:Nx \tl_if_empty:nTF {\seq_item:Nn #1 1}
        \prg_return_true: \prg_return_false:
    }
  }
}
\cs_new:Nn \stex_file_use:N {
  \seq_use:Nn #1 /
}
\prg_new_protected_conditional:Nnn \stex_file_starts_with:NN {T,F,TF} {
  \seq_set_eq:NN \l__stex_path_a_seq #1
  \seq_set_eq:NN \l__stex_path_b_seq #2
  \tl_clear:N \l__stex_path_return_tl
  \bool_while_do:nn{
    \bool_not_p:n{
      \bool_lazy_any_p:n{
        {\seq_if_empty_p:N \l__stex_path_a_seq}
        {\seq_if_empty_p:N \l__stex_path_b_seq}
        {\bool_not_p:n{\tl_if_empty_p:N \l__stex_path_return_tl}}
      }
    }
  }{
    \seq_pop_left:NN \l__stex_path_a_seq \l__stex_path_a_tl
    \seq_pop_left:NN \l__stex_path_b_seq \l__stex_path_b_tl
    \tl_if_eq:NNF \l__stex_path_a_seq \l__stex_path_b_seq {
      \tl_set:Nn \l__stex_path_return_tl {\prg_return_false:}
    }
  }
  \tl_if_empty:NTF \l__stex_path_return_tl {
    \seq_if_empty:NTF \l__stex_path_b_seq \prg_return_true: \prg_return_false:
  } \l__stex_path_return_tl
}
\cs_new_protected:Nn \stex_file_split_off_ext:NN {
  \seq_set_eq:NN #1 #2
  \seq_pop_right:NN #1 \l__stex_path_str
  \seq_set_split:NnV \l__stex_path_seq . \l__stex_path_str
  \seq_pop_right:NN \l__stex_path_seq \l__stex_path_str
  \seq_put_right:Nx #1 {\seq_use:Nn \l__stex_path_seq .}
}
\cs_new_protected:Nn \stex_file_split_off_lang:NN {
  \seq_set_eq:NN #1 #2
  \seq_pop_right:NN #1 \l__stex_path_str
  \seq_set_split:NnV \l__stex_path_seq . \l__stex_path_str
  \seq_pop_right:NN \l__stex_path_seq \l__stex_path_str

  \seq_pop_right:NN \l__stex_path_seq \l__stex_path_str
  \exp_args:NNo \prop_if_in:NnF \c_stex_languages_prop \l__stex_path_str {
    \seq_put_right:No \l__stex_path_seq \l__stex_path_str
  }

  \seq_put_right:Nx #1 {\seq_use:Nn \l__stex_path_seq .}
}
\cs_set_protected:Nn \__stex_path_auth:n {
  \msg_error:nnx{stex}{error/misused-uri}{\tl_to_str:n{#1}}
}
\cs_set_eq:NN \__stex_path_path:n \__stex_path_auth:n
\cs_set_eq:NN \__stex_path_module:n \__stex_path_auth:n
\cs_set_eq:NN \__stex_path_name:n \__stex_path_auth:n

\cs_set_protected:Nn \stex_map_uri:Nnnnn{
  \stex_pseudogroup_with:nn{\__stex_path_auth:n\__stex_path_path:n\__stex_path_module:n\__stex_path_name:n}{
    \cs_set:Npn \__stex_path_auth:n ##1 {#2}
    \cs_set:Npn \__stex_path_path:n ##1 {#3}
    \cs_set:Npn \__stex_path_module:n ##1 {#4}
    \cs_set:Npn \__stex_path_name:n ##1 {#5}
    #1
  }
}
\str_set:Nx\__stex_path_colonslash{\c_colon_str/}
\cs_new_protected:Nn \__stex_path_uri_set:NnN {
  \str_if_empty:nTF {#2} {
    \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{empty}
  }{
    \exp_args:NNNo \exp_args:NNno \seq_set_split:Nnn #1 \__stex_path_colonslash { \tl_to_str:n{#2} }
    \seq_pop_left:NN #1 \l__stex_path_auth_str
    \seq_if_empty:NTF #1 {
      \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{missing~authority}
    }{
      \exp_args:NNnx \seq_set_split:Nnn #1 ? {\exp_args:NNo \seq_use:Nn #1 \__stex_path_colonslash }
      \seq_pop_left:NN #1 \l__stex_path_path
      #3 \l__stex_path_path \l__stex_path_path
      \seq_if_empty:NTF #1 {
        \exp_args:NNo \__stex_path_uri_set:Nnxnn #1 \l__stex_path_auth_str
          {\stex_file_use:N \l__stex_path_path} {} {}
      }{
        \seq_pop_left:NN #1 \l__stex_path_mod
        \seq_if_empty:NTF #1 {
          \exp_args:NNo \__stex_path_uri_set:Nnxon #1 \l__stex_path_auth_str
            {\stex_file_use:N \l__stex_path_path} \l__stex_path_mod {}
        }{
          \seq_pop_left:NN #1 \l__stex_path_name
          \seq_if_empty:NTF #1 {
            \exp_args:NNo \__stex_path_uri_set:Nnxon #2 \l__stex_path_auth_str
              {\stex_file_use:N \l__stex_path_path} \l__stex_path_mod \l__stex_path_name
          }{
            \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{too~many~?s}
          }
        }
      }
    }
  }
  \stex_debug:nn{uris}{Set~\tl_to_str:n{#1}~to~\stex_uri_use:N #1}
}

\cs_new_protected:Nn \__stex_path_uri_set:Nnnnn{
  \tl_set:Nn #1 {
    \__stex_path_auth:n{ #2 }
    \__stex_path_path:n{ #3 }
    \__stex_path_module:n{ #4 }
    \__stex_path_name:n{ #5 }
  }
}
\cs_generate_variant:Nn\__stex_path_uri_set:Nnnnn {Nnxnn,Nnxon,Nnxoo}

\cs_new_protected:Nn \stex_uri_set:Nn {
  \__stex_path_uri_set:NnN #1 {#2} \stex_file_set:No
}
\cs_generate_variant:Nn \stex_uri_set:Nn {No, Nx}
\cs_new_protected:Nn \stex_uri_resolve:Nn {
  \__stex_path_uri_set:NnN #1 {#2} \stex_file_resolve:No
}
\cs_generate_variant:Nn \stex_uri_resolve:Nn {No, Nx}
\cs_new:Npn \__stex_path_uri_use:w \__stex_path_auth:n #1 \__stex_path_path:n #2 \__stex_path_module:n #3 \__stex_path_name:n #4 {
  #1\c_colon_str/ #2 \tl_if_empty:nF { #3 }{ ? #3
    \tl_if_empty:nF { #4 }{ ? #4 } }
}
\cs_new:Nn \stex_uri_use:N {
  \exp_args:Ne \cs_if_eq:NNTF { \tl_head:N #1 } \__stex_path_auth:n {
    \exp_after:wN \__stex_path_uri_use:w #1
  }{
    \msg_error:nnnn{stex}{error/invalid-uri}{#1}{Not~a~URI}
  }
}
\cs_new_protected:Npn \stex_uri_from_repo_file_nolang:NNNn {
  \__stex_path_from_repo_file:NNNNn \stex_file_split_off_lang:NN
}
\cs_new_protected:Npn \stex_uri_from_repo_file:NNNn {
  \__stex_path_from_repo_file:NNNNn \stex_file_split_off_ext:NN
}

\cs_new_protected:Nn \__stex_path_from_repo_file:NNNNn {
  #1 \l__stex_path_file #4
  \prop_if_exist:NTF #3 {
    \str_clear:N \l__stex_path_uri
    \prop_get:NnNF #3 {#5} \l__stex_path_uri {
      \prop_get:NnNF #3 {ns} \l__stex_path_uri {
        \__stex_path_uri_set:Nnxnn #2 {file}
          {\stex_file_use:N \l__stex_path_file} {} {}
      }
    }
    \str_if_empty:NF \l__stex_path_uri {\__stex_path_relativize:N #2}
  }{
    \exp_args:NNx \__stex_path_uri_set:Nnxnn #2 {\tl_to_str:n{file}}
      {\stex_file_use:N \l__stex_path_file} {} {}
  }
}

\cs_new_protected:Nn \__stex_path_relativize:N {
  \seq_set_eq:NN \l__stex_path_seq \l__stex_path_file
  \seq_map_inline:Nn \c_stex_mathhub_file { % mathhub path
    \seq_pop_left:NN \l__stex_path_seq \l__stex_path_tl
  }
  \stex_file_set:Nx \l__stex_path_path {\prop_item:Nn \l_stex_current_repository_prop {id} }
  \seq_map_inline:Nn \l__stex_path_path { % id
    \seq_pop_left:NN \l__stex_path_seq \l__stex_path_tl
  }
  \seq_pop_left:NN \l__stex_path_seq \l__stex_path_tl % source

  \stex_uri_set:Nx #1 { \l__stex_path_uri / \stex_file_use:N \l__stex_path_seq }
}
\cs_new_protected:Nn \stex_uri_from_current_file:Nn {
  \stex_uri_from_repo_file:NNNn #1 \l_stex_current_repository_prop
    \g_stex_current_file {#2}
}
\cs_new_protected:Nn \stex_uri_from_current_file_nolang:Nn {
  \stex_uri_from_repo_file_nolang:NNNn #1 \l_stex_current_repository_prop
    \g_stex_current_file {#2}
}
\cs_new_protected:Nn \stex_uri_add_module:NNn {
  \exp_args:Ne \cs_if_eq:NNTF { \tl_head:N #2 } \__stex_path_auth:n {
    \stex_pseudogroup_with:nn
      {\__stex_path_auth:n\__stex_path_path:n\__stex_path_module:n\__stex_path_name:n}
      {
        \cs_set:Npn \__stex_path_module:n ##1 {
          \tl_if_empty:nTF{##1}{
            \exp_not:N \__stex_path_module:n {#3}
          }{
            \msg_error:nnn{stex}{error/invalid-dpath}{#2}
          }
        }
        \cs_set:Npn \__stex_path_name:n ##1 {
          \tl_if_empty:nTF{##1}{
            \exp_not:N \__stex_path_name:n {}
          }{
            \msg_error:nnn{stex}{error/invalid-dpath}{#2}
          }
        }
        \tl_set:Nx #1 {#2}
      }
  }{
    \msg_error:nnnn{stex}{error/invalid-uri}{#2}{Not~a~URI}
  }
}
\cs_generate_variant:Nn \stex_uri_add_module:NNn {NNo}
\stex_get_env:Nnn\l__stex_path_str{PWD}{CD}
\stex_file_resolve:No \c_stex_pwd_file \l__stex_path_str
\seq_set_eq:NN \c_stex_main_file \c_stex_pwd_file
\seq_put_right:Nx \c_stex_main_file {\jobname\tl_to_str:n{.tex}}

\stex_debug:nn {files} {PWD:~\stex_file_use:N \c_stex_pwd_file}
\seq_gclear_new:N\g__stex_path_stack
\seq_gclear_new:N\g_stex_current_file
\cs_new_protected:Nn \stex_filestack_push:n {
  \exp_args:Nx \tl_if_eq:nnTF {\str_head:n{#1}} / {
    \str_set:Nn \l__stex_path_str {#1}
  }{
    \str_set:Nx \l__stex_path_str {\stex_file_use:N \c_stex_pwd_file / #1}
  }
  \stex_file_resolve:No \g_stex_current_file \l__stex_path_str
  \seq_gset_eq:NN \g_stex_current_file \g_stex_current_file
  \exp_args:NNx \seq_gpush:Nn \g__stex_path_stack {\stex_file_use:N \g_stex_current_file}
  \stex_get_document_uri:
  \stex_get_current_namespace:
}
\cs_new_protected:Nn \stex_filestack_pop: {
  \seq_if_empty:NF \g__stex_path_stack {
    \seq_gpop:NN \g__stex_path_stack \l__stex_path_str
  }
  \seq_if_empty:NTF \g__stex_path_stack {
    \seq_gset_eq:NN \g_stex_current_file \c_stex_main_file
  }{
    \seq_get:NN \g__stex_path_stack \l__stex_path_str
    \exp_args:NNo \stex_file_set:Nn \g_stex_current_file \l__stex_path_str
    \seq_gset_eq:NN \g_stex_current_file \g_stex_current_file
  }
  \stex_get_document_uri:
  \stex_get_current_namespace:
}

\AddToHook{file/before}{
  \tl_if_empty:NTF\CurrentFilePath{
    \exp_args:No \stex_filestack_push:n \CurrentFile
  }{
    \exp_args:Nx \stex_filestack_push:n { \CurrentFilePath / \CurrentFile }
  }
}
\AddToHook{file/after}{ \stex_filestack_pop: }
\str_if_empty:NTF\mathhub{
  \stex_get_env:Nn \l__stex_mathhub_str {MATHHUB}
  \str_if_empty:NTF \l__stex_mathhub_str {
    \sys_if_platform_windows:TF{
      \stex_get_env:Nn \l__stex_mathhub_str {homedrive\c_percent_str\c_percent_str homepath}
    }{
      \stex_get_env:Nn \l__stex_mathhub_str {HOME}
    }
    \ior_open:NnTF \g_tmpa_ior{\l__stex_mathhub_str/.stex/mathhub.path}{
      \group_begin:
        \escapechar=-1\catcode`\\=12
        \ior_str_get:NN \g_tmpa_ior \l__stex_mathhub_str
        \str_gset_eq:NN \l__stex_mathhub_str \l__stex_mathhub_str
      \group_end:
      \ior_close:N \g_tmpa_ior
      \stex_debug:nn{mathhub}{MathHub~directory~determined~from~home~directory}
    }{
      \str_clear:N \l__stex_mathhub_str
    }
  }{
    \stex_debug:nn{mathhub}{MathHub~directory~determined~from~environment~variable}
  }
}{
  \str_set_eq:NN \l__stex_mathhub_str \mathhub
}

\str_if_empty:NTF \l__stex_mathhub_str {
  \msg_warning:nn{stex}{warning/nomathhub}
  \seq_clear:N \c_stex_mathhub_file
  \str_clearn:N \mathhub
}{
  \stex_file_resolve:No \c_stex_mathhub_file \l__stex_mathhub_str
  \str_set:Nx \mathhub {\stex_file_use:N \c_stex_mathhub_file}
  \stex_debug:nn{mathhub}{MATHHUB:~\mathhub}
}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \stex_debug:nn{mathhub}{switching~to~archive~#1}
  \prop_set_eq:Nc \l_stex_current_repository_prop {
    c_stex_mathhub_#1_manifest_prop
  }
}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \seq_if_empty:NTF \c_stex_mathhub_file {
      \_stex_fatal_error:n{warning/nomathhub}
    }{
      \stex_debug:nn{mathhub}{Opening~archive:~#1}
      \__stex_mathhub_do_manifest:n { #1 }
    }
  }
}
\cs_generate_variant:Nn \stex_require_repository:n {o}

\cs_new_protected:Nn \__stex_mathhub_do_manifest:n {
  \__stex_mathhub_find_manifest:n {#1}
  \str_if_empty:NT \l__stex_mathhub_manifest_str {
    \_stex_fatal_error:nxx{error/norepository}
      {#1}{\stex_file_use:N \c_stex_mathhub_file}
  }
  \__stex_mathhub_parse_manifest:n {#1}
}

\cs_new_protected:Nn \__stex_mathhub_find_manifest:n {
  \str_clear:N \l__stex_mathhub_manifest_str
  \exp_args:NNnx \seq_set_split:Nnn \l__stex_mathhub_seq /
    {\stex_file_use:N \c_stex_mathhub_file / #1}
  \bool_set_true:N \l__stex_mathhub_bool
  \bool_while_do:Nn \l__stex_mathhub_bool {
    \tl_if_eq:NNTF \l__stex_mathhub_seq \c_stex_mathhub_file {
      \bool_set_false:N \l__stex_mathhub_bool
    }{
      \__stex_mathhub_check_manifest:
      \bool_if:NT \l__stex_mathhub_bool {
        \seq_pop_right:NN \l__stex_mathhub_seq \l__stex_mathhub_tl
      }
    }
  }
}
\cs_generate_variant:Nn \__stex_mathhub_find_manifest:n {x}

\cs_new_protected:Nn \__stex_mathhub_check_manifest: {
  \__stex_mathhub_check_manifest:n {MANIFEST.MF}
  \bool_if:NT \l__stex_mathhub_bool {
    \__stex_mathhub_check_manifest:n {META-INF/MANIFEST.MF}
    \bool_if:NT \l__stex_mathhub_bool {
      \__stex_mathhub_check_manifest:n {meta-inf/MANIFEST.MF}
    }
  }
}

\cs_new_protected:Nn \__stex_mathhub_check_manifest:n {
  \stex_debug:nn{mathhub}{Checking~\stex_file_use:N \l__stex_mathhub_seq / #1}
  \file_if_exist:nT {\stex_file_use:N \l__stex_mathhub_seq / #1} {
    \bool_set_false:N \l__stex_mathhub_bool
    \str_set:Nx \l__stex_mathhub_manifest_str {\stex_file_use:N \l__stex_mathhub_seq / #1}
  }
}

\ior_new:N \c__stex_mathhub_manifest_ior
\cs_new_protected:Nn \__stex_mathhub_parse_manifest:n {
  \ior_open:Nn \c__stex_mathhub_manifest_ior \l__stex_mathhub_manifest_str
  \prop_clear:N \l__stex_mathhub_prop
  \ior_map_inline:Nn \c__stex_mathhub_manifest_ior {
    \exp_args:NNo \seq_set_split:Nnn \l__stex_mathhub_seq \c_colon_str {##1}
    \seq_pop_left:NNT \l__stex_mathhub_seq \l__stex_mathhub_key {
      \exp_args:NNo \str_set:Nn \l__stex_mathhub_key \l__stex_mathhub_key
      \str_set:Nx \l__stex_mathhub_val {\seq_use:Nn \l__stex_mathhub_seq :}
      \str_set:Nx \l__stex_mathhub_val {\exp_args:No \tl_to_str:n \l__stex_mathhub_val}
      \str_case:Nn \l__stex_mathhub_key {
        {id}              {\prop_put:Nno \l__stex_mathhub_prop { id }      \l__stex_mathhub_val }
        {narration-base}  {\prop_put:Nno \l__stex_mathhub_prop { narr }    \l__stex_mathhub_val }
        {url-base}        {\prop_put:Nno \l__stex_mathhub_prop { docurl }  \l__stex_mathhub_val }
        {source-base}     {\prop_put:Nno \l__stex_mathhub_prop { ns }      \l__stex_mathhub_val }
        {ns}              {\prop_put:Nno \l__stex_mathhub_prop { ns }      \l__stex_mathhub_val }
      }
    }
  }
  \ior_close:N \c__stex_mathhub_manifest_ior
  \prop_gset_eq:cN { c_stex_mathhub_#1_manifest_prop } \l__stex_mathhub_prop
  \stex_debug:nn{mathhub}{Result: \prop_to_keyval:N \l__stex_mathhub_prop}
  \stex_persist:x {
    \prop_set_from_keyval:cn { c_stex_mathhub_#1_manifest_prop }{
      \exp_after:wN \prop_to_keyval:N
      \cs:w c_stex_mathhub_#1_manifest_prop \cs_end:
    }
  }
}
\bool_if:NF \c_stex_persist_mode_bool {
  \seq_if_empty:NF \c_stex_mathhub_file {
    \stex_file_starts_with:NNTF \c_stex_pwd_file \c_stex_mathhub_file {
      \__stex_mathhub_find_manifest:x { \stex_file_use:N \c_stex_pwd_file }
      \str_if_empty:NTF \l__stex_mathhub_manifest_str {
        \stex_debug:nn{mathhub}{Not~currently~in~a~MathHub~repository}
      }{
        \__stex_mathhub_parse_manifest:n { main }
        \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id}
          \l__stex_mathhub_str
        \prop_set_eq:cN { c_stex_mathhub_\l__stex_mathhub_str _manifest_prop }
          \c_stex_mathhub_main_manifest_prop
        \exp_args:No \stex_set_current_repository:n { \l__stex_mathhub_str }
        \stex_debug:nn{mathhub}{Current~repository:~
          \prop_item:Nn \l_stex_current_repository_prop {id}
        }
      }
    }{
      \stex_debug:nn{mathhub}{Not~currently~in~the~MathHub~directory}
    }
  }
}
\tl_new:N \g_stex_document_title
\cs_new_protected:Npn \STEXtitle #1 {
  \tl_if_empty:NT \g_stex_document_title {
    \tl_gset:Nn \g_stex_document_title { #1 }
  }
}
\cs_new_protected:Nn \stex_document_title:n {
  \tl_if_empty:NT \g_stex_document_title {
    \tl_gset:Nn \g_stex_document_title { #1 }
    \stex_annotate_invisible:n{\noindent
      \stex_annotate:nnn{stex:doctitle}{}{ #1 }
    \par}
  }
}

\AtBeginDocument {
  \let \STEXtitle \stex_document_title:n
  \tl_if_empty:NF \g_stex_document_title {
    \stex_annotate_invisible:n{\noindent
      \stex_annotate:nnn{stex:doctitle}{}{ \g_stex_document_title }
    \par}
  }
  \let\_stex_maketitle:\maketitle
  \def\maketitle{
    \tl_if_empty:NF \@title {
      \exp_args:No \stex_document_title:n \@title
    }
    \_stex_maketitle:
  }
}

\iow_new:N \c__stex_refs_iow
\AtBeginDocument{\iow_open:Nn \c__stex_refs_iow {\jobname.sref}}
\AtEndDocument{\iow_close:N \c__stex_refs_iow}
\tl_new:N \l_stex_current_doc_uri
\cs_new_protected:Nn \stex_get_document_uri: {
  \stex_uri_from_current_file:Nn \l_stex_current_doc_uri {narr}
  \stex_debug:nn{sref}{Document~URI:~\stex_uri_use:N \l_stex_current_doc_uri}
}
\seq_new:N \g__stex_refs_files_seq
\int_new:N \l__stex_refs_unnamed_counter_int

\cs_new_protected:Nn \__stex_refs_add_doc_ref:nn {
  \seq_if_in:NnTF \g__stex_refs_files_seq {#1} {
    \seq_if_in:cnF {g__stex_refs_#1_seq}{#2}{
      \seq_gput_left:cn{g__stex_refs_#1_seq}{#2}
    }
  }{
    \seq_gput_right:Nn \g__stex_refs_files_seq {#1}
    \seq_new:c{g__stex_refs_#1_seq}
    \seq_gput_left:cn{g__stex_refs_#1_seq}{#2}
  }
}
\cs_generate_variant:Nn \__stex_refs_add_doc_ref:nn {xo,xx}

\cs_new_protected:Npn \STEXInternalAuxAddDocRef #1 #2 {
  \__stex_refs_add_doc_ref:xx{\tl_to_str:n{#1}}{\tl_to_str:n{#2}}
}
\AtEndDocument{
  \cs_set:Npn \STEXInternalAuxAddDocRef #1 #2 {}
}
\cs_new_protected:Npn \STEXInternalSrefRestoreTarget #1#2#3#4#5 {}

\cs_new_protected:Nn \stex_ref_new_doc_target:n {
  \str_if_empty:nTF {#1}{
    \int_gincr:N \l__stex_refs_unnamed_counter_int
    \str_set:Nx \l__stex_refs_str {REF\int_use:N \l__stex_refs_unnamed_counter_int}
  }{
    \str_set:Nn \l__stex_refs_str {#1}
  }
  \stex_uri_add_module:NNo \l__stex_refs_uri \l_stex_current_doc_uri \l__stex_refs_str
  \stex_debug:nn{sref}{New~document~target:~\stex_uri_use:N \l__stex_refs_uri}
  \__stex_refs_add_doc_ref:xo {\stex_uri_use:N \l_stex_current_doc_uri} \l__stex_refs_str
  \stex_if_smsmode:F {
    \iow_now:Nx \c__stex_refs_iow {
      \STEXInternalSrefRestoreTarget
      {\stex_uri_use:N \l_stex_current_doc_uri}
      {\l__stex_refs_str}
      {\@currentcounter}
      {\@currentlabel}
      {
        \tl_if_exist:NT\@currentlabelname{
          \exp_args:No\exp_not:n\@currentlabelname
        }
      }
    }
    \exp_args:Nx\label{sref_ \stex_uri_use:N \l__stex_refs_uri}
    \iow_now:Nx\@auxout{
      \STEXInternalAuxAddDocRef
      {\stex_uri_use:N \l_stex_current_doc_uri}
      {\l__stex_refs_str}
    }
  }
}
\NewDocumentCommand \slabel {m} {\stex_ref_new_doc_target:n {#1}}
\stex_keys_define:nnnn{sref / 1}{}{
  % TODO get rid of this
  fallback  .code:n = {},
  pre       .code:n = {},
  post      .code:n = {}
}{archive file}
\stex_keys_define:nnnn{sref / 2}{}{}{archive file, title}
\cs_new_protected:Nn \__stex_refs_find_uri:n {
  \str_clear:N \l__stex_refs_uri_str
  \stex_debug:nn{sref}{
    File:~\l_stex_key_file_str^^J
    Repo:\l_stex_key_archive_str
  }
  \str_if_empty:NTF \l_stex_key_file_str {
    \stex_debug:nn{sref}{Empty.~Checking~current~file~for~#1}
    \seq_if_exist:cT{g__stex_refs_\stex_uri_use:N \l_stex_current_doc_uri _seq}{
      \exp_args:Nnx \__stex_refs_find_uri_in_file:nnn{#1}
        {\stex_uri_use:N \l_stex_current_doc_uri}\seq_map_break:
    }
    \str_if_empty:NT \l__stex_refs_uri_str {
      \seq_map_inline:Nn \g__stex_refs_files_seq {
        \__stex_refs_find_uri_in_file:nnn{#1}{##1}{\seq_map_break:n{\seq_map_break:}}
      }
    }
  }{
    \str_if_empty:NTF \l_stex_key_archive_str {
      \prop_if_exist:NTF \l_stex_current_repository_prop {
        \__stex_refs_find_uri_in_prop_file:N \l_stex_current_repository_prop
      }{
        \stex_file_resolve:Nx \l__stex_refs_file
          { \stex_file_use:N \g_stex_current_file / .. / \l_stex_key_file_str }
        \str_set:Nx \l__stex_refs_uri_str { file:/ \stex_file_use:N \l__stex_refs_file }
      }
    }{
      \stex_require_repository:o \l_stex_key_archive_str
      \prop_set_eq:Nc \l__stex_refs_prop { c_stex_mathhub_\l_stex_key_archive_str _manifest_prop }
      \__stex_refs_find_uri_in_prop_file:N \l__stex_refs_prop
    }
  }
}

\cs_new_protected:Nn \__stex_refs_find_uri_in_prop_file:N {
  \str_set:Nx \l__stex_refs_uri_str {
    \stex_file_use:N \c_stex_mathhub_file /
    \prop_item:Nn #1 {id} /
      source / \l_stex_key_file_str
  }
  \stex_file_resolve:No \l__stex_refs_file \l__stex_refs_uri_str
  \stex_uri_from_repo_file:NNNn \l__stex_refs_uri #1
    \l__stex_refs_file {narr}
  \str_set:Nx \l__stex_refs_uri_str {\stex_uri_use:N \l__stex_refs_uri}
}

\cs_new_protected:Nn \__stex_refs_find_uri_in_file:nnn {
  \stex_debug:nn{sref}{Checking~file~#2}
  \seq_map_inline:cn{g__stex_refs_#2_seq}{
    \str_if_eq:nnT{#1}{##1}{
      \str_set:Nx \l__stex_refs_uri_str {\stex_uri_use:N \l_stex_current_doc_uri}
      \stex_debug:nn{sref}{Found.}
      #3
    }
  }
}
\cs_new_protected:Nn \__stex_refs_do_autoref:n {
  \cs_if_exist:cTF{autoref}{
     \exp_args:Nx\autoref{sref_#1}
   }{
     \exp_args:Nx\ref{sref_#1}
   }
}

\cs_new_protected:Nn \__stex_refs_do_sref:nn {
  \str_if_empty:NTF \l__stex_refs_uri_str {
    \str_if_empty:NTF \l_stex_key_file_str {
      \stex_debug:nn{sref}{autoref~on~#1}
      \__stex_refs_do_autoref:n{#1}
    }{
      \stex_debug:nn{sref}{srefin~on~#1}
      \stex_keys_set:nn { sref / 2 }{ #2 }
      \__stex_refs_do_sref_in:n{#1}
    }
  }{
    \exp_args:NNo \seq_if_in:NnTF \g__stex_refs_files_seq \l__stex_refs_uri_str {
      \stex_debug:nn{sref}{Using~ref~file~\l__stex_refs_uri_str}
      \exp_args:Nnx \seq_if_in:cnTF{g_stex_ref_\l__stex_refs_uri_str _seq}{\detokenize{#1}}{
        \stex_debug:nn{sref}{Reference~found~in~ref~files;~autoref~on~\l__stex_refs_uri_str?#1}
        \__stex_refs_do_autoref:n{\l__stex_refs_uri_str?#1}
      }{
        \str_if_empty:NTF \l_stex_key_file_str {
          \stex_debug:nn{sref}{in~empty;~autoref~on~\l__stex_refs_uri_str?#1}
          \__stex_refs_do_autoref:n{\l__stex_refs_uri_str?#1}
        }{
          \stex_debug:nn{sref}{in~non-empty;~srefin~on~\l__stex_refs_uri_str?#1}
          \stex_keys_set:nn { sref / 2 }{ #2 }
          \__stex_refs_do_sref_in:n{#1}
        }
      }
    }{
      \stex_debug:nn{sref}{No~ref~file~found~for~\l__stex_refs_uri_str}
      \str_if_empty:NTF \l_stex_key_file_str {
        \stex_debug:nn{sref}{in~empty;~autoref~on~\l__stex_refs_uri_str?#1}
        \__stex_refs_do_autoref:n{\l__stex_refs_uri_str?#1}
      }{
        \stex_debug:nn{sref}{in~non-empty;~srefin~on~\l__stex_refs_uri_str?#1}
        \stex_keys_set:nn { sref / 2 }{ #2 }
        \__stex_refs_do_sref_in:n{#1}
      }
    }
  }
}

\cs_new_protected:Nn \__stex_refs_do_sref_in:n {
  \stex_debug:nn{sref}{In: \l_stex_key_file_str^^JRepo:\l_stex_key_archive_str}
  \stex_debug:nn{sref}{URI: \l__stex_refs_uri_str?#1}
  %\msg_warning:nnn{stex}{warning/smsmissing}{<filename>}
  \begingroup\catcode13=9\relax\catcode10=9\relax
    \str_if_empty:NTF \l_stex_key_archive_str {
      \prop_if_exist:NTF \l_stex_current_repository_prop {
        \str_set:Nx \l__stex_refs_file_str {
          \stex_file_use:N \c_stex_mathhub_file /
          \prop_item:Nn \l_stex_current_repository_prop { id }
          / source / \l_stex_key_file_str .sref
        }
      }{
        \str_set:Nx \l__stex_refs_file_str {
          \stex_file_use:N \g_stex_current_file / .. / \l_stex_key_file_str . sref
        }
      }
    }{
      \str_set:Nx \l__stex_refs_file_str {
        \stex_file_use:N \c_stex_mathhub_file / \l_stex_key_archive_str
        / source / \l_stex_key_file_str . sref
      }
    }
    \stex_file_resolve:No \l__stex_refs_file \l__stex_refs_file_str
    \str_set:Nx \l__stex_refs_file_str {\stex_file_use:N \l__stex_refs_file }
    \stex_debug:nn{sref}{File: \l__stex_refs_file_str }

    \exp_args:No \IfFileExists \l__stex_refs_file_str {
      \tl_clear:N \l__stex_refs_return_tl
      \str_set:Nn \l__stex_refs_id_str {#1}
      \let\STEXInternalSrefRestoreTarget\__stex_refs_restore_target:nnnnn
      \use:c{@ @ input}{\l__stex_refs_file_str}
      \exp_args:No \tl_if_empty:nTF \l__stex_refs_return_tl {
        \exp_args:Nnno \msg_warning:nnnn{stex}{warning/smslabelmissing}\l__stex_refs_file_str{#1}
        \__stex_refs_do_autoref:n{
          \str_if_empty:NF\l__stex_refs_uri_str{\l__stex_refs_uri_str?}#1
        }
      }{
        \l__stex_refs_return_tl
      }
    }{
      \exp_args:Nnno \msg_warning:nnn{stex}{warning/smsmissing}\l__stex_refs_file_str
      \__stex_refs_do_autoref:n{
        \str_if_empty:NF\l__stex_refs_uri_str{\l__stex_refs_uri_str?}#1
      }
    }
  \endgroup
}

\cs_new_protected:Nn \__stex_refs_restore_target:nnnnn {
  \str_if_empty:NTF \l__stex_refs_uri_str {
    \exp_args:No \str_if_eq:nnT \l__stex_refs_id_str {#2}{
      \tl_set:Nn \l__stex_refs_return_tl {
        \use:c{#3autorefname}~#4\tl_if_empty:nF{#5}{~(#5)}~in~
        \tl_if_empty:NTF\l_stex_key_title_tl{
          ???
        }\l_stex_key_title_tl
      }
    }
  }{
    \stex_debug:nn{sref}{\l__stex_refs_uri_str{}~ == ~ #1 ~ ?}
    \exp_args:No \str_if_eq:nnT \l__stex_refs_uri_str {#1}{
      \stex_debug:nn{sref}{\l__stex_refs_id_str~ == ~ #2 ~ ?}
      \exp_args:No \str_if_eq:nnT \l__stex_refs_id_str {#2}{
        \stex_debug:nn{sref}{success!}
        \tl_set:Nn \l__stex_refs_return_tl {
          \use:c{#3autorefname}~#4\tl_if_empty:nF{#5}{~(#5)}~in~
          \tl_if_empty:nTF\l_stex_key_title_tl{
            ???
          }\l_stex_key_title_tl
        }
        \endinput
      }
    }
  }
}
\NewDocumentCommand \sref { O{} m O{}}{
  \stex_keys_set:nn { sref / 1 }{ #1 }
  \__stex_refs_find_uri:n { #2 }
  \__stex_refs_do_sref:nn{#2}{#3}
}
\NewDocumentCommand \extref { O{} m m}{
  \stex_keys_set:nn { sref / 1 }{ #1 }
  \__stex_refs_find_uri:n { #2 }
  \stex_keys_set:nn { sref / 2 }{ #3 }
  \str_if_empty:NT \l_stex_key_file_str {
    \msg_error:nn{stex}{error/extrefmissing}
  }
  \__stex_refs_do_sref_in:n{#2}
}
\cs_new_protected:Nn \stex_ref_new_sym_target:n {
  % TODO
}
\NewDocumentCommand \srefsym { O{} m}{
  \stex_get_symbol:n { #2 }
  \__stex_refs_sym_aux:nn{#1}{\l_stex_get_symbol_uri_str}
}

\cs_new_protected:Nn \__stex_refs_sym_aux:nn {} % TODO
\cs_new_protected:Npn \srefsymuri #1 #2 { % TODO
  #2%\__stex_refs_sym_aux:nn{linktext={#2}}{#1}
}
\tl_new:N \g__stex_smsmode_allowed_tl
\tl_new:N \g__stex_smsmode_allowed_escape_tl
\seq_new:N \g__stex_smsmode_allowedenvs_seq
\cs_new_protected:Nn \stex_sms_allow:N {
  \tl_gput_right:Nn \g__stex_smsmode_allowed_tl {#1}
}
\cs_new_protected:Nn \stex_sms_allow_escape:N {
  \tl_gput_right:Nn \g__stex_smsmode_allowed_escape_tl {#1}
}
\cs_new_protected:Nn \stex_sms_allow_env:n {
  \exp_args:NNx \seq_gput_right:Nn \g__stex_smsmode_allowedenvs_seq {\tl_to_str:n{#1}}
}
\stex_sms_allow:N \makeatletter
\stex_sms_allow:N \makeatother
\stex_sms_allow:N \ExplSyntaxOn
\stex_sms_allow:N \ExplSyntaxOff
\stex_sms_allow:N \rustexBREAK
\bool_new:N \g__stex_smsmode_bool
\bool_set_false:N \g__stex_smsmode_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g__stex_smsmode_bool \prg_return_true: \prg_return_false:
}
\tl_new:N \g__stex_smsmode_allowed_import_tl
\seq_new:N \g__stex_smsmode_allowed_import_env_seq
\cs_new_protected:Nn \stex_sms_allow_import:Nn {
  \tl_gput_right:Nn \g__stex_smsmode_allowed_import_tl {#1}
  \tl_set:cn{\tl_to_str:n{#1}~-~smsmode} {#2}
}
\cs_new_protected:Nn \stex_sms_allow_import_env:nn {
  \exp_args:NNx \seq_gput_right:Nn \g__stex_smsmode_allowed_import_env_seq {\tl_to_str{#1}}
  \tl_set:cn{\tl_to_str:n{#1}~-~env~-~smsmode} {#2}
}

\tl_new:N \g_stex_sms_import_code
\cs_new_protected:Nn \__stex_smsmode_in_smsmode:n { \stex_suppress_html:n {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_true:N \g__stex_smsmode_bool
    \bool_set_false:N \_stex_html_do_output_bool
    #1
  }
  \box_clear:N \l_tmpa_box
} }

\quark_new:N \q__stex_smsmode_break

\cs_new_protected:Nn \__stex_smsmode_start_smsmode:n {
  \everyeof{\q__stex_smsmode_break\exp_not:N}
  \exp_after:wN \exp_after:wN \exp_after:wN
  \stex_smsmode_do:
  \cs:w @ @ input\cs_end: "#1" \relax
}

\cs_new_protected:Nn \stex_file_in_smsmode:nn {
  \seq_gclear:N \l__stex_smsmode_importmodules_seq
  \seq_gclear:N \l__stex_smsmode_sigmodules_seq
  \tl_clear:N \g_stex_sms_import_code
  \group_begin:
    #2
    \stex_filestack_push:n{#1}
    \__stex_smsmode_in_smsmode:n {
      \let \__stex_smsmode_do_aux_curr:N \__stex_smsmode_do_aux_imports:N
      \tl_map_inline:Nn \g__stex_smsmode_allowed_import_tl {
        \use:c{\tl_to_str:n{##1}~-~smsmode}
      }
      \seq_map_inline:Nn \g__stex_smsmode_allowed_import_env_seq {
        \use:c{\tl_to_str:n{##1}~-~env~-~smsmode}
      }
      \__stex_smsmode_start_smsmode:n{#1}
    }
    \g_stex_sms_import_code
    \__stex_smsmode_in_smsmode:n {
      \let \__stex_smsmode_do_aux_curr:N \__stex_smsmode_do_aux_normal:N
      \__stex_smsmode_start_smsmode:n{#1}
    }
    \stex_filestack_pop:
  \group_end:
}
\cs_generate_variant:Nn \stex_file_in_smsmode:nn {on}
\cs_new_protected:Nn \stex_smsmode_do: {
  \stex_if_smsmode:T {
    \__stex_smsmode_do:w
  }
}

\cs_new:Nn \__stex_smsmode_check_cs:NNn {
  \exp_after:wN\if\exp_after:wN\relax\exp_not:N#3
  \exp_after:wN#1\exp_after:wN#3\else
  \exp_after:wN#2\fi
}

\cs_new_protected:Npn \__stex_smsmode_do:w #1 {
  \exp_args:Nx \tl_if_empty:nTF { \tl_tail:n{ #1 }}{
    \__stex_smsmode_check_cs:NNn \__stex_smsmode_do_aux:N \__stex_smsmode_do:w { #1 }
  }{
    \__stex_smsmode_do:w
  }
}

\cs_new_protected:Nn \__stex_smsmode_do_aux:N {
  \cs_if_eq:NNF #1 \q__stex_smsmode_break {
    \__stex_smsmode_do_aux_curr:N #1
  }
}

\cs_new_protected:Nn \__stex_smsmode_do_aux_imports:N {
 % \stex_debug:nn{sms}{Checking~\tl_to_str:n{#1}~in~import}
  \tl_if_in:NnTF \g__stex_smsmode_allowed_import_tl {#1} {
    \stex_debug:nn{sms}{Executing~\tl_to_str:n{#1}~in~import}
    #1
  }{
    \cs_if_eq:NNTF \begin #1 {
      \__stex_smsmode_check_begin:Nn \g__stex_smsmode_allowed_import_env_seq
    }{
      \cs_if_eq:NNTF \end #1 {
        \__stex_smsmode_check_end:Nn \g__stex_smsmode_allowed_import_env_seq
      }{
        \__stex_smsmode_do:w
      }
    }
  }
}

\cs_new_protected:Nn \__stex_smsmode_do_aux_normal:N {
 % \stex_debug:nn{sms}{Checking~\tl_to_str:n{#1}~in~sms~mode}
  \tl_if_in:NnTF \g__stex_smsmode_allowed_tl {#1} {
    \stex_debug:nn{sms}{Executing~\tl_to_str:n{#1}}
    #1\__stex_smsmode_do:w
  }{
    \tl_if_in:NnTF \g__stex_smsmode_allowed_escape_tl {#1} {
      \stex_debug:nn{sms}{Executing~escaped~\tl_to_str:n{#1}}
      #1
    }{
      \cs_if_eq:NNTF \begin #1 {
        \__stex_smsmode_check_begin:Nn \g__stex_smsmode_allowedenvs_seq
      }{
        \cs_if_eq:NNTF \end #1 {
          \__stex_smsmode_check_end:Nn \g__stex_smsmode_allowedenvs_seq
        }{
          \__stex_smsmode_do:w
        }
      }
    }
  }
}

\cs_new_protected:Nn \__stex_smsmode_check_begin:Nn {
 % \stex_debug:nn{sms}{Checking~environment~#2}
  \seq_if_in:NxTF #1 { \tl_to_str:n{#2} }{
    \stex_debug:nn{sms}{Environment~#2}
    \begin{#2}
  }{
    \__stex_smsmode_do:w
  }
}
\cs_new_protected:Nn \__stex_smsmode_check_end:Nn {
  \seq_if_in:NxTF #1 { \tl_to_str:n{#2} }{
    \stex_debug:nn{sms}{End~Environment~#2}
    \end{#2}\__stex_smsmode_do:w
  }{
    \str_if_eq:nnTF{#2}{document} \endinput \__stex_smsmode_do:w
  }
}
\str_new:N \l_stex_current_module_str
\cs_new:Nn \stex_current_module_prop: {
  \exp_after:wN \exp_not:N \cs:w c_stex_module_\l_stex_current_module_str _prop \cs_end:
}
\seq_new:N \l_stex_all_modules_seq
\tl_set:Nn \g_stex_every_module_tl {
  \stex_metagroup_new:o \l_stex_current_module_str
}
\cs_new_protected:Nn \stex_every_module:n {
  \tl_gput_right:Nn \g_stex_every_module_tl { #1 }
}
\cs_new_protected:Nn \__stex_module_setup_get_uri_str:n {
  \str_clear:N \l__stex_module_setup_ns_str
  \stex_map_uri:Nnnnn \l_stex_current_ns_uri {
    \str_set:Nx \l__stex_module_setup_ns_str{##1\c_colon_str/}
  }{
    \seq_set_split:Nnn \l__stex_module_setup_seq / {##1}
    \seq_pop_right:NN \l__stex_module_setup_seq \l__stex_module_setup_seg
    \exp_args:No \str_if_eq:nnF \l__stex_module_setup_seg {#1} {
      \seq_put_right:No \l__stex_module_setup_seq \l__stex_module_setup_seg
    }
    \tl_put_right:Nx \l__stex_module_setup_ns_str {\seq_use:Nn \l__stex_module_setup_seq /}
  }{}{}
}

\cs_new_protected:Nn \__stex_module_setup_setup_top_nosig:n {
  \stex_if_module_exists:nTF{\l__stex_module_setup_ns_str?#1}{
    \stex_debug:nn{modules}{(already exists)}
  }{
    \prop_clear:N \l__stex_module_setup_prop
    \prop_put:Nnn \l__stex_module_setup_prop {name} { #1 }
    \prop_put:Nno \l__stex_module_setup_prop {ns} \l__stex_module_setup_ns_str
    \tl_gclear:c{c_stex_module_ \l__stex_module_setup_ns_str ? #1 _code}
    \tl_gclear:c{c_stex_module_ \l__stex_module_setup_ns_str ? #1 _dependencies }
    \tl_gclear:c{c_stex_module_ \l__stex_module_setup_ns_str ? #1 _declarations }
    \tl_gclear:c{c_stex_module_ \l__stex_module_setup_ns_str ? #1 _notations }
    % \stex_debug:nn{module}{creating~c_stex_module_ \l__stex_module_setup_ns_str ? #1 _prop}
    \prop_gset_eq:cN {c_stex_module_ \l__stex_module_setup_ns_str ? #1 _prop}\l__stex_module_setup_prop
  }
  \str_set:Nx \l_stex_current_module_str {\l__stex_module_setup_ns_str?#1}
  \seq_put_right:No \l_stex_all_modules_seq \l_stex_current_module_str
}

\cs_new_protected:Nn \__stex_module_setup_setup_top_sig:n {
  \stex_if_module_exists:nTF{\l__stex_module_setup_ns_str?#1}{
    \stex_debug:nn{modules}{(already exists)}
  }{
    \stex_debug:nn{modules}{(needs loading)}
    \TODO
  }
  \stex_if_smsmode:F { % WHY?
    \stex_activate_module:x {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }
  }
  \str_set:Nx\l_stex_current_module_str{\l__stex_module_setup_ns_str?#1}
}

\cs_new_protected:Nn \__stex_module_setup_setup_top:n {
  \__stex_module_setup_get_uri_str:n{#1}
  \stex_debug:nn{module}{Module~URI:~\l__stex_module_setup_ns_str?#1}
  \str_if_empty:NTF \l_stex_key_sig_str
  \__stex_module_setup_setup_top_nosig:n \__stex_module_setup_setup_top_sig:n {#1}
  \g_stex_every_module_tl
  \__stex_module_setup_load_meta:
}

\cs_new_protected:Nn \__stex_module_setup_setup_nested:n {
  \str_set:Nx \l__stex_module_setup_ns_str {\prop_item:cn{
    c_stex_module_ \l_stex_current_module_str _prop
  }{ns}}
  \exp_args:Nx \__stex_module_setup_setup_top_nosig:n {\prop_item:cn{
    c_stex_module_ \l_stex_current_module_str _prop
  }{name} / #1}
  \stex_debug:nn{module}{Nested~Module~URI:~\l_stex_current_module_str}
  \seq_put_right:No \l_stex_all_modules_seq \l_stex_current_module_str
  \stex_metagroup_new:o \l_stex_current_module_str
}

\bool_new:N \l_stex_in_meta_bool
\bool_set_false:N \l_stex_in_meta_bool

\cs_new_protected:Nn \__stex_module_setup_load_meta: {
  \tl_if_empty:NF \l_stex_metatheory_uri {
    \stex_pseudogroup_with:nn{\l_stex_in_meta_bool}{
      \TODO
    }
  }
}

\cs_new_protected:Npn \stex_module_setup:n {
  \stex_if_in_module:TF \__stex_module_setup_setup_nested:n \__stex_module_setup_setup_top:n
}

\cs_new:Nn \stex_close_module: {
  \stex_if_smsmode:T {
    \stex_persist:x{
      \prop_set_from_keyval:Nn \stex_current_module_prop: {
        \exp_after:wN \prop_to_keyval:N \cs:w c_stex_module_\l_stex_current_module_str _prop\cs_end:
      }

      \tl_set:cn{c_stex_module_\l_stex_current_module_str _dependencies}{
        \use:c{c_stex_module_\l_stex_current_module_str _dependencies}
      }
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _declarations}{
        \use:c{c_stex_module_\l_stex_current_module_str _declarations}
      }
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _notations}{
        \use:c{c_stex_module_\l_stex_current_module_str _notations}
      }

      % TODO more
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _code}{
        \exp_after:wN \exp_after:wN \exp_after:wN \exp_not:n
        \exp_after:wN \exp_after:wN \exp_after:wN \exp_not:n
        { \cs:w c_stex_module_\l_stex_current_module_str _code \cs_end: }
      }
    }
  }
  \stex_debug:nn{module}{
    Closing~module~\l_stex_current_module_str^^J
    Code:~\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _code\endcsname^^J
    Imports:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _dependencies\endcsname^^J
    Declarations:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _declarations\endcsname^^J
    Notations:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _notations\endcsname^^J
  }
}
\tl_new:N \l_stex_metatheory_uri
\cs_new_protected:Nn \__stex_modules_set_metatheory:nn {
  %\stex_import_module_uri:nn { #1 } { #2 }
  %\stex_import_require_module:nnnn
  %{ \l_stex_import_ns_str } { \l_stex_import_archive_str }
  %{ \l_stex_import_path_str } { \l_stex_import_name_str }
  %\str_set:Nx \l_stex_metatheory_str { \l_stex_import_ns_str ? \l_stex_import_name_str }
  \TODO
}

\NewDocumentCommand \setmetatheory {O{} m}{
  \__stex_modules_set_metatheory:nn { #1 }{ #2 }
  \stex_smsmode_do:
}
\stex_keys_define:nnnn{smodule}{
  \str_clear:N \l_stex_key_sig_str
}{
  %meta          .str_set_x:N  = \l_stex_key_metatheory_str ,
  meta          .code:n       = {
    \str_if_empty:nTF {#1}{
      \tl_clear:N \l_stex_metatheory_uri
    }{
      \stex_uri_resolve:Nx \l_stex_metatheory_uri { #1 }
    }
  },
  ns            .code:n       = {
    \stex_uri_resolve:Nx \l_stex_current_ns_uri { #1 }
  } ,
  lang          .code:n       = {
    \stex_set_language:n { #1 }
  } ,
  sig           .str_set_x:N  = \l_stex_key_sig_str ,
  creators      .code:n       = {} , % todo ?
  contributors  .code:n       = {} , % todo ?
  srccite       .code:n       = {}   % todo ?
}{id, title, style, deprecate}
\stex_new_stylable_env:nnnnnn {module} {O{} m}{
  \stex_keys_set:nn { smodule }{ #1 }
  \_stex_do_deprecation:n{#2}
  \exp_args:Nx \stex_module_setup:n { \tl_to_str:n{ #2 } }

  \stex_if_do_html:T {
    \begin{stex_annotate_env} {stex:theory} {
      \l_stex_current_module_str
    }
    \stex_annotate_invisible:nnn{stex:header}{}{
      \stex_annotate:nnn{stex:language}{ \l_stex_current_language_str}{}
      \stex_annotate:nnn{stex:signature}{ \l_stex_key_sig_str }{}
      \tl_if_empty:NF \l_stex_metatheory_uri {
        \stex_annotate:nnn{stex:metatheory}{ \stex_uri_use:N \l_stex_metatheory_uri }
      }
      %\str_if_empty:NF \thisstyle {
      %  \stex_annotate:nnn{stex:type}{\thisstyle}{}
      %}
    }
  }
  \stex_if_smsmode:F \stex_style_apply:

  \stex_smsmode_do:
}{
  \stex_close_module:
  \stex_if_smsmode:F \stex_style_apply:
  \stex_if_do_html:T{ \end{stex_annotate_env} }
}{}{}

\stex_sms_allow_env:n{smodule}
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \str_if_empty:NTF \l_stex_current_module_str
    \prg_return_false: \prg_return_true:
}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_do_up_to_module:n {
  \exp_args:No \stex_metagroup_do_in:nn \l_stex_current_module_str {#1}
}
\cs_generate_variant:Nn \stex_do_up_to_module:n {x}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \tl_gput_right:cn {c_stex_module_\l_stex_current_module_str _code} { #1 }
}
\cs_generate_variant:Nn \stex_add_to_current_module:n {x}
\cs_new_protected:Nn \_stex_morphism:nnnn {
  \exp_not:N \_stex_morphism:nnnn
  {#1}{#2}{#3}{\exp_not:n{#4}}
  %\msg_error:nnn{stex}{error/misused-importmodule}{#1:#2}
}
\cs_new_protected:Nn \stex_add_module_dependency:nnnn {
  \tl_gput_left:cn {c_stex_module_\l_stex_current_module_str _dependencies} {
    \_stex_morphism:nnnn{#1}{#2}{#3}{#4}
  }
}
\cs_generate_variant:Nn \stex_add_module_dependency:nnnn {nonn,oonn}
\cs_new_protected:Nn \stex_iterate_modules:nn {
  \__stex_modules_iterate_setup:n{#2}
  \stex_pseudogroup_with:nn{\_stex_morphism:nnn}{
    \cs_set:Npn \_stex_morphism:nnnn ##1 ##2 ##3 ##4 {
      \bool_if:NT \l__stex_modules_mod_bool {
        %\stex_debug:nn{}{Checking~##2~<:~#1}
        \stex_str_if_ends_with:nnT{##2}{#1}{
          %\stex_debug:nn{}{true}
          \exp_args:No \__stex_modules_cs:nnnn{\l__stex_modules_prefix_str##1}{##2}{##3}{##4}
        }
        \tl_if_empty:nTF{##1}{
          \__stex_modules_iterate_module:n{##2}
        }{
          \stex_pseudogroup:nn{
            \str_put_right:Nn \l__stex_modules_prefix_str{##1/}
            \__stex_modules_iterate_module:n{##2}
          }{
            \stex_pseudogroup_restore:N \l__stex_modules_prefix_str
          }
        }
      }
    }
    \seq_map_inline:Nn \l_stex_all_modules_seq {
      \exp_args:NNo\seq_if_in:NnF \l__stex_modules_mod_seq {##1}{
        \exp_args:Nno \_stex_morphism:nnnn {}{##1}{}{}
        \__stex_modules_iterate_module:n{##1}
      }
    }
  }
  \l__stex_modules_mod_tl
}
\cs_new_protected:Nn \stex_iterate_modules:n {
  \__stex_modules_iterate_modules:nn{#1}{
    \str_if_empty:NF \l_stex_current_module_str {
      \exp_args:Nno \_stex_morphism:nnnn {} \l_stex_current_module_str{top}{}
      \exp_args:No \__stex_modules_iterate_module:n \l_stex_current_module_str
    }
    \bool_if:NT \l__stex_modules_mod_bool {
      \seq_map_inline:Nn \l_stex_all_modules_seq {
        \exp_args:NNo\seq_if_in:NnF \l__stex_modules_mod_seq {##1}{
          \exp_args:Nno \_stex_morphism:nnnn {}{##1}{}{}
          \__stex_modules_iterate_module:n{##1}
        }
      }
    }
  }
}

\cs_new_protected:Nn \__stex_modules_iterate_setup:n {
  \seq_clear:N \l__stex_modules_mod_seq
  \bool_set_true:N \l__stex_modules_mod_bool
  \tl_clear:N \l__stex_modules_mod_tl
  \str_clear:N \l__stex_modules_prefix_str
  \cs_set:Npn \stex_iterate_break: {\bool_set_false:N \l__stex_modules_mod_bool}
  \cs_set:Npn \stex_iterate_break:n ##1 {
    \stex_iterate_break:
    \tl_set:Nn \l__stex_modules_mod_tl {##1}
  }
  \cs_set:Npn \__stex_modules_cs:nnnn ##1 ##2 ##3 ##4 { #1 }

}

\cs_new_protected:Nn \__stex_modules_iterate_modules:nn {
  \__stex_modules_iterate_setup:n {#1}
  \stex_pseudogroup_with:nn{\_stex_morphism:nnn}{
    \cs_set:Npn \_stex_morphism:nnnn ##1 ##2 ##3 ##4 {
      \bool_if:NT \l__stex_modules_mod_bool {
        \exp_args:No \__stex_modules_cs:nnnn{\l__stex_modules_prefix_str##1}{##2}{##3}{##4}
        \tl_if_empty:nTF{##1}{
          \__stex_modules_iterate_module:n{##2}
        }{
          \stex_pseudogroup:nn{
            \str_put_right:Nn \l__stex_modules_prefix_str{##1/}
            \__stex_modules_iterate_module:n{##2}
          }{
            \stex_pseudogroup_restore:N \l__stex_modules_prefix_str
          }
        }
      }
    }
  #2
  }
  \l__stex_modules_mod_tl
}

\cs_new_protected:Nn \__stex_modules_iterate_module:n {
  \bool_if:NT \l__stex_modules_mod_bool {
    \exp_args:NNo\seq_if_in:NnF \l__stex_modules_mod_seq {\l__stex_modules_prefix_str #1}{
      \seq_put_right:No \l__stex_modules_mod_seq {\l__stex_modules_prefix_str #1}
      \use:c{c_stex_module_#1_dependencies}
    }
  }
}
\cs_new_protected:Nn \_stex_symbol:nnnnnnn {
  \exp_not:N \_stex_symbol:nnnnnnn
  {#1}{#2}{#3}{#4}{#5}{#6}{\exp_not:n{#7}}
}

\cs_new_protected:Nn \stex_add_module_decl:nnnnnnn {
  \tl_gput_left:cn {c_stex_module_\l_stex_current_module_str _declarations} {
    \_stex_symbol:nnnnnnn{#1}{#2}{#3}{#4}{#5}{#6}{#7}
  }
}
\cs_new_protected:Nn \stex_iterate_decls:n {
  \cs_set:Npn \__stex_modules_sym_cs:nnnnnnnn
  ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
    #1
  }
  \stex_pseudogroup_with:nn{\_stex_symbol:nnnnnnn}{
    \stex_iterate_modules:n{
      \cs_set:Npn \_stex_symbol:nnnnnnn
      ####1 ####2 ####3 ####4 ####5 ####6 ####7 {
        \bool_if:NT \l__stex_modules_mod_bool {
          \__stex_modules_sym_cs:nnnnnnnn {##2}{####1}{####2}{####3}
          {####4}{####5}{####6}{####7}
        }
      }
      ##4
      \use:c{c_stex_module_##2_declarations}
    }
  }
}
\cs_new_protected:Nn \stex_iterate_decls:nn {
  \cs_set:Npn \__stex_modules_sym_cs:nnnnnnnn
  ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
    #2
  }
  \stex_pseudogroup_with:nn{\_stex_symbol:nnnnnnn}{
    \stex_iterate_modules:nn{#1}{
      \cs_set:Npn \_stex_symbol:nnnnnnn
      ####1 ####2 ####3 ####4 ####5 ####6 ####7 {
        \bool_if:NT \l__stex_modules_mod_bool {
          \__stex_modules_sym_cs:nnnnnnnn {##2}{####1}{####2}{####3}
          {####4}{####5}{####6}{####7}
        }
      }
      ##4
      \use:c{c_stex_module_##2_declarations}
    }
  }
}
\cs_new_protected:Nn \_stex_notation:nnnn {
  \exp_not:N \_stex_notation:nnnn
  {#1}{#2}{#3}{\exp_not:n{#4}}
}
\cs_new_protected:Nn \stex_add_module_notation:nnnn {
  \tl_gput_right:cn {c_stex_module_\l_stex_current_module_str _notations} {
    \_stex_notation:nnnn{#1}{#2}{#3}{#4}
  }
}
\cs_generate_variant:Nn \stex_add_module_notation:nnnn {eoex}
\cs_new_protected:Nn \stex_execute_in_module:n { \stex_if_in_module:TF {
  \stex_add_to_current_module:n { #1 }
  \stex_do_up_to_module:n { #1 }
}{ #1 }}
\cs_generate_variant:Nn \stex_execute_in_module:n {x}
\NewDocumentCommand \STEXexport {} {
  \ExplSyntaxOn
  \__stex_modules_export:n
}
\cs_new_protected:Nn \__stex_modules_export:n {
  \ignorespacesandpars#1\ExplSyntaxOff
  \stex_add_to_current_module:n { \ignorespacesandpars#1}
  \stex_smsmode_do:
}
\stex_deactivate_macro:Nn \STEXexport {module~environments}
\stex_sms_allow_escape:N \STEXexport
\stex_every_module:n {\stex_reactivate_macro:N \STEXexport}
\cs_new_protected:Nn \stex_get_current_namespace: {
  \stex_uri_from_current_file_nolang:Nn \l_stex_current_ns_uri {source-base}
  \stex_debug:nn{modules}{Namespace~URI:~\stex_uri_use:N \l_stex_current_ns_uri}
}
\NewDocumentEnvironment { mmtinterface } { O{} m m } {
  \TODO
}{}
\cs_new_protected:Nn \stex_activate_module:n {
  \seq_if_in:NnF \l_stex_all_modules_seq { #1 } {
    \stex_debug:nn{modules}{Activating~module~#1}
    \seq_put_right:Nn \l_stex_all_modules_seq { #1 }
    \use:c{ c_stex_module_#1_code }
    % \TODO % morphisms
  }
}
\cs_generate_variant:Nn \stex_activate_module:n {o,x}
\newenvironment{structural_feature_module}[2]{
  \stex_module_setup:n {#1}
  #2
}{
  \tl_gset_eq:Nc \g_stex_last_feature_str \l_stex_current_module_str
}
\cs_new_protected:Nn \stex_import_module_uri:nn {
  \exp_args:NNnx \seq_set_split:Nnn \__stex_importmodule_seq ? { \tl_to_str:n{ #2 } }
  \seq_pop_right:NN \__stex_importmodule_seq \l_stex_import_name_str
  \str_set:Nx \l_stex_import_path_str { \seq_use:Nn \__stex_importmodule_seq ? }
  \tl_if_empty:nTF { #1 } {
    \prop_if_exist:NTF \l_stex_current_repository_prop {
      \str_set:Nx \l_stex_import_archive_str {
        \prop_item:Nn \l_stex_current_repository_prop { id }
      }
    }{
      \str_clear:N \l_stex_import_archive_str
      \str_if_empty:NTF \l_stex_import_path_str {
        \str_set:Nx \l_stex_import_path_str {
          \stex_file_use:N \g_stex_current_file / ..
        }
      }{
        \stex_file_resolve:Nx \l__stex_importmodule_seq { \stex_file_use:N \g_stex_current_file / .. / \l_stex_import_path_str}
        \str_set:Nx \l_stex_import_path_str {
          \stex_file_use:N \l__stex_importmodule_seq
        }
      }
    }
  } {
    \str_set:Nx \l_stex_import_archive_str { #1 }
    \stex_require_repository:o \l_stex_import_archive_str
  }
}
\cs_new_protected:Npn \stex_import_require_module:nnn #1 {
  \tl_if_empty:nTF { #1 } {
    \str_clear:N \l__stex_importmodule_archive_str
    \str_set:Nn \l__stex_importmodule_uri {file:}
    \__stex_importmodule_get_module:nnn {}
  }{
    \str_set:Nx \l__stex_importmodule_archive_str {#1}
    \str_set:Nx \l__stex_importmodule_uri { \prop_item:cn{ c_stex_mathhub_ #1 _manifest_prop}{ ns } }
    \str_set:Nx \l__stex_importmodule_str { \stex_file_use:N \c_stex_mathhub_file / #1 / source }
    \exp_args:No \__stex_importmodule_get_module:nnn \l__stex_importmodule_str
  }
}

\cs_new_protected:Nn \__stex_importmodule_get_module:nnn {
  \tl_if_empty:nF {#2}{
    \str_set:Nx \l__stex_importmodule_uri {\l__stex_importmodule_uri / #2}
  }
  \stex_if_module_exists:nF {\l__stex_importmodule_uri?#3} {
    \__stex_importmodule_get_from_file:nnn{#1}{#2}{#3}
  }
  \str_set:Nx \l_stex_import_ns_str {\l__stex_importmodule_uri?#3}
  \stex_activate_module:o \l_stex_import_ns_str
}

\cs_new_protected:Nn \__stex_importmodule_get_from_file:nnn {
  \stex_file_resolve:Nx \l__stex_importmodule_seq { \tl_if_empty:nF{ #1 }{ #1 / } #2 }
  \str_set:Nx \l__stex_importmodule_str {\stex_file_use:N \l__stex_importmodule_seq}
  \stex_debug:nn{imports}{Looking~for~\l__stex_importmodule_uri?#3...}
  \__stex_importmodule_check_file:nn{ .tex }{
    \__stex_importmodule_check_file:nn{. \l_stex_current_language_str .tex}{
      \__stex_importmodule_check_file:nn{.en.tex}{
        \__stex_importmodule_check_file:nn{/#3.tex}{
          \__stex_importmodule_check_file:nn{/#3.\l_stex_current_language_str .tex}{
            \__stex_importmodule_check_file:nn{/#3.en.tex}{
              \msg_error:nnx{stex}{error/unknownmodule}{\l__stex_importmodule_uri?#3}
            }
          }
        }
      }
    }
  }
  \__stex_importmodule_load_file:n{#3}
}

\cs_new_protected:Nn \__stex_importmodule_load_file:n {
  \stex_file_in_smsmode:on \l__stex_importmodule_str {
    \seq_clear:N \l_stex_all_modules_seq
    \str_clear:N \l_stex_current_module_str
    \str_if_empty:NF \l__stex_importmodule_archive_str {
      \stex_set_current_repository:n \l__stex_importmodule_archive_str
    }
    \stex_debug:nn{modules}{Loading~\l__stex_importmodule_str}
  }
  \stex_if_module_exists:nF {\l__stex_importmodule_uri?#1} {
    \msg_error:nnx{stex}{error/unknownmodule}{\l__stex_importmodule_uri?#1}
  }
}

\cs_new_protected:Npn \__stex_importmodule_check_file:nn #1 {
  \stex_debug:nn{imports}{Checking~\l__stex_importmodule_str #1}
  \IfFileExists{ \l__stex_importmodule_str #1 }{
    \stex_debug:nn{imports}{Success}
    \str_set:Nx \l__stex_importmodule_str { \l__stex_importmodule_str #1 }
  }
}
\stex_new_stylable_cmd:nnnnn {usemodule} { O{} m } {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \stex_import_require_module:nnn
    \l_stex_import_archive_str
    \l_stex_import_path_str
    \l_stex_import_name_str
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn
      {stex:usemodule} \l_stex_import_ns_str {}
  }
}{}{}
\stex_new_stylable_cmd:nnnnn{importmodule} { O{} m } {
  \__stex_importmodule_import_module:nn {#1}{#2}
  \stex_smsmode_do:
}{}{}
\stex_deactivate_macro:Nn \importmodule {module~environments}

\cs_new_protected:Nn \__stex_importmodule_import_module:nn {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \stex_import_require_module:nnn
    \l_stex_import_archive_str
    \l_stex_import_path_str
    \l_stex_import_name_str
  \stex_execute_in_module:x{
    \stex_activate_module:n{\l_stex_import_ns_str}
  }
  \stex_add_module_dependency:nonn
    {}{\l_stex_import_ns_str}{import}{}
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn
      {stex:import} \l_stex_import_ns_str {}
  }
  \stex_if_smsmode:F{
    \tl_set_eq:NN \importmoduleuri \l_stex_import_ns_str
    \tl_set_eq:NN \importmodulename \l_stex_import_name_str
    \tl_clear:N \thisstyle
    \stex_style_apply:
  }
}

\cs_new_protected:Nn \__stex_importmodule_import_module_presms:nn {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \tl_gput_right:Nx \g_stex_sms_import_code {
    \stex_import_require_module:nnn
      {\l_stex_import_archive_str}
      {\l_stex_import_path_str}
      {\l_stex_import_name_str}
  }
}
\stex_sms_allow_escape:N \importmodule
\stex_every_module:n {\stex_reactivate_macro:N \importmodule}
\stex_sms_allow_import:Nn \importmodule {
  \stex_reactivate_macro:N \importmodule
  \let \__stex_importmodule_import_module:nn \__stex_importmodule_import_module_presms:nn
}
\stex_new_stylable_cmd:nnnnn{MMTinclude} {m}{
  \stex_annotate_invisible:nnn{stex:import}{#1}{}
}{}{}
\stex_every_module:n {\stex_reactivate_macro:N \MMTinclude}
\stex_get_env:Nn\__stex_symdecl_env_str{STEX_CHECKTERMS}
\str_if_empty:NF\__stex_symdecl_env_str{
  \exp_args:No \str_if_eq:nnF \__stex_symdecl_env_str{false}{
    \bool_set_true:N \c_stex_check_terms_bool
  }
}
\prg_new_conditional:Nnn \stex_if_check_terms: {p, T, F, TF} {
  \bool_if:NTF \c_stex_check_terms_bool {
    \stex_html_backend:TF\prg_return_false:{
      \stex_if_smsmode:TF\prg_return_false:\prg_return_true:
    }
  }\prg_return_false:
}
\stex_keys_define:nnnn{decl}{
  \str_clear:N \l_stex_key_name_str
  \str_clear:N \l_stex_key_args_str
  \tl_clear:N \l_stex_key_type_tl
  \tl_clear:N \l_stex_key_def_tl
  \clist_clear:N \l_stex_key_argnames_clist
  \str_clear:N \l_stex_key_args_str
  \str_clear:N \l_stex_key_reorder_str
  \str_clear:N \l_stex_key_assoc_str
  \str_clear:N \l_stex_key_intent_str
}{
  name      .str_set_x:N  = \l_stex_key_name_str ,

  args      .str_set_x:N  = \l_stex_key_args_str ,
  reorder   .str_set_x:N  = \l_stex_key_reorder_str ,
  argnames  .clist_set:N  = \l_stex_key_argnames_clist ,
  assoc     .choices:nn   = {bin,binl,binr,pre,conj,pwconj}
    {\str_set:Nx \l_stex_key_assoc_str \l_keys_choice_tl},
  intent    .str_set_x:N  = \l_stex_key_intent_str ,

  type      .tl_set:N     = \l_stex_key_type_tl  ,
  def       .tl_set:N     = \l_stex_key_def_tl   ,

  align     .code:n       = {},
  gfc       .code:n       = {}
}{style,deprecate}
\int_new:N \l_stex_args_count
\int_new:N \l_stex_assoc_args_count
\cs_new_protected:Nn \stex_decl_parse_arity: {
  \int_zero:N \l_stex_args_count
  \int_zero:N \l_stex_assoc_args_count
  \str_map_inline:Nn \l_stex_key_args_str {
    \str_case:nnF ##1 {
      0 { \str_map_break: }
      1 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {1}
        \str_set:Nn \l_stex_key_args_str {i}
      } }
      2 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {2}
        \str_set:Nn \l_stex_key_args_str {ii}
      } }
      3 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {3}
        \str_set:Nn \l_stex_key_args_str {iii}
      } }
      4 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {4}
        \str_set:Nn \l_stex_key_args_str {iiii}
      } }
      5 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {5}
        \str_set:Nn \l_stex_key_args_str {iiiii}
      } }
      6 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {6}
        \str_set:Nn \l_stex_key_args_str {iiiiii}
      } }
      7 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {7}
        \str_set:Nn \l_stex_key_args_str {iiiiiii}
      } }
      8 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {8}
        \str_set:Nn \l_stex_key_args_str {iiiiiiii}
      } }
      9 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {9}
        \str_set:Nn \l_stex_key_args_str {iiiiiiiii}
      } }
      i {\int_incr:N \l_stex_args_count}
      b {\int_incr:N \l_stex_args_count}
      a {\int_incr:N \l_stex_args_count \int_incr:N \l_stex_assoc_args_count}
      B {\int_incr:N \l_stex_args_count \int_incr:N \l_stex_assoc_args_count}
    }{
      \msg_error:nnxx{stex}{error/wrongargs}{
        \l_stex_current_module_str ? \l_stex_key_name_str
      }{##1}
    }
  }
  \seq_clear:N \l_stex_argnames_seq
  \int_step_inline:nn \l_stex_args_count {
    \clist_if_empty:NTF \l_stex_key_argnames_clist {
      \exp_args:NNo \seq_put_right:Nn \l_stex_argnames_seq {\c_dollar_str##1}
    }{
      \clist_pop:NN \l_stex_key_argnames_clist \l__stex_symdecl_tmp
      \exp_args:NNx \seq_put_right:Nn \l_stex_argnames_seq {
        \c_dollar_str\exp_args:No\tl_to_str:n\l__stex_symdecl_tmp
      }
    }
  }
}
\stex_new_stylable_cmd:nnnnn {symdecl} { s m O{}} {
  \stex_keys_set:nn{decl}{#3}
  \str_if_empty:NT \l_stex_key_name_str {
    \str_set:Nx \l_stex_key_name_str { #2 }
  }
  \IfBooleanTF #1 {
    \str_clear:N \l_stex_macroname_str
  }{
    \str_set:Nx \l_stex_macroname_str { #2 }
  }
  \stex_symdecl_do:
  \stex_if_check_terms:T{
    \vbox_set:Nn \l_tmpa_box {
      \group_begin:
        \stex_debug:nn{check_terms}{Checking type...}
        {$\l_stex_key_type_tl$}
        \stex_debug:nn{check_terms}{Checking definiens...}
        {$\l_stex_key_def_tl$}
      \group_end:
    }
  }
  \stex_if_smsmode:F{
    \tl_set:Nx \symdecluri {\l_stex_current_module_str ? \l_stex_key_name_str}
    \tl_set_eq:NN \symdeclname \l_stex_key_name_str
    \tl_clear:N \thisstyle
    \stex_style_apply:
  }
  \stex_smsmode_do:
}{}{}
\stex_deactivate_macro:Nn \symdecl {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \symdecl}
\stex_sms_allow_escape:N \symdecl
\cs_new_protected:Nn \_stex_invoke_symbol:nnnnnn {
  \tl_set:Nx \STEXInternalSymbolAfterInvokationTL {
    \stex_pseudogroup_restore:N \STEXInternalCurrentSymbolStr
    \stex_pseudogroup_restore:N \STEXInternalCurrentArgsStr
    \stex_pseudogroup_restore:N \STEXInternalCurrentArityStr
    \stex_pseudogroup_restore:N \STEXInternalCurrentArgnamesSeq
  }
  \str_set:Nx \STEXInternalCurrentSymbolStr{ #1?#2 }
  \str_set:Nx \STEXInternalCurrentArityStr{ #3 }
  \str_set:Nx \STEXInternalCurrentArgsStr{ #4 }
  \seq_set_split:Nnn\STEXInternalCurrentArgnamesSeq , { #5 }
  #6
}
\cs_new_protected:Nn \stex_invoke_symdecl: { \TODO }

\cs_new_protected:Nn \stex_symdecl_do: {
  \_stex_do_deprecation:n \l_stex_key_name_str
  \stex_decl_parse_arity:
  \exp_args:Nnx \use:nn {\stex_add_module_decl:nnnnnnn}{
    {\l_stex_macroname_str}
    {\l_stex_key_name_str}
    {\int_use:N \l_stex_args_count}
    {\l_stex_key_args_str}
    {\seq_use:Nn \l_stex_argnames_seq , }
    {\tl_if_empty:NTF \l_stex_key_def_tl
      {\tl_to_str:n{true}}{\tl_to_str:n{false}}
    }{\stex_invoke_symdecl:}
  }
  \stex_symdecl_html:
  \str_if_empty:NF \l_stex_macroname_str {
    \stex_execute_in_module:x {
      \tl_set:cn {\l_stex_macroname_str}{
        \_stex_invoke_symbol:nnnnnn
          {\l_stex_current_module_str}
          {\l_stex_key_name_str}
          {\int_use:N \l_stex_args_count}
          {\l_stex_key_args_str}
          {\seq_use:Nn \l_stex_argnames_seq , }
          {\stex_invoke_symdecl:}
      }
    }
  }
}
\cs_new_protected:Nn \stex_symdecl_html: {
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn {stex:symdecl} {
      \l_stex_current_module_str ? \l_stex_key_name_str
    }{
      \stex_annotate_invisible:nnn{stex:args}{\l_stex_key_args_str}{}
      \stex_annotate_invisible:nnn{stex:macroname}{\l_stex_macroname_str}{}
      \tl_if_empty:NF \l_stex_key_type_tl {
        \stex_annotate_invisible:nnn{stex:type}{}{$\l_stex_key_type_tl$}
      }
      \tl_if_empty:NF \l_stex_key_def_tl {
        \stex_annotate_invisible:nnn{stex:definiens}{}{$\l_stex_key_def_tl$}
      }
      \str_if_empty:NF \l_stex_key_assoc_str {
        \stex_annotate_invisible:nnn{stex:assoctype}{\l_stex_key_assoc_str}{}
      }
      \str_if_empty:NF \l_stex_key_reorder_str {
        \stex_annotate_invisible:nnn{stex:reorderargs}{\l_stex_key_reorder_str}{}
      }
    }
  }
}
\stex_new_stylable_cmd:nnnnn {textsymdecl} {m O{} m} {
  \TODO
}{}{}

\cs_new_protected:Nn \stex_get_symbol:n {
  \str_clear:N \l_stex_get_symbol_mod_str
  \str_clear:N \l_stex_get_symbol_name_str
  \cs_if_exist:cTF { #1 }{
    \cs_set_eq:Nc \l__stex_symdecl_cs { #1 }
    % command name
    \exp_args:Nx \tl_if_empty:nTF { \cs_argument_spec:N \l__stex_symdecl_cs }{
      % ...that takes no arguments
      \exp_args:Nx \cs_if_eq:NNTF {\tl_head:N \l__stex_symdecl_cs}
        \_stex_invoke_symbol:nnnnnn
        \__stex_symdecl_get_symbol_from_cs:
        {\__stex_symdecl_get_symbol_from_string:n { #1 }}
    }{
      \__stex_symdecl_get_symbol_from_string:n { #1 }
    }
  }{
    \__stex_symdecl_get_symbol_from_string:n { #1 }
  }
  \str_if_empty:NT \l_stex_get_symbol_name_str {
    \msg_error:nnn{stex}{error/unknownsymbol}{#1}
  }
}
\int_new:N \l_stex_get_symbol_arity_int
\cs_new_protected:Nn \__stex_symdecl_get_symbol_from_cs: {
  \stex_debug:nn{symbols}{Getting~from~cs...}
  \stex_pseudogroup_with:nn{\_stex_invoke_symbol:nnnnnn}{
    \cs_set:Npn \_stex_invoke_symbol:nnnnnn ##1 ##2 ##3 ##4 ##5 ##6 {
      \str_set:Nn \l_stex_get_symbol_mod_str {##1}
      \str_set:Nn \l_stex_get_symbol_name_str {##2}
      \int_set:Nn \l_stex_get_symbol_arity_int {##3}
      \str_set:Nn \l_stex_get_symbol_args_str {##4}
    }
    \l__stex_symdecl_cs
  }
}

\cs_new_protected:Nn \__stex_symdecl_get_symbol_from_string:n {
  \stex_debug:nn{symbols}{Getting~from~string~#1...}
  \seq_set_split:Nnn \l__stex_symdecl_seq ? {#1}
  \seq_pop_right:NN \l__stex_symdecl_seq \l__stex_symdecl_name
  \seq_if_empty:NTF \l__stex_symdecl_seq {
    \exp_args:No \__stex_symdecl_get_from_one_string:n {#1}
  }{
    \exp_args:NNx \exp_args:Nno \__stex_symdecl_get_symbol_from_modules:nn {
      \seq_use:Nn \l__stex_symdecl_seq ?
    } \l__stex_symdecl_name
  }
}

\cs_new_protected:Nn \__stex_symdecl_get_symbol_from_modules:nn {
  \stex_debug:nn{symbols}{Getting~#2~in~#1...}
  \stex_iterate_decls:nn{#1}{
    %\stex_debug:nn{symbols}{>#2==##2<...}
    \str_if_eq:nnTF{#2}{##2}{
      \stex_iterate_break:n{
        \str_set:Nn \l_stex_get_symbol_mod_str {##1}
        \str_set:Nn \l_stex_get_symbol_name_str {##3}
        \int_set:Nn \l_stex_get_symbol_arity_int {##4}
        \str_set:Nn \l_stex_get_symbol_args_str {##5}
      }
    }{
      %\stex_debug:nn{symbols}{>#2==##3<...}
      \str_if_eq:nnT{#2}{##3}{
        \stex_iterate_break:n{
          \str_set:Nn \l_stex_get_symbol_mod_str {##1}
          \str_set:Nn \l_stex_get_symbol_name_str {##3}
          \int_set:Nn \l_stex_get_symbol_arity_int {##4}
          \str_set:Nn \l_stex_get_symbol_args_str {##5}
        }
      }
    }
  }
}

\cs_new_protected:Nn \__stex_symdecl_get_from_one_string:n {
  \stex_debug:nn{symbols}{Getting~#1~anywhere...}
  \stex_iterate_decls:n{
    %\stex_debug:nn{symbols}{>#1==##2<...}
    \str_if_eq:nnTF{#1}{##2}{
      \stex_iterate_break:n{
        \str_set:Nn \l_stex_get_symbol_mod_str {##1}
        \str_set:Nn \l_stex_get_symbol_name_str {##3}
      }
    }{
     % \stex_debug:nn{symbols}{>#1==##3<...}
      \str_if_eq:nnT{#1}{##3}{
        \stex_iterate_break:n{
          \str_set:Nn \l_stex_get_symbol_mod_str {##1}
          \str_set:Nn \l_stex_get_symbol_name_str {##3}
        }
      }
    }
  }
}
\stex_keys_define:nnnn{notation}{
  \str_clear:N \l_stex_key_variant_str
  \str_clear:N \l_stex_key_prec_str
  \str_clear:N \l_stex_key_op_tl
  \str_clear:N \l_stex_key_hints_str
}{
  variant    .str_set_x:N  = \l_stex_key_variant_str ,
  prec       .str_set_x:N  = \l_stex_key_prec_str ,
  op         .tl_set:N     = \l_stex_key_op_tl ,
  hints      .str_set_x:N  = \l_stex_key_hints_str ,
  unknown    .code:n       = {
    \str_set:Nx \l_stex_key_variant_str \l_keys_key_str
  }
}{style}
\cs_new:Nn \__stex_notations_make_args: {
  \str_map_function:NN \l_stex_key_args_str \__stex_notations_make_arg:n
}
\cs_new:Nn \__stex_notations_make_arg:n {
  \str_case:nn ##1 {
    i {{i}}
    b {{b}}
    a {{a1,a2,a3}}
    B {{B1,B2,B3}}
  }
}
\stex_new_stylable_cmd:nnnnn {notation} { m O{}} {
  \stex_keys_set:nn{notation}{#2}
  \stex_get_symbol:n{#1}
  \stex_notation_do:nn{
    \stex_if_check_terms:T{
      \vbox_set:Nn \l_tmpa_box {
        \group_begin:
        \str_set:Nn \STEXInternalCurrentSymbolStr {test}
        \tl_set:Nn \STEXInternalSymbolAfterInvokationTL {}
        \cs_set:Npn \comp ##1 {##1}
        \stex_debug:nn{check_terms}{Checking notation...}
          ${
            \exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
              \__stex_notations_make_args:
            }
          }$
        \group_end:
      }
    }
    \stex_add_module_notation:eoex{
      \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str
    }\l_stex_key_variant_str{\int_use:N \l_stex_args_count}{
      \stex_macro_body:N \l_stex_notation_macrocode_cs
    }
    %\let \thisnotation \l_stex_notation_macrocode_cs
    %\cs_set_eq:cN {l_stex_notation_
    %  \l_stex_get_symbol_mod_str ?
    %  \l_stex_get_symbol_name_str _
    %  \l_stex_key_variant_str _cs
    %}\l_stex_notation_macrocode_cs
    %\stex_execute_in_module:x {
    %  \exp_after:wN \stex_macro_definition:N
    %  \cs:w
    %    l_stex_notation_
    %    \l_stex_get_symbol_mod_str ?
    %    \l_stex_get_symbol_name_str _
    %    \l_stex_key_variant_str _cs
    %  \cs_end:
    %}
    \stex_style_apply: % TODO
    \stex_smsmode_do:
  }
}{}{}
\stex_deactivate_macro:Nn \notation {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \notation}
\stex_sms_allow_escape:N \notation
\cs_new_protected:Npn \stex_notation_do:nn {
  \int_compare:nNnTF \l_stex_get_symbol_arity_int = 0
  \stex_notation_const_do:nn \stex_notation_fun_do:nn
}

\cs_new_protected:Nn \stex_notation_const_do:nn {
  \stex_debug:nn{notation}{Constant~notation~\exp_not:n{#2}}
  % precedences
  \seq_clear:N \l__stex_notations_precs_seq
  \str_if_empty:NTF \l_stex_key_prec_str {
    \tl_set:No \l__stex_notations_opprec_tl { \neginfprec }
  }{
    \str_if_eq:onTF \l_stex_key_prec_str {nobrackets}{
      \tl_set:No \l__stex_notations_opprec_tl { \neginfprec }
    }{
      \tl_set_eq:NN \l__stex_notations_opprec_tl \l_stex_key_prec_str
    }
  }
  \let \STEXInternalCurrentSymbolStr \relax
  \exp_args:NNe
  \cs_set_nopar:Npn \l_stex_notation_macrocode_cs {
    \STEXInternalTermMathOMSiiii { \exp_not:N \STEXInternalCurrentSymbolStr }
      { \l_stex_key_variant_str }
      { \l__stex_notations_opprec_tl }
      { \exp_not:n { \comp{#2} } }
  }
  \stex_debug:nn{notation}{Notation:~\meaning\l_stex_notation_macrocode_cs}
  #1
}
\int_new:N \l__stex_notations_currarg_int
\cs_new_protected:Nn \stex_notation_fun_do:nn {
  %\stex_debug:nn{notation}{Function~notation~\tl_to_str:n{#2}}
  \seq_clear:N \l__stex_notations_precs_seq

  \str_if_empty:NTF \l_stex_key_prec_str {
    \tl_set:Nn \l__stex_notations_opprec_tl { 0 }
    \int_step_inline:nn \l_stex_get_symbol_arity_int {
      \seq_put_right:Nn \l__stex_notations_precs_seq {0}
    }
  }{
    \str_if_eq:onTF \l_stex_key_prec_str {nobrackets}{
      \stex_debug:nn{notation}{No~brackets}
      \tl_set:No \l__stex_notations_opprec_tl { \neginfprec }
      \int_step_inline:nn \l_stex_get_symbol_arity_int {
        \exp_args:NNo \seq_put_right:Nn \l__stex_notations_precs_seq \infprec
      }
    }\__stex_notations_parse_precs:
  }

  \let \STEXInternalCurrentSymbolStr \relax
  \str_if_in:NnTF \l_stex_get_symbol_args_str b \__stex_notations_do_omb:n{
    \str_if_in:NnTF \l_stex_get_symbol_args_str B
      \__stex_notations_do_omb:n\__stex_notations_do_oma:n
  }{#2}

  \str_set_eq:NN \l__stex_notations_rem_args \l_stex_get_symbol_args_str
  \int_zero:N \l__stex_notations_currarg_int
  \seq_set_eq:NN \l__stex_notations_rem_precs_seq \l__stex_notations_precs_seq
  \tl_clear:N \l__stex_notations_dummys_tl
  \tl_set:Nn \l__stex_notations_after_tl{#1}

  \stex_debug:nn{notation}{Doing~notation^^J\l_stex_get_symbol_args_str^^J
    \meaning\l__stex_notations_precs_seq^^J\the\l_stex_get_symbol_arity_int
  }
  \__stex_notations_args:
}

\cs_new_protected:Nn \__stex_notations_args: {
  \str_if_empty:NTF \l__stex_notations_rem_args {
    \exp_args:Nnx \use:nn {
      \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
      \cs_set_nopar:Npn \l_stex_get_symbol_arity_int
    }{{
      \exp_after:wN \exp_after:wN \exp_after:wN
      \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \l_stex_notation_macrocode_cs \l__stex_notations_dummys_tl \STEXInternalSymbolAfterInvokationTL}
    }}
    \stex_debug:nn{notation}{Notation:~\meaning\l_stex_notation_macrocode_cs}
    \l__stex_notations_after_tl
  }{
    \int_incr:N \l__stex_notations_currarg_int
    \str_set:Nx \l__stex_notations_currarg_str { \str_head:N \l__stex_notations_rem_args }
    \str_set:Nx \l__stex_notations_rem_args { \str_tail:N \l__stex_notations_rem_args }
    \str_if_eq:VnTF \l__stex_notations_currarg_str {a}{
      \__stex_notations_assoc_arg:nn{a}
    }{
      \str_if_eq:VnTF \l__stex_notations_currarg_str {B}{
        \__stex_notations_assoc_arg:nn{B}
      }{
        \exp_args:No\__stex_notations_simple_arg:n\l__stex_notations_currarg_str
      }
    }
  }
}

\cs_new_protected:Nn \__stex_notations_assoc_arg:nn {
  \cs_generate_from_arg_count:NNnn \l_tmpa_cs \cs_set:Npn
    \l_stex_get_symbol_arity_int {#2}
  \int_zero:N \l_tmpa_int
  \tl_clear:N \l_tmpa_tl
  \str_map_inline:Nn \l_stex_get_symbol_args_str {
    \int_incr:N \l_tmpa_int
    \tl_put_right:Nx \l_tmpa_tl {
      \str_if_eq:nnTF {##1}{a}{ {} }{
        \str_if_eq:nnTF {##1}{B}{ {} }{
          {\_stex_term_arg:nn{##1\int_use:N \l_tmpa_int}{################ \int_use:N \l_tmpa_int}}
        }
      }
    }
  }

  \exp_after:wN\exp_after:wN\exp_after:wN \def
  \exp_after:wN\exp_after:wN\exp_after:wN \l_tmpa_cs
  \exp_after:wN\exp_after:wN\exp_after:wN ##
  \exp_after:wN\exp_after:wN\exp_after:wN 1
  \exp_after:wN\exp_after:wN\exp_after:wN ##
  \exp_after:wN\exp_after:wN\exp_after:wN 2
  \exp_after:wN\exp_after:wN\exp_after:wN {
    \exp_after:wN \exp_after:wN \exp_after:wN
    \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN {
      \exp_after:wN \l_tmpa_cs \l_tmpa_tl
    }
  }

  \seq_pop_left:NN \l__stex_notations_rem_precs_seq \l__stex_notations_prec_str
  \tl_put_right:Nx \l__stex_notations_dummys_tl { {
    \STEXInternalTermMathAssocArgiiiii
      { \int_use:N \l__stex_notations_currarg_int }
      { \l__stex_notations_prec_str }
      { ####\int_use:N \l__stex_notations_currarg_int }
      { \l_tmpa_cs \STEXInternalAssocArgMarkerI \STEXInternalAssocArgMarkerII }
      {#1}
  } }
  \__stex_notations_args:
}

\cs_new_protected:Nn \__stex_notations_simple_arg:n {
  \seq_pop_left:NN \l__stex_notations_rem_precs_seq \l__stex_notations_prec_str
  \tl_put_right:Nx \l__stex_notations_dummys_tl {{
    \STEXInternalTermMathArgiii
      {\tl_to_str:n{#1}\int_use:N \l__stex_notations_currarg_int}
      {\l__stex_notations_prec_str}
      {####\int_use:N \l__stex_notations_currarg_int}
  }}
  \__stex_notations_args:
}

\cs_new_protected:Nn \__stex_notations_do_omb:n {
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
  \cs_set:Npn \l_stex_get_symbol_arity_int } { {
    \STEXInternalTermMathOMBiiii { \STEXInternalCurrentSymbolStr }
      { \l_stex_key_variant_str }
      { \l__stex_notations_opprec_tl }
      { \exp_not:n { #1 } }
  } }
}

\cs_new_protected:Nn \__stex_notations_do_oma:n {
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
  \cs_set:Npn \l_stex_get_symbol_arity_int } { {
    \STEXInternalTermMathOMAiiii { \STEXInternalCurrentSymbolStr }
      { \l_stex_key_variant_str }
      { \l__stex_notations_opprec_tl }
      { \exp_not:n { #1 } }
  } }
}

\cs_new_protected:Nn \__stex_notations_parse_precs: {
  \stex_debug:nn{notation}{parsing~precedence~\l_stex_key_prec_str}
  \seq_set_split:NnV \l__stex_notations_seq ; \l_stex_key_prec_str
  \seq_pop_left:NNTF \l__stex_notations_seq \l__stex_notations_str {
    \tl_set_eq:NN \l__stex_notations_opprec_tl \l__stex_notations_str
    \seq_pop_left:NNT \l__stex_notations_seq \l__stex_notations_str {
      \exp_args:NNo \seq_set_split:NnV \l__stex_notations_seq
        {\tl_to_str:n{x}} \l__stex_notations_str
    }
  }{
    \tl_set:No \l__stex_notations_opprec_tl { 0 }
  }
  \int_step_inline:nn \l_stex_get_symbol_arity_int {
    \seq_pop_left:NNTF \l__stex_notations_seq \l__stex_notations_str {
      \seq_put_right:No \l__stex_notations_precs_seq \l__stex_notations_str
    }{
      \seq_put_right:No \l__stex_notations_precs_seq \l__stex_notations_opprec_tl
    }
  }
}
\stex_keys_define:nnnn{symdef}{}{}{decl,notation}
\stex_new_stylable_cmd:nnnnn {symdef} { m O{}} {
  \stex_keys_set:nn{symdef}{#2}
  \str_if_empty:NT \l_stex_key_name_str {
    \str_set:Nx \l_stex_key_name_str { #1 }
  }
  \str_set:Nx \l_stex_macroname_str { #1 }
  \stex_symdecl_do:
  \stex_if_check_terms:T{
    \vbox_set:Nn \l_tmpa_box {
      \group_begin:
        \stex_debug:nn{check_terms}{Checking type...}
        {$\l_stex_key_type_tl$}
        \stex_debug:nn{check_terms}{Checking definiens...}
        {$\l_stex_key_def_tl$}
      \group_end:
    }
  }
  \stex_if_smsmode:F{
    \tl_set:Nx \symdecluri {\l_stex_current_module_str ? \l_stex_key_name_str}
    \tl_set_eq:NN \symdeclname \l_stex_key_name_str
    \tl_clear:N \thisstyle
  }
  \str_set_eq:NN \l_stex_get_symbol_args_str \l_stex_key_args_str
  \int_set:Nn \l_stex_get_symbol_arity_int {\l_stex_args_count}
  \stex_debug:nn{symdef}{Doing~\l_stex_current_module_str ? \l_stex_key_name_str}
  \stex_notation_do:nn{
    \stex_if_check_terms:T{
      \vbox_set:Nn \l_tmpa_box {
        \group_begin:
        \str_set:Nn \STEXInternalCurrentSymbolStr {test}
        \tl_set:Nn \STEXInternalSymbolAfterInvokationTL {}
        \cs_set:Npn \comp ##1 {##1}
        \stex_debug:nn{check_terms}{Checking notation...}
          ${
            \exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
              \__stex_notations_make_args:
            }
          }$
        \group_end:
      }
    }
    \stex_add_module_notation:eoex{
      \l_stex_current_module_str ? \l_stex_key_name_str
    }\l_stex_key_variant_str{\int_use:N \l_stex_args_count}{
      \stex_macro_body:N \l_stex_notation_macrocode_cs
    }
    \stex_style_apply: % TODO
    \stex_smsmode_do:
  }
  %\stex_style_apply:
  %\stex_smsmode_do:
}{}{}
\stex_deactivate_macro:Nn \symdef {module~environments}
<<<<<<< HEAD
\stex_every_module:n {\stex_reactivate_macro:N \symdef}
\stex_sms_allow_escape:N \symdef
\cs_new:Npn \infprec {}
\cs_new:Npn \neginfprec {}
\cs_new_protected:Npn \STEXInternalTermMathArgiii #1 #2 #3 {}
\cs_new_protected:Npn \STEXInternalTermMathAssocArgiiiii #1 #2 #3 #4 #5 {}
\cs_new_protected:Npn \STEXInternalTermMathOMSiiii #1 #2 #3 #4 {}
\cs_new_protected:Npn \STEXInternalTermMathOMBiiii #1 #2 #3 #4 {}
\cs_new_protected:Npn \STEXInternalTermMathOMAiiii #1 #2 #3 #4 {}
\cs_new_protected:Nn \_stex_term_arg:nn {}
\cs_new_protected:Npn \STEXInternalSymbolAfterInvokationTL {}
\cs_new_protected:Npn \STEXInternalAssocArgMarkerI {}
\cs_new_protected:Npn \STEXInternalAssocArgMarkerII {}
\let\stex_par:\par
\stex_read_persist:
\cs_undefine:N \stex_read_persist:
=======

\keys_define:nn { stex / mmtdef } {
  name    .str_set_x:N = \l_stex_symdecl_name_str ,
  args    .str_set_x:N = \l_stex_symdecl_args_str ,
  reorder .str_set_x:N = \l_stex_symdecl_reorder_str ,
  op      .tl_set:N    = \l__stex_notation_op_tl ,
 % lang    .str_set_x:N = \l__stex_notation_lang_str ,
  variant .str_set_x:N = \l__stex_notation_variant_str ,
  prec    .str_set_x:N = \l__stex_notation_prec_str ,
  argnames    .clist_set:N  = \l_stex_symdecl_argnames_clist ,
  assoc   .choices:nn  =
      {bin,binl,binr,pre,conj,pwconj}
      {\str_set:Nx \l_stex_symdecl_assoctype_str {\l_keys_choice_tl}},
  unknown .code:n      = \str_set:Nx
      \l__stex_notation_variant_str \l_keys_key_str
}
\cs_new_protected:Nn \_stex_mmtdef_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \str_clear:N \l_stex_symdecl_assoctype_str
  \str_clear:N \l_stex_symdecl_reorder_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \clist_clear:N \l_stex_symdecl_argnames_clist
 % \str_clear:N \l__stex_notation_lang_str
  \str_clear:N \l__stex_notation_variant_str
  \str_clear:N \l__stex_notation_prec_str
  \tl_clear:N \l__stex_notation_op_tl

  \keys_set:nn { stex / mmtdef } { #1 }
}

\NewDocumentCommand \mmtdef {m O{} }{
  \_stex_mmtdef_args:n{ #2 }
  \bool_set_true:N \l_stex_symdecl_make_macro_bool
  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }
  %\tl_set:Nx \l_stex_symdecl_definiens_tl {
  %  \stex_annotate:nnn{ OMID }{
  %    \l_stex_module_mmtfor_str?\l_stex_symdecl_name_str
  %  }{}
  %}
  \stex_symdecl_do:n { #1 }
  \stex_if_smsmode:F{
    \MMTrule{rules.stex.mmt.kwarc.info?SubstitutionRule}{
      \stex_annotate:nnn{ OMID }{
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
      }{},
      \stex_annotate:nnn{ OMID }{
        \l_stex_module_mmtfor_str?\l_stex_symdecl_name_str
      }{}
    }
  }
  \tl_set:Nn \l_stex_notation_after_do_tl {
    \__stex_notation_final:
    \stex_smsmode_do:\ignorespacesandpars
  }
  \str_set:Nx \l_stex_get_symbol_uri_str {
    \l_stex_current_module_str ? \l_stex_symdecl_name_str
  }
  \exp_args:Nx \stex_notation_do:nnnnn
    { \prop_item:cn {l_stex_symdecl_\l_stex_get_symbol_uri_str _prop } { args } }
    { \prop_item:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _prop } { arity } }
    { \l__stex_notation_variant_str }
    { \l__stex_notation_prec_str}
}

\keys_define:nn { stex / vardef } {
  name    .str_set_x:N  = \l__stex_variables_name_str ,
  args    .str_set_x:N  = \l__stex_variables_args_str ,
  type    .tl_set:N     = \l__stex_variables_type_tl ,
  def     .tl_set:N     = \l__stex_variables_def_tl ,
  op      .tl_set:N     = \l__stex_variables_op_tl ,
  prec    .str_set_x:N  = \l__stex_variables_prec_str ,
  reorder .str_set_x:N  = \l__stex_variables_reorder_str ,
  argnames    .clist_set:N  = \l__stex_variables_argnames_clist ,
  assoc   .choices:nn   =
      {bin,binl,binr,pre,conj,pwconj}
      {\str_set:Nx \l__stex_variables_assoctype_str {\l_keys_choice_tl}},
  bind    .choices:nn   =
      {forall,exists}
      {\str_set:Nx \l__stex_variables_bind_str {\l_keys_choice_tl}}
}

\cs_new_protected:Nn \__stex_variables_args:n {
  \str_clear:N \l__stex_variables_name_str
  \str_clear:N \l__stex_variables_args_str
  \str_clear:N \l__stex_variables_prec_str
  \str_clear:N \l__stex_variables_assoctype_str
  \str_clear:N \l__stex_variables_reorder_str
  \str_clear:N \l__stex_variables_bind_str
  \tl_clear:N \l__stex_variables_type_tl
  \tl_clear:N \l__stex_variables_def_tl
  \tl_clear:N \l__stex_variables_op_tl
  \clist_clear:N \l__stex_variables_argnames_clist

  \keys_set:nn { stex / vardef } { #1 }
}

\NewDocumentCommand \__stex_variables_do_simple:nnn { m O{}} {
  \__stex_variables_args:n {#2}
  \str_if_empty:NT \l__stex_variables_name_str {
    \str_set:Nx \l__stex_variables_name_str { #1 }
  }
  \prop_clear:N \l_tmpa_prop
  \prop_put:Nno \l_tmpa_prop { name } \l__stex_variables_name_str

  \int_zero:N \l_tmpb_int
  \bool_set_true:N \l_tmpa_bool
  \str_map_inline:Nn \l__stex_variables_args_str {
    \token_case_meaning:NnF ##1 {
      0 {} 1 {} 2 {} 3 {} 4 {} 5 {} 6 {} 7 {} 8 {} 9 {}
      {\tl_to_str:n i} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n b} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n a} {
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
      {\tl_to_str:n B} {
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
    }{
      \msg_error:nnxx{stex}{error/wrongargs}{
        variable~\l__stex_variables_name_str
      }{##1}
    }
  }
  \bool_if:NTF \l_tmpa_bool {
    % possibly numeric
    \str_if_empty:NTF \l__stex_variables_args_str {
      \prop_put:Nnn \l_tmpa_prop { args } {}
      \prop_put:Nnn \l_tmpa_prop { arity } { 0 }
    }{
      \int_set:Nn \l_tmpa_int { \l__stex_variables_args_str }
      \prop_put:Nnx \l_tmpa_prop { arity } { \int_use:N \l_tmpa_int }
      \str_clear:N \l_tmpa_str
      \int_step_inline:nn \l_tmpa_int {
        \str_put_right:Nn \l_tmpa_str i
      }
      \str_set_eq:NN \l__stex_variables_args_str \l_tmpa_str
      \prop_put:Nnx \l_tmpa_prop { args } { \l__stex_variables_args_str }
    }
  } {
    \prop_put:Nnx \l_tmpa_prop { args } { \l__stex_variables_args_str }
    \prop_put:Nnx \l_tmpa_prop { arity }
      { \str_count:N \l__stex_variables_args_str }
  }
  \prop_put:Nnx \l_tmpa_prop { assocs } { \int_use:N \l_tmpb_int }
  \tl_set:cx { #1 }{ \stex_invoke_variable:n { \l__stex_variables_name_str } }

  % argnames

  \clist_clear:N \l_tmpa_clist
  \int_step_inline:nn {\prop_item:Nn \l_tmpa_prop {arity}} {
    \clist_if_empty:NTF \l__stex_variables_argnames_clist {
      \clist_put_right:Nn \l_tmpa_clist {##1}
    }{
      \clist_pop:NN \l__stex_variables_argnames_clist \l_tmpa_tl
      \exp_args:NNx \clist_put_right:Nn \l_tmpa_clist {\c_dollar_str\l_tmpa_tl}
    }
  }
  \prop_put:Nnx \l_tmpa_prop {argnames} {\clist_use:Nn \l_tmpa_clist ,}

  \prop_set_eq:cN { l_stex_symdecl_var://\l__stex_variables_name_str _prop} \l_tmpa_prop

  \tl_if_empty:NF \l__stex_variables_op_tl {
    \cs_set:cpx {
      stex_var_op_notation_ \l__stex_variables_name_str _cs
    } { \exp_not:N\comp{ \exp_args:No \exp_not:n { \l__stex_variables_op_tl } } }
  }

  \tl_set:Nn \l_stex_notation_after_do_tl {
    \exp_args:Nne \use:nn {
      \cs_generate_from_arg_count:cNnn { stex_var_notation_\l__stex_variables_name_str _cs }
        \cs_set:Npn { \prop_item:Nn \l_tmpa_prop { arity } }
    } {{
      \exp_after:wN \exp_after:wN \exp_after:wN
      \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \l_stex_notation_macrocode_cs \l_stex_notation_dummyargs_tl \STEXInternalSymbolAfterInvokationTL}
    }}
    \stex_if_do_html:T {
      \stex_annotate_invisible:nnn {vardecl}{\l__stex_variables_name_str}{
        \stex_annotate_invisible:nnn { precedence }
          { \l__stex_variables_prec_str }{}
        \tl_if_empty:NF \l__stex_variables_type_tl {\stex_annotate_invisible:nnn{type}{}{$\l__stex_variables_type_tl$}}
        \stex_annotate_invisible:nnn{args}{ \l__stex_variables_args_str }{}
        \stex_annotate_invisible:nnn{macroname}{#1}{}
        \tl_if_empty:NF \l__stex_variables_def_tl {
          \stex_annotate_invisible:nnn{definiens}{}
            {$\l__stex_variables_def_tl$}
        }
        \str_if_empty:NF \l__stex_variables_assoctype_str {
          \stex_annotate_invisible:nnn{assoctype}{\l__stex_variables_assoctype_str}{}
        }
        \str_if_empty:NF \l__stex_variables_reorder_str {
          \stex_annotate_invisible:nnn{reorderargs}{\l__stex_variables_reorder_str}{}
        }
        \int_zero:N \l_tmpa_int
        \str_set_eq:NN \l__stex_variables_remaining_args_str \l__stex_variables_args_str
        \tl_clear:N \l_tmpa_tl
        \int_step_inline:nn { \prop_item:Nn \l_tmpa_prop { arity } }{
          \int_incr:N \l_tmpa_int
          \str_set:Nx \l_tmpb_str { \str_head:N \l__stex_variables_remaining_args_str }
          \str_set:Nx \l__stex_variables_remaining_args_str { \str_tail:N \l__stex_variables_remaining_args_str }
          \str_if_eq:VnTF \l_tmpb_str a {
            \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
              \stex_annotate:nnn{argmarker}{\int_use:N \l_tmpa_int a}{} ,
              \stex_annotate:nnn{argmarker}{\int_use:N \l_tmpa_int b}{}
            } }
          }{
            \str_if_eq:VnTF \l_tmpb_str B {
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
                \stex_annotate:nnn{argmarker}{\int_use:N \l_tmpa_int a}{} ,
                \stex_annotate:nnn{argmarker}{\int_use:N \l_tmpa_int b}{}
              } }
            }{
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
                \stex_annotate:nnn{argmarker}{\int_use:N \l_tmpa_int}{}
              } }
            }
          }
        }
        \stex_annotate_invisible:nnn { notationcomp }{}{
          \str_set:Nx \STEXInternalCurrentSymbolStr {var://\l__stex_variables_name_str }
          $ \exp_args:Nno \use:nn { \use:c {
            stex_var_notation_\l__stex_variables_name_str _cs
          } } { \l_tmpa_tl } $
        }
        \tl_if_empty:NF \l__stex_variables_op_tl {
          \stex_annotate_invisible:nnn { notationopcomp }{}{
            $\l__stex_variables_op_tl$
          }
        }
      }
      \str_if_empty:NF \l__stex_variables_bind_str {
        \stex_annotate_invisible:nnn {bindtype}{\l__stex_variables_bind_str,\l__stex_variables_name_str}{}
      }
    }\ignorespacesandpars
  }

  \stex_notation_do:nnnnn { \l__stex_variables_args_str } { \prop_item:Nn \l_tmpa_prop { arity } } {}{ \l__stex_variables_prec_str}
}

\cs_new:Nn \_stex_reset:N {
  \tl_if_exist:NTF #1 {
    \def \exp_not:N #1 { \exp_args:No \exp_not:n #1 }
  }{
    \let \exp_not:N #1 \exp_not:N \undefined
  }
}

\NewDocumentCommand \__stex_variables_do_complex:nn { m m }{
  \clist_set:Nx \l__stex_variables_names { \tl_to_str:n {#1} }
  \exp_args:Nnx \use:nn {
    % TODO
    \stex_annotate_invisible:nnn {vardecl}{\clist_use:Nn\l__stex_variables_names,}{
      #2
    }
  }{
    \_stex_reset:N \varnot
    \_stex_reset:N \vartype
    \_stex_reset:N \vardefi
  }
}

\NewDocumentCommand \vardef { s } {
  \IfBooleanTF#1 {
    \__stex_variables_do_complex:nn
  }{
    \__stex_variables_do_simple:nnn
  }
}

\NewDocumentCommand \svar { O{} m }{
  \tl_if_empty:nTF {#1}{
    \str_set:Nn \l_tmpa_str { #2 }
  }{
    \str_set:Nn \l_tmpa_str { #1 }
  }
  \_stex_term_omv:nn {
    var://\l_tmpa_str
  }{
    \exp_args:Nnx \use:nn {
      \def\comp{\_varcomp}
      \str_set:Nx \STEXInternalCurrentSymbolStr { var://\l_tmpa_str }
      \comp{ #2 }
    }{
      \_stex_reset:N \comp
      \_stex_reset:N \STEXInternalCurrentSymbolStr
    }
  }
}

\keys_define:nn { stex / varseq } {
  name    .str_set_x:N  = \l__stex_variables_name_str ,
  args    .int_set:N    = \l__stex_variables_args_int ,
  type    .tl_set:N     = \l__stex_variables_type_tl  ,
  mid     .tl_set:N     = \l__stex_variables_mid_tl   ,
  bind    .choices:nn   =
      {forall,exists}
      {\str_set:Nx \l__stex_variables_bind_str {\l_keys_choice_tl}}
}

\cs_new_protected:Nn \__stex_variables_seq_args:n {
  \str_clear:N \l__stex_variables_name_str
  \int_set:Nn \l__stex_variables_args_int 1
  \tl_clear:N \l__stex_variables_type_tl
  \str_clear:N \l__stex_variables_bind_str

  \keys_set:nn { stex / varseq } { #1 }
}

\NewDocumentCommand \varseq {m O{} m m m}{
  \__stex_variables_seq_args:n { #2 }
  \str_if_empty:NT \l__stex_variables_name_str {
    \str_set:Nx \l__stex_variables_name_str { #1 }
  }
  \prop_clear:N \l_tmpa_prop
  \prop_put:Nnx \l_tmpa_prop { arity }{\int_use:N \l__stex_variables_args_int}

  \seq_set_from_clist:Nn \l_tmpa_seq {#3}
  \int_compare:nNnF {\seq_count:N \l_tmpa_seq} = \l__stex_variables_args_int {
    \msg_error:nnxx{stex}{error/seqlength}
      {\int_use:N \l__stex_variables_args_int}
      {\seq_count:N \l_tmpa_seq}
  }
  \seq_set_from_clist:Nn \l_tmpb_seq {#4}
  \int_compare:nNnF {\seq_count:N \l_tmpb_seq} = \l__stex_variables_args_int {
    \msg_error:nnxx{stex}{error/seqlength}
      {\int_use:N \l__stex_variables_args_int}
      {\seq_count:N \l_tmpb_seq}
  }
  \prop_put:Nnn \l_tmpa_prop {starts} {#3}
  \prop_put:Nnn \l_tmpa_prop {ends} {#4}

  \cs_generate_from_arg_count:cNnn {stex_varseq_\l__stex_variables_name_str _cs}
    \cs_set:Npn  {\int_use:N \l__stex_variables_args_int} { #5 }

  % argnames

  \clist_clear:N \l_tmpa_clist
  \int_step_inline:nn {\l__stex_variables_args_int} {
      \clist_put_right:Nn \l_tmpa_clist {##1}
  }
  \prop_put:Nnx \l_tmpa_prop {argnames} {\clist_use:Nn \l_tmpa_clist ,}

  \exp_args:NNo \tl_set:No \l_tmpa_tl {\use:c{stex_varseq_\l__stex_variables_name_str _cs}}
  \int_step_inline:nn \l__stex_variables_args_int {
    \tl_put_right:Nx \l_tmpa_tl { {\seq_item:Nn \l_tmpa_seq {##1}} }
  }
  \tl_set:Nx \l_tmpa_tl {\exp_args:NNo \exp_args:No \exp_not:n{\l_tmpa_tl}}
  \tl_put_right:Nn \l_tmpa_tl {,\ellipses,}
  \tl_if_empty:NF \l__stex_variables_mid_tl {
    \tl_put_right:No \l_tmpa_tl \l__stex_variables_mid_tl
    \tl_put_right:Nn \l_tmpa_tl {,\ellipses,}
  }
  \exp_args:NNo \tl_set:No \l_tmpb_tl {\use:c{stex_varseq_\l__stex_variables_name_str _cs}}
  \int_step_inline:nn \l__stex_variables_args_int {
    \tl_put_right:Nx \l_tmpb_tl { {\seq_item:Nn \l_tmpb_seq {##1}} }
  }
  \tl_set:Nx \l_tmpb_tl {\exp_args:NNo \exp_args:No \exp_not:n{\l_tmpb_tl}}
  \tl_put_right:No \l_tmpa_tl \l_tmpb_tl

  \prop_put:Nno \l_tmpa_prop { notation }\l_tmpa_tl

  \tl_set:cx {#1} {\stex_invoke_sequence:n {\l__stex_variables_name_str}}

  \exp_args:NNo \tl_set:No \l_tmpa_tl {\use:c{stex_varseq_\l__stex_variables_name_str _cs}}

  \int_step_inline:nn \l__stex_variables_args_int {
    \tl_set:Nx \l_tmpa_tl {\exp_args:No \exp_not:n \l_tmpa_tl {
      \STEXInternalTermMathArgiii{i##1}{0}{\exp_not:n{####}##1}
    }}
  }

  \tl_set:Nx \l_tmpa_tl {
    \STEXInternalTermMathOMAiiii { varseq://\l__stex_variables_name_str}{}{0}{
      \exp_args:NNo \exp_args:No \exp_not:n {\l_tmpa_tl}
    }
  }

  \tl_set:No \l_tmpa_tl { \exp_after:wN { \l_tmpa_tl \STEXInternalSymbolAfterInvokationTL} }

  \exp_args:Nno \use:nn {
  \cs_generate_from_arg_count:cNnn {stex_varseq_\l__stex_variables_name_str _cs}
    \cs_set:Npn {\int_use:N \l__stex_variables_args_int}}{\l_tmpa_tl}

  \stex_debug:nn{sequences}{New~Sequence:~
    \expandafter\meaning\csname stex_varseq_\l__stex_variables_name_str _cs\endcsname\\~\\
    \prop_to_keyval:N \l_tmpa_prop
  }
  \prop_set_eq:cN {l_stex_symdecl_varseq://\l__stex_variables_name_str _prop}\l_tmpa_prop

  \stex_if_do_html:T{\stex_annotate_invisible:nnn{varseq}{\l__stex_variables_name_str}{
    \tl_if_empty:NF \l__stex_variables_type_tl {
      \stex_annotate:nnn {type}{}{$\l__stex_variables_type_tl$}
    }
    \stex_annotate:nnn {args}{\int_use:N \l__stex_variables_args_int}{}
    \str_if_empty:NF \l__stex_variables_bind_str {
      \stex_annotate:nnn {bindtype}{\l__stex_variables_bind_str}{}
    }
    \stex_annotate:nnn{startindex}{}{$#3$}
    \stex_annotate:nnn{endindex}{}{$#4$}

    \tl_clear:N \l_tmpa_tl
    \int_step_inline:nn \l__stex_variables_args_int {
      \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
        \stex_annotate:nnn{argmarker}{##1}{}
      } }
    }
    \stex_annotate_invisible:nnn { notationcomp }{}{
      \str_set:Nx \STEXInternalCurrentSymbolStr {varseq://\l__stex_variables_name_str }
      $ \exp_args:Nno \use:nn { \use:c {
        stex_varseq_\l__stex_variables_name_str _cs
      } } { \l_tmpa_tl } $
    }
    \stex_annotate_invisible:nnn { notationopcomp }{}{
      $ \prop_item:Nn \l_tmpa_prop { notation } $
    }

  }}

  \ignorespacesandpars
}

\keys_define:nn { stex / mmtdecl } {
  name        .str_set_x:N  = \l_stex_symdecl_name_str ,
  args        .str_set_x:N  = \l_stex_symdecl_args_str ,
  deprecate   .str_set_x:N  = \l_stex_symdecl_deprecate_str ,
  reorder     .str_set_x:N  = \l_stex_symdecl_reorder_str ,
  argnames    .clist_set:N  = \l_stex_symdecl_argnames_clist ,
  assoc       .choices:nn   =
      {bin,binl,binr,pre,conj,pwconj}
      {\str_set:Nx \l_stex_symdecl_assoctype_str {\l_keys_choice_tl}}
}

\cs_new_protected:Nn \_stex_mmtdecl_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \str_clear:N \l_stex_symdecl_deprecate_str
  \str_clear:N \l_stex_symdecl_reorder_str
  \str_clear:N \l_stex_symdecl_assoctype_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \clist_clear:N \l_stex_symdecl_argnames_clist

  \keys_set:nn { stex / symdecl } { #1 }
}

\NewDocumentCommand \mmtdecl { s m O{}} {
  \_stex_mmtdecl_args:n{#3}
  \IfBooleanTF #1 {
    \bool_set_false:N \l_stex_symdecl_make_macro_bool
  } {
    \bool_set_true:N \l_stex_symdecl_make_macro_bool
  }
  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }
  %\tl_set:Nx \l_stex_symdecl_definiens_tl {
  %  \stex_annotate:nnn{ OMID }{
  %    \l_stex_module_mmtfor_str?\l_stex_symdecl_name_str
  %  }{}
  %}
  \stex_symdecl_do:n{#2}
  \MMTrule{rules.stex.mmt.kwarc.info?SubstitutionRule}{
    \stex_annotate:nnn{ OMID }{
      \l_stex_current_module_str ? \l_stex_symdecl_name_str
    }{},
    \stex_annotate:nnn{ OMID }{
      \l_stex_module_mmtfor_str?\l_stex_symdecl_name_str
    }{}
  }
  \stex_smsmode_do:
}

\stex_deactivate_macro:Nn \mmtdecl {mmtinterface~environments}
\stex_deactivate_macro:Nn \mmtdef {mmtinterface~environments}



%%%%%%%%%%%%%   terms.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/nonotation}{
  Symbol~#1~invoked,~but~has~no~notation#2!
}
\msg_new:nnn{stex}{error/notationarg}{
  Error~in~parsing~notation~#1
}
\msg_new:nnn{stex}{error/noop}{
  Symbol~#1~has~no~operator~notation~for~notation~#2
}
\msg_new:nnn{stex}{error/notallowed}{
  Symbol~invokation~#1~not~allowed~in~notation~component~of~#2
}
\msg_new:nnn{stex}{error/doubleargument}{
  Argument~#1~of~symbol~#2~already~assigned
}
\msg_new:nnn{stex}{error/overarity}{
  Argument~#1~invalid~for~symbol~#2~with~arity~#3
}


\bool_new:N \l_stex_allow_semantic_bool
\bool_set_true:N \l_stex_allow_semantic_bool

\cs_new_protected:Nn \stex_invoke_symbol:n {
  \ifvmode\indent\fi
  \bool_if:NTF \l_stex_allow_semantic_bool {
    \str_if_eq:eeF {
      \prop_item:cn {
        l_stex_symdecl_#1_prop
      }{ deprecate }
    }{}{
      \msg_warning:nnxx{stex}{warning/deprecated}{
        Symbol~#1
      }{
        \prop_item:cn {l_stex_symdecl_#1_prop}{ deprecate }
      }
    }
    \if_mode_math:
      \exp_after:wN \__stex_terms_invoke_math:n
    \else:
      \exp_after:wN \__stex_terms_invoke_text:n
    \fi: { #1 }
  }{
    \msg_error:nnxx{stex}{error/notallowed}{#1}{\STEXInternalCurrentSymbolStr}
  }
}

\cs_new_protected:Nn \__stex_terms_invoke_text:n {
  \peek_charcode_remove:NTF ! {
    \__stex_terms_invoke_op_custom:nn {#1}
  }{
    \__stex_terms_invoke_custom:nn {#1}
  }
}

\cs_new_protected:Nn \__stex_terms_invoke_math:n {
  \peek_charcode_remove:NTF ! {
    % operator
    \peek_charcode_remove:NTF * {
      % custom op
      \__stex_terms_invoke_op_custom:nn {#1}
    }{
      % op notation
      \peek_charcode:NTF [ {
        \__stex_terms_invoke_op_notation:nw {#1}
      }{
        \__stex_terms_invoke_op_notation:nw {#1}[]
      }
    }
  }{
    \peek_charcode_remove:NTF * {
      \__stex_terms_invoke_custom:nn {#1}
      % custom
    }{
      % normal
      \peek_charcode:NTF [ {
        \__stex_terms_invoke_notation:nw {#1}
      }{
        \__stex_terms_invoke_notation:nw {#1}[]
      }
    }
  }
}

\cs_new_protected:Nn \__stex_terms_invoke_op_custom:nn {
  \exp_args:Nnx \use:nn {
    \def\comp{\_comp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { #1 }
    \bool_set_false:N \l_stex_allow_semantic_bool
    \stex_mathml_intent:nn{#1}{
      \_stex_term_oms:nnn {#1}{#1 \c_hash_str CUSTOM-}{
        \comp{ #2 }
      }
    }
  }{
    \_stex_reset:N \comp
    \_stex_reset:N \STEXInternalCurrentSymbolStr
    \bool_set_true:N \l_stex_allow_semantic_bool
  }
}

\keys_define:nn { stex / terms } {
  variant .tl_set_x:N = \l_stex_notation_variant_str ,
  unknown .code:n     = \str_set:Nx
      \l_stex_notation_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \__stex_terms_args:n {
 % \str_clear:N \l_stex_notation_lang_str
  \str_clear:N \l_stex_notation_variant_str

  \keys_set:nn { stex / terms } { #1 }
}

\cs_new_protected:Nn \stex_find_notation:nn {
  \__stex_terms_args:n { #2 }
  \seq_if_empty:cTF {
    l_stex_symdecl_ #1 _notations
  } {
    \msg_error:nnxx{stex}{error/nonotation}{#1}{s}
  } {
    \str_if_empty:NTF \l_stex_notation_variant_str {
      \seq_get_left:cN {l_stex_symdecl_#1_notations}\l_stex_notation_variant_str
    }{
      \seq_if_in:cxTF {l_stex_symdecl_#1_notations}{
        \l_stex_notation_variant_str
      }{
      %  \str_set:Nx \l_stex_notation_variant_str { \l_stex_notation_variant_str \c_hash_str \l_stex_notation_lang_str }
      }{
        \msg_error:nnxx{stex}{error/nonotation}{#1}{
          ~\l_stex_notation_variant_str
        }
      }
    }
  }
}

\cs_new_protected:Npn \__stex_terms_invoke_op_notation:nw #1 [#2] {
  \exp_args:Nnx \use:nn {
    \def\comp{\_comp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { #1 }
    \stex_find_notation:nn { #1 }{ #2 }
    \bool_set_false:N \l_stex_allow_semantic_bool
    \cs_if_exist:cTF {
      stex_op_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs
    }{
      \_stex_term_oms:nnn { #1 }{
        #1 \c_hash_str \l_stex_notation_variant_str
      }{
        \use:c{stex_op_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs}
      }
    }{
      \int_compare:nNnTF {\prop_item:cn {l_stex_symdecl_#1_prop}{arity}} = 0{
        \cs_if_exist:cTF {
          stex_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs
        }{
          \tl_set:Nx \STEXInternalSymbolAfterInvokationTL {
            \_stex_reset:N \comp
            \_stex_reset:N \STEXInternalSymbolAfterInvokationTL
            \_stex_reset:N \STEXInternalCurrentSymbolStr
            \bool_set_true:N \l_stex_allow_semantic_bool
          }
          \def\comp{\_comp}
          \str_set:Nn \STEXInternalCurrentSymbolStr { #1 }
          \bool_set_false:N \l_stex_allow_semantic_bool
          \use:c{stex_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs}
        }{
          \msg_error:nnxx{stex}{error/nonotation}{#1}{
            ~\l_stex_notation_variant_str
          }
        }
      }{
        \msg_error:nnxx{stex}{error/noop}{#1}{\l_stex_notation_variant_str}
      }
    }
  }{
    \_stex_reset:N \comp
    \_stex_reset:N \STEXInternalCurrentSymbolStr
    \bool_set_true:N \l_stex_allow_semantic_bool
  }
}

\cs_new_protected:Npn \__stex_terms_invoke_notation:nw #1 [#2] {
  \stex_find_notation:nn { #1 }{ #2 }
  \cs_if_exist:cTF {
    stex_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs
  }{
    \tl_set:Nx \STEXInternalSymbolAfterInvokationTL {
      \_stex_reset:N \comp
      \_stex_reset:N \STEXInternalSymbolAfterInvokationTL
      \_stex_reset:N \STEXInternalCurrentSymbolStr
      \bool_set_true:N \l_stex_allow_semantic_bool
    }
    \def\comp{\_comp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { #1 }
    \bool_set_false:N \l_stex_allow_semantic_bool
    \use:c{stex_notation_ #1 \c_hash_str \l_stex_notation_variant_str _cs}
  }{
    \msg_error:nnxx{stex}{error/nonotation}{#1}{
      ~\l_stex_notation_variant_str
    }
  }
}

\prop_new:N \l__stex_terms_custom_args_prop
\clist_new:N \l_stex_argnames_seq
\seq_new:N \l__stex_terms_tmp_seq

\cs_new_protected:Nn\__stex_terms_custom_comp:n{\bool_set_false:N \l_stex_allow_semantic_bool\_comp{#1}\bool_set_true:N \l_stex_allow_semantic_bool}

\cs_new_protected:Nn \__stex_terms_invoke_custom:nn {
  \exp_args:Nnx \use:nn {
    \def\comp{\__stex_terms_custom_comp:n}
    \str_set:Nn \STEXInternalCurrentSymbolStr { #1 }
    \prop_clear:N \l__stex_terms_custom_args_prop
    \prop_put:Nnn \l__stex_terms_custom_args_prop {currnum} {1}
    \prop_get:cnN {
      l_stex_symdecl_#1 _prop
    }{ args } \l_tmpa_str
    \exp_args:NNx \seq_set_from_clist:Nn \l_stex_argnames_seq {
      \prop_item:cn {l_stex_symdecl_#1 _prop}{argnames}
    }
    \prop_put:Nno \l__stex_terms_custom_args_prop {args} \l_tmpa_str
    \tl_set:Nn \arg { \__stex_terms_arg: }
    \str_if_empty:NTF \l_tmpa_str {
      \stex_mathml_intent:nn{#1}{
        \_stex_term_oms:nnn {#1}{#1\c_hash_str CUSTOM-}{\ignorespaces#2}
      }
    }{
      %\bool_set_false:N \l_stex_allow_semantic_bool
      \seq_clear:N \l__stex_terms_tmp_seq
      \exp_args:Nx\int_step_inline:nn{\prop_item:cn{l_stex_symdecl_#1 _prop}{arity}}{
        \tl_set:Nx \l__stex_terms_tmp_tl {\seq_item:Nn \l_stex_argnames_seq {##1}}
        \bool_lazy_or:nnT{
          \str_if_eq_p:nn{a}{\str_item:Nn\l_tmpa_str{##1}}
        }{
          \str_if_eq_p:nn{B}{\str_item:Nn\l_tmpa_str{##1}}
        }{
          \tl_put_right:Nn \l__stex_terms_tmp_tl +
        }
        \seq_put_right:No \l__stex_terms_tmp_seq \l__stex_terms_tmp_tl
      }
      \stex_mathml_intent:nn{
        #1[\prop_item:cn {l_stex_symdecl_#1 _prop}{ args }](
          \seq_use:Nn \l__stex_terms_tmp_seq ,
        )
      }{
        \str_if_in:NnTF \l_tmpa_str b {
          \_stex_term_ombind:nnn {#1}{#1\c_hash_str CUSTOM-\l_tmpa_str}{\ignorespaces#2}
        }{
          \str_if_in:NnTF \l_tmpa_str B {
            \_stex_term_ombind:nnn {#1}{#1\c_hash_str CUSTOM-\l_tmpa_str}{\ignorespaces#2}
          }{
            \_stex_term_oma:nnn {#1}{#1\c_hash_str CUSTOM-\l_tmpa_str}{\ignorespaces#2}
          }
        }
      }
    }
    % TODO check that all arguments exist
  }{
    \_stex_reset:N \l_stex_argnames_seq
    \_stex_reset:N \STEXInternalCurrentSymbolStr
    \_stex_reset:N \arg
    \_stex_reset:N \comp
    \_stex_reset:N \l__stex_terms_custom_args_prop
    %\bool_set_true:N \l_stex_allow_semantic_bool
  }
}

\NewDocumentCommand \__stex_terms_arg: { s O{} m}{
  \tl_if_empty:nTF {#2}{
    \int_set:Nn \l_tmpa_int {\prop_item:Nn \l__stex_terms_custom_args_prop {currnum}}
    \bool_set_true:N \l_tmpa_bool
    \bool_do_while:Nn \l_tmpa_bool {
      \exp_args:NNx \prop_if_in:NnTF \l__stex_terms_custom_args_prop {\int_use:N \l_tmpa_int} {
        \int_incr:N \l_tmpa_int
      }{
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }{
    \int_set:Nn \l_tmpa_int { #2 }
  }
  \str_set:Nx \l_tmpa_str {\prop_item:Nn \l__stex_terms_custom_args_prop {args} }
  \int_compare:nNnT \l_tmpa_int > {\str_count:N \l_tmpa_str} {
    \msg_error:nnxxx{stex}{error/overarity}
      {\int_use:N \l_tmpa_int}
      {\STEXInternalCurrentSymbolStr}
      {\str_count:N \l_tmpa_str}
  }
  \str_set:Nx \l_tmpa_str {\str_item:Nn \l_tmpa_str \l_tmpa_int}
  \exp_args:NNx \prop_if_in:NnT \l__stex_terms_custom_args_prop {\int_use:N \l_tmpa_int} {
    \bool_lazy_any:nF {
      {\str_if_eq_p:Vn \l_tmpa_str {a}}
      {\str_if_eq_p:Vn \l_tmpa_str {B}}
    }{
      \msg_error:nnxx{stex}{error/doubleargument}
        {\int_use:N \l_tmpa_int}
        {\STEXInternalCurrentSymbolStr}
    }
  }
  \exp_args:NNx \prop_put:Nnn \l__stex_terms_custom_args_prop {\int_use:N \l_tmpa_int} {\ignorespaces#3}
  \bool_if:NTF \l_stex_allow_semantic_bool \use_i:nn {
    \bool_set_true:N \l_stex_allow_semantic_bool
    \use:nn
  }
  {
  \stex_mathml_arg:nn{\seq_item:Nn \l_stex_argnames_seq \l_tmpa_int}{
    \IfBooleanTF#1{
      \stex_annotate_invisible:n { %TODO
        \exp_args:No \_stex_term_arg:nn {\l_tmpa_str\int_use:N \l_tmpa_int}{\ignorespaces#3}
      }
    }{ %TODO
      \exp_args:No \_stex_term_arg:nn {\l_tmpa_str\int_use:N \l_tmpa_int}{\ignorespaces#3}
    }
  }}
  {}\bool_set_true:N \l_stex_allow_semantic_bool
}

\cs_new_protected:Nn \_stex_term_arg:nn {
  \bool_set_true:N \l_stex_allow_semantic_bool
  \stex_annotate:nnn{ arg }{ #1 }{ #2 }
  \bool_set_false:N \l_stex_allow_semantic_bool
}

\cs_new_protected:Npn \STEXInternalTermMathArgiii #1#2#3 {
  \exp_args:Nnx \use:nn
    { \int_set:Nn \l__stex_terms_downprec { #2 }
      \stex_mathml_arg:nn{\seq_item:Nn \l_stex_argnames_seq \l_tmpa_int}{
        \_stex_term_arg:nn { #1 }{ #3 }
      }
    }
    { \int_set:Nn \exp_not:N \l__stex_terms_downprec { \int_use:N \l__stex_terms_downprec } }
}
\cs_new_protected:Npn \STEXInternalTermMathAssocArgiiiii #1#2#3#4#5 {
  \cs_set:Npn \l_tmpa_cs ##1 ##2 { #4 }
  \tl_set:Nn \l_tmpb_tl {\STEXInternalTermMathArgiii{#5#1}{#2}}
  \tl_if_empty:nTF { #3 }{
    \STEXInternalTermMathArgiii{#5#1}{#2}{}
  }{
    \exp_args:Nx \tl_if_empty:nTF { \tl_tail:n{ #3 }}{
      \expandafter\if\expandafter\relax\noexpand#3
        \tl_set:Nn \l_tmpa_tl {\__stex_terms_math_assoc_arg_maybe_sequence:Nnn#3{#1}{#5}}
      \else
        \tl_set:Nn \l_tmpa_tl {\__stex_terms_math_assoc_arg_simple:nnn{#1}{#3}{#5}}
      \fi
      \l_tmpa_tl
    }{
      \__stex_terms_math_assoc_arg_simple:nnn{#1}{#3}{#5}
    }
  }
}

\cs_new_protected:Nn \__stex_terms_math_assoc_arg_maybe_sequence:Nnn {
  \str_set:Nx \l_tmpa_str { \cs_argument_spec:N #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \exp_args:Nx \cs_if_eq:NNTF {
      \tl_head:N #1
    } \stex_invoke_sequence:n {
      \tl_set:Nx \l_tmpa_tl {\tl_tail:N #1}
      \str_set:Nx \l_tmpa_str {\exp_after:wN \use:n \l_tmpa_tl}
      \tl_set:Nx \l_tmpa_tl {\prop_item:cn {l_stex_symdecl_varseq://\l_tmpa_str _prop}{notation}}
      \exp_args:NNo \seq_set_from_clist:Nn \l_tmpa_seq \l_tmpa_tl
      \tl_set:Nx \l_tmpa_tl {{\exp_not:N \exp_not:n{
        \exp_not:n{\exp_args:Nnx \use:nn} {
          \exp_not:n {
            \def\comp{\_varcomp}
            \str_set:Nn \STEXInternalCurrentSymbolStr
          } {varseq://\l_tmpa_str}
          \exp_not:n{ ##1 }
        }{
          \exp_not:n {
            \_stex_reset:N \comp
            \_stex_reset:N \STEXInternalCurrentSymbolStr
          }
        }
      }}}
      \exp_args:Nno \use:n {\seq_set_map:NNn \l_tmpa_seq \l_tmpa_seq} \l_tmpa_tl
      \seq_reverse:N \l_tmpa_seq
      \seq_pop:NN \l_tmpa_seq \l_tmpa_tl
      \seq_map_inline:Nn \l_tmpa_seq {
        \exp_args:NNNo \exp_args:NNo \tl_set:No \l_tmpa_tl {
          \exp_args:Nno
          \l_tmpa_cs { ##1 } \l_tmpa_tl
        }
      }
      \tl_set:Nx \l_tmpa_tl {
        \_stex_term_omv:nn {varseq://\l_tmpa_str}{
          \exp_args:No \exp_not:n \l_tmpa_tl
        }
      }
      \exp_args:No\l_tmpb_tl\l_tmpa_tl
    }{
      \__stex_terms_math_assoc_arg_simple:nnn{#2} { #1 }{#3}
    }
  } {
    \__stex_terms_math_assoc_arg_simple:nnn{#2} { #1 }{#3}
  }

}

\cs_new_protected:Nn \__stex_terms_math_assoc_arg_simple:nnn {
  \clist_set:Nn \l_tmpa_clist{ #2 }
  \int_compare:nNnTF { \clist_count:N \l_tmpa_clist } < 2 {
    \tl_set:Nn \l_tmpa_tl {
      \stex_mathml_arg:nn{\seq_item:Nn \l_stex_argnames_seq #1}{
        \_stex_term_arg:nn{A#3#1}{ #2 } }
    }
  }{
    \clist_reverse:N \l_tmpa_clist
    \clist_pop:NN \l_tmpa_clist \l_tmpa_tl
    \tl_set:Nx \l_tmpa_tl {
      \stex_mathml_arg:nn{\seq_item:Nn \l_stex_argnames_seq #1}{
        \_stex_term_arg:nn{A#3#1}{
        \exp_args:No \exp_not:n \l_tmpa_tl
      }
    }}
    \clist_map_inline:Nn \l_tmpa_clist {
      \exp_args:NNNo \exp_args:NNo \tl_set:No \l_tmpa_tl {
        \exp_args:Nno
        \l_tmpa_cs {
          \stex_mathml_arg:nn{\seq_item:Nn \l_stex_argnames_seq #1}{
            \_stex_term_arg:nn{A#3#1}{##1}
          }
        } \l_tmpa_tl
      }
    }
  }
  \exp_args:No\l_tmpb_tl\l_tmpa_tl
}
\tl_const:Nx \infprec {\int_use:N \c_max_int}
\tl_const:Nx \neginfprec {-\int_use:N \c_max_int}
\int_new:N \l__stex_terms_downprec
\int_set_eq:NN \l__stex_terms_downprec \infprec
\tl_set:Nn \l__stex_terms_left_bracket_str (
\tl_set:Nn \l__stex_terms_right_bracket_str )
\cs_new_protected:Nn \__stex_terms_maybe_brackets:nn {
  \bool_if:NTF \l__stex_terms_brackets_done_bool {
    \bool_set_false:N \l__stex_terms_brackets_done_bool
    #2
  } {
    \int_compare:nNnTF { #1 } > \l__stex_terms_downprec {
      \bool_if:NTF \l_stex_inparray_bool { #2 }{
        \stex_debug:nn{dobrackets}{\number#1 > \number\l__stex_terms_downprec; \detokenize{#2}}
        \dobrackets { #2 }
      }
    }{ #2 }
  }
}
\bool_new:N \l__stex_terms_brackets_done_bool
\cs_new_protected:Npn \dobrackets #1 {
  %\ThisStyle{\if D\m@switch
  %    \exp_args:Nnx \use:nn
  %    { \exp_after:wN \left\l__stex_terms_left_bracket_str #1 }
  %    { \exp_not:N\right\l__stex_terms_right_bracket_str }
  %  \else
      \exp_args:Nnx \use:nn
      {
        \bool_set_true:N \l__stex_terms_brackets_done_bool
        \int_set:Nn \l__stex_terms_downprec \infprec
        \l__stex_terms_left_bracket_str
        #1
      }
      {
        \bool_set_false:N \l__stex_terms_brackets_done_bool
        \l__stex_terms_right_bracket_str
        \int_set:Nn \l__stex_terms_downprec { \int_use:N \l__stex_terms_downprec }
      }
  %\fi}
}
\cs_new_protected:Npn \withbrackets #1 #2 #3 {
  \exp_args:Nnx \use:nn
  {
    \tl_set:Nx \l__stex_terms_left_bracket_str { #1 }
    \tl_set:Nx \l__stex_terms_right_bracket_str { #2 }
    #3
  }
  {
    \tl_set:Nn \exp_not:N \l__stex_terms_left_bracket_str
      {\l__stex_terms_left_bracket_str}
    \tl_set:Nn \exp_not:N \l__stex_terms_right_bracket_str
      {\l__stex_terms_right_bracket_str}
  }
}
\cs_new_protected:Npn \STEXinvisible #1 {
  \stex_annotate_invisible:n { #1 }
}
\cs_new_protected:Nn \_stex_term_oms:nnn {
  \stex_annotate:nnn{ OMID }{ #2 }{
    #3
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMSiiii #1#2#3#4 {
  \__stex_terms_maybe_brackets:nn { #3 }{
    \stex_mathml_intent:nn{#1} {
      \_stex_term_oms:nnn { #1 } { #1\c_hash_str#2 } { #4 }
    }
  }
}
\cs_new_protected:Nn \_stex_term_omv:nn {
  \stex_annotate:nnn{ OMV }{ #1 }{
    #2
  }
}
\cs_new_protected:Nn \_stex_term_oma:nnn {
  \stex_annotate:nnn{ OMA }{ #2 }{
    #3
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMAiiii #1#2#3#4 {
  \exp_args:Nnx \use:nn {
    \seq_clear:N \l__stex_terms_tmp_seq
    \prop_if_exist:cT{l_stex_symdecl_#1 _prop}{
    \exp_args:NNx \seq_set_from_clist:Nn \l_stex_argnames_seq {
      \prop_item:cn {l_stex_symdecl_#1 _prop}{argnames}
    }
    \exp_args:Nx\int_step_inline:nn{\prop_item:cn{l_stex_symdecl_#1 _prop}{arity}}{
      \tl_set:Nx \l__stex_terms_tmp_tl {\seq_item:Nn \l_stex_argnames_seq {##1}}
      \bool_lazy_or:nnT{
        \str_if_eq_p:nn{a}{\str_item:Nn\l_tmpa_str{##1}}
      }{
        \str_if_eq_p:nn{B}{\str_item:Nn\l_tmpa_str{##1}}
      }{
        \tl_put_right:Nn \l__stex_terms_tmp_tl +
      }
      \seq_put_right:No \l__stex_terms_tmp_seq \l__stex_terms_tmp_tl
    }
  }
  \__stex_terms_maybe_brackets:nn { #3 }{
    \stex_mathml_intent:nn{
      #1[\prop_item:cn {l_stex_symdecl_#1 _prop}{ args }](
        \seq_use:Nn \l__stex_terms_tmp_seq ,
      )
    }{
      \_stex_term_oma:nnn { #1 } { #1\c_hash_str#2 } { #4 }
    }
  }
  }{
    \_stex_reset:N \l_stex_argnames_seq
  }
}
\cs_new_protected:Nn \_stex_term_ombind:nnn {
  \stex_annotate:nnn{ OMBIND }{ #2 }{
    #3
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMBiiii #1#2#3#4 {
  \exp_args:Nnx \use:nn {
    \seq_clear:N \l__stex_terms_tmp_seq
    \prop_if_exist:cT{l_stex_symdecl_#1 _prop}{
    \exp_args:NNx \seq_set_from_clist:Nn \l_stex_argnames_seq {
      \prop_item:cn {l_stex_symdecl_#1 _prop}{argnames}
    }
    \exp_args:Nx\int_step_inline:nn{\prop_item:cn{l_stex_symdecl_#1 _prop}{arity}}{
      \tl_set:Nx \l__stex_terms_tmp_tl {\seq_item:Nn \l_stex_argnames_seq {##1}}
      \bool_lazy_or:nnT{
        \str_if_eq_p:nn{a}{\str_item:Nn\l_tmpa_str{##1}}
      }{
        \str_if_eq_p:nn{B}{\str_item:Nn\l_tmpa_str{##1}}
      }{
        \tl_put_right:Nn \l__stex_terms_tmp_tl +
      }
      \seq_put_right:No \l__stex_terms_tmp_seq \l__stex_terms_tmp_tl
    }
  }
  \__stex_terms_maybe_brackets:nn { #3 }{
    \stex_mathml_intent:nn{
      #1[\prop_item:cn {l_stex_symdecl_#1 _prop}{ args }](
        \seq_use:Nn \l__stex_terms_tmp_seq ,
      )
    }{
      \_stex_term_ombind:nnn { #1 } { #1\c_hash_str#2 } { #4 }
    }
  }
  }{
    \_stex_reset:N \l_stex_argnames_seq
  }
}
\cs_new:Nn \stex_capitalize:n { \uppercase{#1} }

\keys_define:nn { stex / symname } {
  pre     .tl_set_x:N    = \l__stex_terms_pre_tl ,
  post    .tl_set_x:N    = \l__stex_terms_post_tl ,
  root    .tl_set_x:N    = \l__stex_terms_root_tl
}

\cs_new_protected:Nn \stex_symname_args:n {
  \tl_clear:N \l__stex_terms_post_tl
  \tl_clear:N \l__stex_terms_pre_tl
  \tl_clear:N \l__stex_terms_root_str
  \keys_set:nn { stex / symname } { #1 }
}

\NewDocumentCommand \symref { m m }{
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \STEXsymbol{#1}!{ #2 }
  \let\compemph@uri\compemph_uri_prev:
}

\NewDocumentCommand \synonym { O{} m m}{
  \stex_symname_args:n { #1 }
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  % TODO
  \STEXsymbol{#2}!{\l__stex_terms_pre_tl #3 \l__stex_terms_post_tl}
  \let\compemph@uri\compemph_uri_prev:
}

\NewDocumentCommand \symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}

  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }!\ifmmode*\fi{
    \l__stex_terms_pre_tl \l_tmpa_str \l__stex_terms_post_tl
   } }
  \let\compemph@uri\compemph_uri_prev:
}

\NewDocumentCommand \Symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }!\ifmmode*\fi{
    \exp_after:wN \stex_capitalize:n \l_tmpa_str
      \l__stex_terms_post_tl
   } }
  \let\compemph@uri\compemph_uri_prev:
}
\cs_new_protected:Npn \_comp #1 {
  \str_if_empty:NF \STEXInternalCurrentSymbolStr {
    \stex_html_backend:TF {
      \stex_annotate:nnn { comp }{ \STEXInternalCurrentSymbolStr }{ #1 }
    }{
      \exp_args:Nnx \compemph@uri { #1 } { \STEXInternalCurrentSymbolStr }
    }
  }
}

\cs_new_protected:Npn \_varcomp #1 {
  \str_if_empty:NF \STEXInternalCurrentSymbolStr {
    \stex_html_backend:TF {
      \stex_annotate:nnn { varcomp }{ \STEXInternalCurrentSymbolStr }{ #1 }
    }{
      \exp_args:Nnx \varemph@uri { #1 } { \STEXInternalCurrentSymbolStr }
    }
  }
}

\def\comp{\_comp}

\cs_new_protected:Npn \compemph@uri #1 #2 {
    \compemph{ #1 }
}

\cs_new_protected:Npn \compemph #1 {
    #1
}

\cs_new_protected:Npn \defemph@uri #1 #2 {
    \defemph{#1}
}

\cs_new_protected:Npn \defemph #1 {
    \textbf{#1}
}

\cs_new_protected:Npn \symrefemph@uri #1 #2 {
    \symrefemph{#1}
}

\cs_new_protected:Npn \symrefemph #1 {
    \emph{#1}
}

\cs_new_protected:Npn \varemph@uri #1 #2 {
    \varemph{#1}
}

\cs_new_protected:Npn \varemph #1 {
    #1
}
\NewDocumentCommand \ellipses {} { \ldots }
\bool_new:N \l_stex_inparray_bool
\bool_set_false:N \l_stex_inparray_bool
\NewDocumentCommand \parray { m m } {
  \begingroup
  \bool_set_true:N \l_stex_inparray_bool
  \begin{array}{#1}
    #2
  \end{array}
  \endgroup
}

\NewDocumentCommand \prmatrix { m } {
  \begingroup
  \bool_set_true:N \l_stex_inparray_bool
  \begin{matrix}
    #1
  \end{matrix}
  \endgroup
}

\def \maybephline {
  \bool_if:NT \l_stex_inparray_bool {\hline}
}

\def \parrayline #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\}
}

\def \pmrow #1 { \parrayline{}{ #1 } }

\def \parraylineh #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\\hline}
}

\def \parraycell #1 {
  #1 \bool_if:NT \l_stex_inparray_bool {&}
}
\cs_new_protected:Nn \stex_invoke_variable:n {
  \if_mode_math:
    \exp_after:wN \__stex_variables_invoke_math:n
  \else:
    \exp_after:wN \__stex_variables_invoke_text:n
  \fi: {#1}
}

\cs_new_protected:Nn \__stex_variables_invoke_text:n {
  \peek_charcode_remove:NTF ! {
    \__stex_variables_invoke_op_custom:nn {#1}
  }{
    \__stex_variables_invoke_custom:nn {#1}
  }
}

\cs_new_protected:Nn \__stex_variables_invoke_math:n {
  \peek_charcode_remove:NTF ! {
    \peek_charcode_remove:NTF ! {
      \peek_charcode:NTF [ {
        % TODO throw error
      }{
        \__stex_variables_invoke_op_custom:nn
      }
    }{
      \__stex_variables_invoke_op:n { #1 }
    }
  }{
    \peek_charcode_remove:NTF * {
      \__stex_variables_invoke_custom:nn { #1 }
    }{
      \__stex_variables_invoke_math_ii:n { #1 }
    }
  }
}

\cs_new_protected:Nn \__stex_variables_invoke_op_custom:nn {
  \exp_args:Nnx \use:nn {
    \def\comp{\_varcomp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { var://#1 }
    \bool_set_false:N \l_stex_allow_semantic_bool
    \_stex_term_omv:nn {var://#1}{
      \comp{ #2 }
    }
  }{
    \_stex_reset:N \comp
    \_stex_reset:N \STEXInternalCurrentSymbolStr
    \bool_set_true:N \l_stex_allow_semantic_bool
  }
}

\cs_new_protected:Nn \__stex_variables_invoke_op:n {
  \cs_if_exist:cTF {
    stex_var_op_notation_ #1 _cs
  }{
    \exp_args:Nnx \use:nn {
      \def\comp{\_varcomp}
      \str_set:Nn \STEXInternalCurrentSymbolStr { var://#1 }
      \_stex_term_omv:nn { var://#1 }{
        \use:c{stex_var_op_notation_ #1 _cs }
      }
    }{
      \_stex_reset:N \comp
      \_stex_reset:N \STEXInternalCurrentSymbolStr
    }
  }{
    \int_compare:nNnTF {\prop_item:cn {l_stex_symdecl_var://#1_prop}{arity}} = 0{
      \__stex_variables_invoke_math_ii:n {#1}
    }{
      \msg_error:nnxx{stex}{error/noop}{variable~#1}{}
    }
  }
}

\cs_new_protected:Npn \__stex_variables_invoke_math_ii:n  #1 {
  \cs_if_exist:cTF {
    stex_var_notation_#1_cs
  }{
    \tl_set:Nx \STEXInternalSymbolAfterInvokationTL {
      \_stex_reset:N \comp
      \_stex_reset:N \STEXInternalSymbolAfterInvokationTL
      \_stex_reset:N \STEXInternalCurrentSymbolStr
      \bool_set_true:N \l_stex_allow_semantic_bool
    }
    \def\comp{\_varcomp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { var://#1 }
    \bool_set_false:N \l_stex_allow_semantic_bool
    \use:c{stex_var_notation_#1_cs}
  }{
    \msg_error:nnxx{stex}{error/nonotation}{variable~#1}{s}
  }
}

\cs_new_protected:Nn \__stex_variables_invoke_custom:nn {
  \exp_args:Nnx \use:nn {
    \def\comp{\_varcomp}
    \str_set:Nn \STEXInternalCurrentSymbolStr { var://#1 }
    \prop_clear:N \l__stex_terms_custom_args_prop
    \prop_put:Nnn \l__stex_terms_custom_args_prop {currnum} {1}
    \prop_get:cnN {
      l_stex_symdecl_var://#1 _prop
    }{ args } \l_tmpa_str
    \prop_put:Nno \l__stex_terms_custom_args_prop {args} \l_tmpa_str
    \tl_set:Nn \arg { \__stex_terms_arg: }
    \str_if_empty:NTF \l_tmpa_str {
      \_stex_term_omv:nn {var://#1}{\ignorespaces#2}
    }{
      \str_if_in:NnTF \l_tmpa_str b {
        \_stex_term_ombind:nnn {var://#1}{}{\ignorespaces#2}
      }{
        \str_if_in:NnTF \l_tmpa_str B {
          \_stex_term_ombind:nnn {var://#1}{}{\ignorespaces#2}
        }{
          \_stex_term_oma:nnn {var://#1}{}{\ignorespaces#2}
        }
      }
    }
    % TODO check that all arguments exist
  }{
    \_stex_reset:N \STEXInternalCurrentSymbolStr
    \_stex_reset:N \arg
    \_stex_reset:N \comp
    \_stex_reset:N \l__stex_terms_custom_args_prop
    %\bool_set_true:N \l_stex_allow_semantic_bool
  }
}

\cs_new_protected:Nn \stex_invoke_sequence:n {
  \peek_charcode_remove:NTF ! {
    \_stex_term_omv:nn {varseq://#1}{
      \exp_args:Nnx \use:nn {
        \def\comp{\_varcomp}
        \str_set:Nn \STEXInternalCurrentSymbolStr {varseq://#1}
        \prop_item:cn{l_stex_symdecl_varseq://#1_prop}{notation}
      }{
        \_stex_reset:N \comp
        \_stex_reset:N \STEXInternalCurrentSymbolStr
      }
    }
  }{
    \bool_set_false:N \l_stex_allow_semantic_bool
    \def\comp{\_varcomp}
    \str_set:Nn \STEXInternalCurrentSymbolStr {varseq://#1}
    \tl_set:Nx \STEXInternalSymbolAfterInvokationTL {
      \_stex_reset:N \comp
      \_stex_reset:N \STEXInternalSymbolAfterInvokationTL
      \_stex_reset:N \STEXInternalCurrentSymbolStr
      \bool_set_true:N \l_stex_allow_semantic_bool
    }
    \use:c { stex_varseq_#1_cs }
  }
}



%%%%%%%%%%%%%   features.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/copymodule/notallowed}{
  Symbol~#1~can~not~be~assigned~in~copymodule~#2
}
\msg_new:nnn{stex}{error/interpretmodule/nodefiniens}{
  Symbol~#1~not~assigned~in~interpretmodule~#2
}

\msg_new:nnn{stex}{error/unknownstructure}{
  No~structure~#1~found!
}

\msg_new:nnn{stex}{error/unknownfield}{
  No~field~#1~in~instance~#2~found!\\#3
}

\msg_new:nnn{stex}{error/keyval}{
  Invalid~key=value~pair:#1
}
\msg_new:nnn{stex}{error/instantiate/missing}{
  Assignments~missing~in~instantiate:~#1
}
\msg_new:nnn{stex}{error/incompatible}{
  Incompatible~signature:~#1~(#2)~and~#3~(#4)
}

\cs_new_protected:Nn \stex_get_symbol_in_seq:nn {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \__stex_copymodule_get_symbol_from_cs:
  }{
    % argument is a string
    % is it a command name?
    \cs_if_exist:cTF { #1 }{
      \cs_set_eq:Nc \l_tmpa_tl { #1 }
      \str_set:Nx \l_tmpa_str { \cs_argument_spec:N \l_tmpa_tl }
      \str_if_empty:NTF \l_tmpa_str {
        \exp_args:Nx \cs_if_eq:NNTF {
          \tl_head:N \l_tmpa_tl
        } \stex_invoke_symbol:n {
          \__stex_copymodule_get_symbol_from_cs:n{ #2 }
        }{
          \__stex_copymodule_get_symbol_from_string:nn { #1 }{ #2 }
        }
      } {
        \__stex_copymodule_get_symbol_from_string:nn { #1 }{ #2 }
      }
    }{
      % argument is not a command name
      \__stex_copymodule_get_symbol_from_string:nn { #1 }{ #2 }
      % \l_stex_all_symbols_seq
    }
  }
}

\cs_new_protected:Nn \__stex_copymodule_get_symbol_from_string:nn {
  \str_set:Nn \l_tmpa_str { #1 }
  \bool_set_false:N \l_tmpa_bool
  \bool_if:NF \l_tmpa_bool {
    \tl_set:Nn \l_tmpa_tl {
      \msg_error:nnn{stex}{error/unknownsymbol}{#1}
    }
    \str_set:Nn \l_tmpa_str { #1 }
    \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
    \seq_map_inline:Nn #2 {
      \str_set:Nn \l_tmpb_str { ##1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
      } {
        \seq_map_break:n {
          \tl_set:Nn \l_tmpa_tl {
            \str_set:Nn \l_stex_get_symbol_uri_str {
              ##1
            }
          }
        }
      }
    }
    \l_tmpa_tl
  }
}

\cs_new_protected:Nn \__stex_copymodule_get_symbol_from_cs:n {
  \exp_args:NNx \tl_set:Nn \l_tmpa_tl
    { \tl_tail:N \l_tmpa_tl }
  \tl_if_single:NTF \l_tmpa_tl {
    \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
      \exp_after:wN \str_set:Nn \exp_after:wN
        \l_stex_get_symbol_uri_str \l_tmpa_tl
      \__stex_copymodule_get_symbol_check:n { #1 }
    }{
      % TODO
      % tail is not a single group
    }
  }{
    % TODO
    % tail is not a single group
  }
}

\cs_new_protected:Nn \__stex_copymodule_get_symbol_check:n {
  \exp_args:NNx \seq_if_in:NnF #1 \l_stex_get_symbol_uri_str {
    \msg_error:nnxx{stex}{error/copymodule/notallowed}{\l_stex_get_symbol_uri_str}{
      :~\seq_use:Nn #1 {,~}
    }
  }
}

\cs_new_protected:Nn \stex_copymodule_start:nnnn {
  % import module
  \stex_import_module_uri:nn { #1 } { #2 }
  \str_set:Nx \l_stex_current_copymodule_name_str {#3}
  \stex_import_require_module:nnnn
    { \l_stex_import_ns_str } { \l_stex_import_archive_str }
    { \l_stex_import_path_str } { \l_stex_import_name_str }

  \stex_collect_imports:n {\l_stex_import_ns_str ?\l_stex_import_name_str }
  \seq_set_eq:NN \l__stex_copymodule_copymodule_modules_seq \l_stex_collect_imports_seq

  % fields
  \seq_clear:N \l__stex_copymodule_copymodule_fields_seq
  \seq_map_inline:Nn \l__stex_copymodule_copymodule_modules_seq {
    \seq_map_inline:cn {c_stex_module_##1_constants}{
      \exp_args:NNx \seq_put_right:Nn \l__stex_copymodule_copymodule_fields_seq {
        ##1 ? ####1
      }
    }
  }

  % setup prop
  \seq_clear:N \l_tmpa_seq
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_copymodule_prop {
    name      = \l_stex_current_copymodule_name_str ,
    module    = \l_stex_current_module_str ,
    from      = \l_stex_import_ns_str ?\l_stex_import_name_str ,
    includes  = \l_tmpa_seq %,
  %  fields    = \l_tmpa_seq
  }
  \stex_debug:nn{copymodule}{#4~for~module~{\l_stex_import_ns_str ?\l_stex_import_name_str}
    as~\l_stex_current_module_str?\l_stex_current_copymodule_name_str}
    \stex_debug:nn{copymodule}{modules:\seq_use:Nn \l__stex_copymodule_copymodule_modules_seq {,~}}
  \stex_debug:nn{copymodule}{fields:\seq_use:Nn \l__stex_copymodule_copymodule_fields_seq {,~}}

  \stex_if_do_html:T {
    \begin{stex_annotate_env} {#4} {
      \l_stex_current_module_str?\l_stex_current_copymodule_name_str
    }
    \stex_annotate_invisible:nnn{domain}{\l_stex_import_ns_str ?\l_stex_import_name_str}{}
  }
}

\cs_new_protected:Nn \stex_copymodule_end:n {
  % apply to every field
  \def \l_tmpa_cs ##1 ##2 {#1}

  \tl_clear:N \__stex_copymodule_module_tl
  \tl_clear:N \__stex_copymodule_exec_tl

  %\prop_get:NnN \l_stex_current_copymodule_prop {fields} \l_tmpa_seq
  \seq_clear:N \__stex_copymodule_fields_seq

  \seq_map_inline:Nn \l__stex_copymodule_copymodule_modules_seq {
    \seq_map_inline:cn {c_stex_module_##1_constants}{

      \tl_clear:N \__stex_copymodule_curr_symbol_tl % <- wrap in current symbol html
      \l_tmpa_cs{##1}{####1}

      \str_if_exist:cTF {l__stex_copymodule_copymodule_##1?####1_name_str} {
        \str_set_eq:Nc \__stex_copymodule_curr_name_str {l__stex_copymodule_copymodule_##1?####1_name_str}
        \stex_if_do_html:T {
          \tl_put_right:Nx \__stex_copymodule_curr_symbol_tl {
            \stex_annotate_invisible:nnn{alias}{\use:c{l__stex_copymodule_copymodule_##1?####1_name_str}}{}
          }
        }
      }{
        \str_set:Nx \__stex_copymodule_curr_name_str { \l_stex_current_copymodule_name_str / ####1 }
      }

      \prop_set_eq:Nc \l_tmpa_prop {l_stex_symdecl_ ##1?####1 _prop}
      \prop_put:Nnx \l_tmpa_prop { name } \__stex_copymodule_curr_name_str
      \prop_put:Nnx \l_tmpa_prop { module } \l_stex_current_module_str

      \tl_if_exist:cT {l__stex_copymodule_copymodule_##1?####1_def_tl}{
        \stex_if_do_html:T {
          \tl_put_right:Nx \__stex_copymodule_curr_symbol_tl {
            $\stex_annotate_invisible:nnn{definiens}{}{\exp_after:wN \exp_not:N\csname l__stex_copymodule_copymodule_##1?####1_def_tl\endcsname}$
          }
        }
        \prop_put:Nnn \l_tmpa_prop { defined } { true }
      }

      \stex_add_constant_to_current_module:n \__stex_copymodule_curr_name_str
      \tl_put_right:Nx \__stex_copymodule_module_tl {
        \seq_clear:c {l_stex_symdecl_ \l_stex_current_module_str ? \__stex_copymodule_curr_name_str _notations}
        \prop_set_from_keyval:cn {
          l_stex_symdecl_\l_stex_current_module_str ? \__stex_copymodule_curr_name_str _prop
        }{
          \prop_to_keyval:N \l_tmpa_prop
        }
      }

      \str_if_exist:cT {l__stex_copymodule_copymodule_##1?####1_macroname_str} {
        \stex_if_do_html:T {
          \tl_put_right:Nx \__stex_copymodule_curr_symbol_tl {
            \stex_annotate_invisible:nnn{macroname}{\use:c{l__stex_copymodule_copymodule_##1?####1_macroname_str}}{}
          }
        }
        \tl_put_right:Nx \__stex_copymodule_module_tl {
          \tl_set:cx {\use:c{l__stex_copymodule_copymodule_##1?####1_macroname_str}}{
            \stex_invoke_symbol:n {
              \l_stex_current_module_str ? \__stex_copymodule_curr_name_str
            }
          }
        }
      }

      \seq_put_right:Nx \__stex_copymodule_fields_seq {\l_stex_current_module_str ? \__stex_copymodule_curr_name_str }

      \tl_put_right:Nx \__stex_copymodule_exec_tl {
        \stex_copy_notations:nn {\l_stex_current_module_str ? \__stex_copymodule_curr_name_str} { ##1 ? ####1 }
      }

      \tl_put_right:Nx \__stex_copymodule_exec_tl {
        \stex_if_do_html:TF{
          \stex_annotate_invisible:nnn{assignment} {##1?####1} { \exp_after:wN \exp_not:n \exp_after:wN {\__stex_copymodule_curr_symbol_tl} }
        }{
          \exp_after:wN \exp_not:n \exp_after:wN {\__stex_copymodule_curr_symbol_tl}
        }
      }
    }
  }

  \prop_put:Nno \l_stex_current_copymodule_prop {fields} \__stex_copymodule_fields_seq
  \tl_put_left:Nx \__stex_copymodule_module_tl {
    \prop_set_from_keyval:cn {
      l_stex_copymodule_ \l_stex_current_module_str?\l_stex_current_copymodule_name_str _prop
    }{
      \prop_to_keyval:N \l_stex_current_copymodule_prop
    }
  }

  \seq_gput_right:cx{c_stex_module_\l_stex_current_module_str _copymodules}{
    \l_stex_current_module_str?\l_stex_current_copymodule_name_str
  }

  \exp_args:No \stex_execute_in_module:n \__stex_copymodule_module_tl
  \stex_debug:nn{copymodule}{result:\meaning \__stex_copymodule_module_tl}
  \stex_debug:nn{copymodule}{output:\meaning \__stex_copymodule_exec_tl}

  \__stex_copymodule_exec_tl
  \stex_if_do_html:T {
    \end{stex_annotate_env}
  }
}

\NewDocumentEnvironment {copymodule} { O{} m m}{
  \stex_copymodule_start:nnnn { #1 }{ #2 }{ #3 }{ copymodule }
  \stex_deactivate_macro:Nn \symdecl {module~environments}
  \stex_deactivate_macro:Nn \symdef {module~environments}
  \stex_deactivate_macro:Nn \notation {module~environments}
  \stex_reactivate_macro:N \assign
  \stex_reactivate_macro:N \renamedecl
  \stex_reactivate_macro:N \donotcopy
  \stex_smsmode_do:
}{
  \stex_copymodule_end:n {}
}

\NewDocumentEnvironment {interpretmodule} { O{} m m}{
  \stex_copymodule_start:nnnn { #1 }{ #2 }{ #3 }{ interpretmodule }
  \stex_deactivate_macro:Nn \symdecl {module~environments}
  \stex_deactivate_macro:Nn \symdef {module~environments}
  \stex_deactivate_macro:Nn \notation {module~environments}
  \stex_reactivate_macro:N \assign
  \stex_reactivate_macro:N \renamedecl
  \stex_reactivate_macro:N \donotcopy
  \stex_smsmode_do:
}{
  \stex_copymodule_end:n {
    \tl_if_exist:cF {
      l__stex_copymodule_copymodule_##1?##2_def_tl
    }{
      \str_if_eq:eeF {
        \prop_item:cn{
          l_stex_symdecl_ ##1 ? ##2 _prop }{ defined }
      }{ true }{
        \msg_error:nnxx{stex}{error/interpretmodule/nodefiniens}{
          ##1?##2
        }{\l_stex_current_copymodule_name_str}
      }
    }
  }
}

\iffalse \begin{stex_annotate_env} \fi
\NewDocumentEnvironment {realization} { O{} m}{
  \stex_copymodule_start:nnnn { #1 }{ #2 }{ #2 }{ realize }
  \stex_deactivate_macro:Nn \symdecl {module~environments}
  \stex_deactivate_macro:Nn \symdef {module~environments}
  \stex_deactivate_macro:Nn \notation {module~environments}
  \stex_reactivate_macro:N \donotcopy
  \stex_reactivate_macro:N \assign
  \stex_smsmode_do:
}{
  \stex_import_module_uri:nn { #1 } { #2 }
  \tl_clear:N \__stex_copymodule_exec_tl
  \tl_set:Nx \__stex_copymodule_module_tl {
    \stex_import_require_module:nnnn
      { \l_stex_import_ns_str } { \l_stex_import_archive_str }
      { \l_stex_import_path_str } { \l_stex_import_name_str }
  }
  \exp_args:Nx \stex_add_import_to_current_module:n{
    \l_stex_import_ns_str ? \l_stex_import_name_str
  }

  \seq_map_inline:Nn \l__stex_copymodule_copymodule_modules_seq {
    \seq_map_inline:cn {c_stex_module_##1_constants}{
      \str_set:Nx \__stex_copymodule_curr_name_str { \l_stex_current_copymodule_name_str / ####1 }
      \tl_if_exist:cT {l__stex_copymodule_copymodule_##1?####1_def_tl}{
        \stex_if_do_html:T {
          \tl_put_right:Nx \__stex_copymodule_exec_tl {
            \stex_annotate_invisible:nnn{assignment} {##1?####1} {
              $\stex_annotate_invisible:nnn{definiens}{}{\exp_after:wN \exp_not:N\csname l__stex_copymodule_copymodule_##1?####1_def_tl\endcsname}$
             }
          }
        }
        \tl_put_right:Nx \__stex_copymodule_module_tl {
          \prop_put:cnn {l_stex_symdecl_##1?####1_prop}{ defined }{ true }
        }
      }
  }}

  \exp_args:No \stex_execute_in_module:n \__stex_copymodule_module_tl

  \__stex_copymodule_exec_tl
  \stex_if_do_html:T {\end{stex_annotate_env}}
}

\NewDocumentCommand \donotcopy { m }{
  \str_clear:N \l_stex_import_name_str
  \str_set:Nn \l_tmpa_str { #1 }
  \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
  \seq_map_inline:Nn \l_stex_all_modules_seq {
    \str_set:Nn \l_tmpb_str { ##1 }
    \str_if_eq:eeT { \l_tmpa_str } {
      \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
    } {
      \seq_map_break:n {
        \stex_if_do_html:T {
          \stex_if_smsmode:F {
            \stex_annotate_invisible:nnn{donotcopy}{##1}{
              \stex_annotate:nnn{domain}{##1}{}
            }
          }
        }
        \str_set_eq:NN \l_stex_import_name_str \l_tmpb_str
      }
    }
    \seq_map_inline:cn {c_stex_module_##1_copymodules}{
      \str_set:Nn \l_tmpb_str { ####1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
      } {
        \seq_map_break:n {\seq_map_break:n {
          \stex_if_do_html:T {
            \stex_if_smsmode:F {
              \stex_annotate_invisible:nnn{donotcopy}{####1}{
                \stex_annotate:nnn{domain}{
                  \prop_item:cn {l_stex_copymodule_ ####1 _prop}{module}
                }{}
              }
            }
          }
          \str_set:Nx \l_stex_import_name_str {
            \prop_item:cn {l_stex_copymodule_ ####1 _prop}{module}
          }
        }}
      }
    }
  }
  \str_if_empty:NTF \l_stex_import_name_str {
    % TODO throw error
  }{
    \stex_collect_imports:n {\l_stex_import_name_str }
    \seq_map_inline:Nn \l_stex_collect_imports_seq {
      \seq_remove_all:Nn \l__stex_copymodule_copymodule_modules_seq { ##1 }
      \seq_map_inline:cn {c_stex_module_##1_constants}{
        \seq_remove_all:Nn \l__stex_copymodule_copymodule_fields_seq { ##1 ? ####1 }
        \bool_lazy_any:nT {
          { \cs_if_exist_p:c {l__stex_copymodule_copymodule_##1?####1_name_str}}
          { \cs_if_exist_p:c {l__stex_copymodule_copymodule_##1?####1_macroname_str}}
          { \cs_if_exist_p:c {l__stex_copymodule_copymodule_##1?####1_def_tl}}
        }{
          % TODO throw error
        }
      }
    }
    \prop_get:NnN \l_stex_current_copymodule_prop { includes } \l_tmpa_seq
    \seq_put_right:Nx \l_tmpa_seq {\l_stex_import_name_str }
    \prop_put:Nno \l_stex_current_copymodule_prop {includes} \l_tmpa_seq
  }
  \stex_smsmode_do:
}

\NewDocumentCommand \assign { m m }{
  \stex_get_symbol_in_seq:nn {#1} \l__stex_copymodule_copymodule_fields_seq
  \stex_debug:nn{assign}{defining~{\l_stex_get_symbol_uri_str}~as~\detokenize{#2}}
  \tl_set:cn {l__stex_copymodule_copymodule_\l_stex_get_symbol_uri_str _def_tl}{#2}
  \stex_smsmode_do:
}

\keys_define:nn { stex / renamedecl } {
  name        .str_set_x:N  = \l_stex_renamedecl_name_str
}
\cs_new_protected:Nn \__stex_copymodule_renamedecl_args:n {
  \str_clear:N \l_stex_renamedecl_name_str
  \keys_set:nn { stex / renamedecl } { #1 }
}

\NewDocumentCommand \renamedecl { O{} m m}{
  \__stex_copymodule_renamedecl_args:n { #1 }
  \stex_get_symbol_in_seq:nn {#2} \l__stex_copymodule_copymodule_fields_seq
  \stex_debug:nn{renamedecl}{renaming~{\l_stex_get_symbol_uri_str}~to~#3}
  \str_set:cx {l__stex_copymodule_copymodule_\l_stex_get_symbol_uri_str _macroname_str}{#3}
  \str_if_empty:NTF \l_stex_renamedecl_name_str {
    \tl_set:cx { #3 }{ \stex_invoke_symbol:n {
      \l_stex_get_symbol_uri_str
    } }
  } {
    \str_set:cx {l__stex_copymodule_copymodule_\l_stex_get_symbol_uri_str _name_str}{\l_stex_renamedecl_name_str}
    \stex_debug:nn{renamedecl}{@~\l_stex_current_module_str ? \l_stex_renamedecl_name_str}
    \prop_set_eq:cc {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}
    \seq_set_eq:cc {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _notations
    }{l_stex_symdecl_ \l_stex_get_symbol_uri_str _notations}
    \prop_put:cnx {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{ name }{ \l_stex_renamedecl_name_str }
    \prop_put:cnx {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{ module }{ \l_stex_current_module_str }
    \exp_args:NNx \seq_put_left:Nn \l__stex_copymodule_copymodule_fields_seq {
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
    }
    \tl_set:cx { #3 }{ \stex_invoke_symbol:n {
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
    } }
  }
  \stex_smsmode_do:
}

\stex_deactivate_macro:Nn \assign {copymodules}
\stex_deactivate_macro:Nn \renamedecl {copymodules}
\stex_deactivate_macro:Nn \donotcopy {copymodules}


\NewDocumentEnvironment{structural_feature_module}{ m m m }{
  \stex_if_in_module:F {
    \msg_set:nnn{stex}{error/nomodule}{
      Structural~Feature~has~to~occur~in~a~module:\\
      Feature~#2~of~type~#1\\
      In~File:~\stex_path_to_string:N \g_stex_currentfile_seq
    }
    \msg_error:nn{stex}{error/nomodule}
  }

  \str_set_eq:NN \l_stex_feature_parent_str \l_stex_current_module_str

  \stex_module_setup:nn{meta=NONE}{#2 - #1}

  \stex_if_do_html:T {
    \begin{stex_annotate_env}{ feature:#1 }{\l_stex_feature_parent_str ? #2 - #1}
      \stex_annotate_invisible:nnn{header}{}{ #3 }
  }
}{
  \str_gset_eq:NN \l_stex_last_feature_str \l_stex_current_module_str
  \prop_gput:cnn {c_stex_module_ \l_stex_current_module_str _prop}{feature}{#1}
  \stex_debug:nn{features}{
    Feature: \l_stex_last_feature_str
  }
  \stex_if_do_html:T {
    \end{stex_annotate_env}
  }
}
\cs_new_protected:Nn \stex_add_structure_to_current_module:nn {
  \prop_if_exist:cF {c_stex_module_\l_stex_current_module_str _structures}{
    \prop_new:c {c_stex_module_\l_stex_current_module_str _structures}
  }
  \prop_gput:cxx{c_stex_module_\l_stex_current_module_str _structures}
    {#1}{#2}
}

\keys_define:nn { stex / features / structure } {
  name         .str_set_x:N  = \l__stex_structures_name_str ,
}

\cs_new_protected:Nn \__stex_structures_structure_args:n {
  \str_clear:N \l__stex_structures_name_str
  \keys_set:nn { stex / features / structure } { #1 }
}
\NewDocumentEnvironment{mathstructure}{m O{}}{
  \begin{mathstructure_inner}{#1}[#2]
    \stex_smsmode_do:
    \ignorespacesandpars
  }{\end{mathstructure_inner}}
\NewDocumentEnvironment{mathstructure_inner}{m O{}}{
  \__stex_structures_structure_args:n { #2 }
  \str_if_empty:NT \l__stex_structures_name_str {
    \str_set:Nx \l__stex_structures_name_str { #1 }
  }
  \stex_suppress_html:n {
    \bool_set_true:N \l_stex_symdecl_make_macro_bool
    \exp_args:Nx \stex_symdecl_do:nn {
      name = \l__stex_structures_name_str ,
      def  = {\STEXsymbol{module-type}{
        \STEXInternalTermMathOMSiiii {
          \prop_item:cn {c_stex_module_\l_stex_current_module_str _prop}
            { ns } ?
            \prop_item:cn {c_stex_module_\l_stex_current_module_str _prop}
              { name } / \l__stex_structures_name_str - structure
         }{}{0}{}
      }}
    }{ #1 }
  }
  \exp_args:Nnnx
  \begin{structural_feature_module}{ structure }
    { \l__stex_structures_name_str }{}
}{
  \end{structural_feature_module}
  \_stex_reset_up_to_module:n \l_stex_last_feature_str
  \exp_args:No \stex_collect_imports:n \l_stex_last_feature_str
  \seq_clear:N \l_tmpa_seq
  \seq_map_inline:Nn \l_stex_collect_imports_seq {
    \seq_map_inline:cn{c_stex_module_##1_constants}{
      \seq_put_right:Nn \l_tmpa_seq { ##1 ? ####1 }
    }
  }
  \exp_args:Nnno
  \prop_gput:cnn {c_stex_module_ \l_stex_last_feature_str _prop}{fields}\l_tmpa_seq
  \stex_debug:nn{structure}{Fields:~\seq_use:Nn \l_tmpa_seq ,}
  \stex_add_structure_to_current_module:nn
    \l__stex_structures_name_str
    \l_stex_last_feature_str

  \stex_execute_in_module:x {
    \tl_set:cn { #1 }{
      \exp_not:N \stex_invoke_structure:nn {\l_stex_current_module_str }{ \l__stex_structures_name_str}
    }
  }
}

\cs_new:Nn \stex_invoke_structure:nn {
  \stex_invoke_symbol:n { #1?#2 }
}

\cs_new_protected:Nn \stex_get_structure:n {
  \stex_debug:nn{getstructure}{Looking~for~structure~#1}
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \tl_set:Nn \l_tmpa_tl { #1 }
    \__stex_structures_get_from_cs:
  }{
    \cs_if_exist:cTF { #1 }{
      \stex_debug:nn{getstructure}{cs~exists}
      \cs_set_eq:Nc \l_tmpa_cs { #1 }
      \str_set:Nx \l_tmpa_str {\cs_argument_spec:N \l_tmpa_cs }
      \stex_debug:nn{getstructure}{arguments: \l_tmpa_str}
      \str_if_empty:NTF \l_tmpa_str {
        \exp_args:Nx \cs_if_eq:NNTF { \tl_head:N \l_tmpa_cs} \stex_invoke_structure:nn {
          \stex_debug:nn{getstructure}{head~is~invoke_structure}
          \tl_set_eq:NN \l_tmpa_tl \l_tmpa_cs
          \__stex_structures_get_from_cs:
        }{
          \stex_debug:nn{getstructure}{head~is~not~invoke_structure: \meaning\l_tmpa_cs}
          \__stex_structures_get_from_string:n { #1 }
        }
      }{
        \stex_debug:nn{getstructure}{not~empty}
        \__stex_structures_get_from_string:n { #1 }
      }
    }{
      \stex_debug:nn{getstructure}{cs~does~not~exist}
      \__stex_structures_get_from_string:n { #1 }
    }
  }
}

\cs_new_protected:Nn \__stex_structures_get_from_cs: {
  \stex_debug:nn{getstructure}{From~cs?}
  \exp_args:NNx \tl_set:Nn \l_tmpa_tl
    { \tl_tail:N \l_tmpa_tl }
  \str_set:Nx \l_tmpa_str {
    \exp_after:wN \use_i:nn \l_tmpa_tl
  }
  \str_set:Nx \l_tmpb_str {
    \exp_after:wN \use_ii:nn \l_tmpa_tl
  }
  \str_set:Nx \l_stex_get_structure_str {
    \l_tmpa_str ? \l_tmpb_str
  }
  \str_set:Nx \l_stex_get_structure_module_str {
    \exp_args:Nno \prop_item:cn {c_stex_module_\l_tmpa_str _structures}{\l_tmpb_str}
  }
}

\cs_new_protected:Nn \__stex_structures_get_from_string:n {
  \stex_debug:nn{getstructure}{From~string?}
  \tl_set:Nn \l_tmpa_tl {
    \msg_error:nnn{stex}{error/unknownstructure}{#1}
  }
  \str_set:Nn \l_tmpa_str { #1 }
  \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }

  \seq_map_inline:Nn \l_stex_all_modules_seq {
    \prop_if_exist:cT {c_stex_module_##1_structures} {
      \prop_map_inline:cn {c_stex_module_##1_structures} {
        \exp_args:No \str_if_eq:nnT \l_tmpa_str {####1}{
        %\str_if_eq:eeT { \l_tmpa_str }{ \str_range:nnn {##1?####1}{-\l_tmpa_int}{-1}}{
          \prop_map_break:n{\seq_map_break:n{
            \tl_set:Nn \l_tmpa_tl {
              \str_set:Nn \l_stex_get_structure_str {##1?####1}
              \str_set:Nn \l_stex_get_structure_module_str {####2}
            }
          }}
        }
      }
    }
  }
  \l_tmpa_tl
}

\NewDocumentCommand{\usestructure}{m}{
  \stex_if_smsmode:F {
    \stex_get_structure:n {#1}
    \exp_args:Nnx \stex_debug:nn{features}{using~structure:~\l_stex_get_structure_module_str}
    \exp_args:No \stex_activate_module:n \l_stex_get_structure_module_str
    \stex_annotate_invisible:nnn
      {usemodule} {\l_stex_get_structure_module_str} {}
  }
}

\keys_define:nn { stex / instantiate } {
  name        .str_set_x:N  = \l__stex_structures_name_str
}
\cs_new_protected:Nn \__stex_structures_instantiate_args:n {
  \str_clear:N \l__stex_structures_name_str
  \keys_set:nn { stex / instantiate } { #1 }
}

\NewDocumentEnvironment{extstructure}{m m O{}}{
  \begin{mathstructure_inner}{#1}[#3]
    \seq_set_split:Nnn\__stex_structures_extstructure_imports_seq,{#2}
    \seq_map_inline:Nn\__stex_structures_extstructure_imports_seq {
      \stex_get_structure:n {##1}
      \exp_args:Nnx \stex_debug:nn{features}{importing~structure:~\l_stex_get_structure_module_str{}~into~\l_stex_current_module_str}
      \exp_args:No \stex_activate_module:n \l_stex_get_structure_module_str
      \stex_if_smsmode:F {
        \stex_annotate_invisible:nnn
          {import} {\l_stex_get_structure_module_str} {}
      }
      \exp_args:Nx \stex_add_import_to_current_module:n {
        \l_stex_get_structure_module_str
      }
      \exp_args:Nx \stex_add_to_current_module:n {
        \exp_args:No \stex_activate_module:n \l_stex_get_structure_module_str
      }
    }
    \stex_smsmode_do:
    \ignorespacesandpars
}{
  \end{mathstructure_inner}
}

\NewDocumentEnvironment{extstructure*}{m m O{}}{
  % TODO
  \begin{extstructure}{#1}{#2}[#3]
}{
  \end{extstructure}
}

\NewDocumentCommand \instantiate {m O{} m m O{}}{
  \begingroup
    \stex_get_structure:n {#3}
    \__stex_structures_instantiate_args:n { #2 }
    \str_if_empty:NT \l__stex_structures_name_str {
      \str_set:Nn \l__stex_structures_name_str { #1 }
    }
    \exp_args:No \stex_activate_module:n \l_stex_get_structure_module_str
    \seq_clear:N \l__stex_structures_fields_seq
    \exp_args:Nx \stex_collect_imports:n \l_stex_get_structure_module_str
    \seq_map_inline:Nn \l_stex_collect_imports_seq {
      \seq_map_inline:cn {c_stex_module_##1_constants}{
        \seq_put_right:Nx \l__stex_structures_fields_seq { ##1 ? ####1 }
      }
    }

    \tl_if_empty:nF{#5}{
      \seq_set_split:Nnn \l_tmpa_seq , {#5}
      \prop_clear:N \l_tmpa_prop
      \seq_map_inline:Nn \l_tmpa_seq {
        \seq_set_split:Nnn \l_tmpb_seq = { ##1 }
        \int_compare:nNnF { \seq_count:N \l_tmpb_seq } = 2 {
          \msg_error:nnn{stex}{error/keyval}{##1}
        }
        \exp_args:Nx \stex_get_symbol_in_seq:nn {\seq_item:Nn \l_tmpb_seq 1} \l__stex_structures_fields_seq
        \str_set_eq:NN \l__stex_structures_dom_str \l_stex_get_symbol_uri_str
        \exp_args:NNx \seq_remove_all:Nn \l__stex_structures_fields_seq \l_stex_get_symbol_uri_str
        \exp_args:Nx \stex_get_symbol:n {\seq_item:Nn \l_tmpb_seq 2}
        \exp_args:Nxx \str_if_eq:nnF
          {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
          {\prop_item:cn{l_stex_symdecl_\l_stex_get_symbol_uri_str _prop}{args}}{
          \msg_error:nnxxxx{stex}{error/incompatible}
            {\l__stex_structures_dom_str}
            {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
            {\l_stex_get_symbol_uri_str}
            {\prop_item:cn{l_stex_symdecl_\l_stex_get_symbol_uri_str _prop}{args}}
        }
        \prop_put:Nxx \l_tmpa_prop {\seq_item:Nn \l_tmpb_seq 1} \l_stex_get_symbol_uri_str
      }
    }

    \seq_map_inline:Nn \l__stex_structures_fields_seq {
      \str_set:Nx \l_tmpa_str {field:\l__stex_structures_name_str . \prop_item:cn {l_stex_symdecl_##1_prop}{name} }
      \stex_debug:nn{instantiate}{Field~\l_tmpa_str :~##1}

      \stex_add_constant_to_current_module:n {\l_tmpa_str}
      \stex_execute_in_module:x {
        \prop_set_from_keyval:cn { l_stex_symdecl_ \l_stex_current_module_str?\l_tmpa_str _prop}{
          name   = \l_tmpa_str ,
          args   = \prop_item:cn {l_stex_symdecl_##1_prop}{args} ,
          arity  = \prop_item:cn {l_stex_symdecl_##1_prop}{arity} ,
          assocs = \prop_item:cn {l_stex_symdecl_##1_prop}{assocs} ,
          argnames = {\prop_item:cn {l_stex_symdecl_##1_prop}{argnames}}
        }
        \seq_clear:c {l_stex_symdecl_\l_stex_current_module_str?\l_tmpa_str _notations}
      }

      \seq_if_empty:cF{l_stex_symdecl_##1_notations}{
        \stex_find_notation:nn{##1}{}
        \stex_execute_in_module:x {
          \seq_put_right:cn {l_stex_symdecl_\l_stex_current_module_str?\l_tmpa_str _notations}{\l_stex_notation_variant_str}
        }

        \stex_copy_control_sequence_ii:ccN
          {stex_notation_\l_stex_current_module_str?\l_tmpa_str\c_hash_str \l_stex_notation_variant_str _cs}
          {stex_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}
          \l_tmpa_tl
        \exp_args:No \stex_execute_in_module:n \l_tmpa_tl

        \cs_if_exist:cT{stex_op_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}{
          \tl_set_eq:Nc \l_tmpa_cs {stex_op_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}
          \stex_execute_in_module:x {
            \tl_set:cn
            {stex_op_notation_\l_stex_current_module_str?\l_tmpa_str\c_hash_str \l_stex_notation_variant_str _cs}
            { \exp_args:No \exp_not:n \l_tmpa_cs}
          }
        }

      }

      \prop_put:Nxx \l_tmpa_prop {\prop_item:cn {l_stex_symdecl_##1_prop}{name}}{\l_stex_current_module_str?\l_tmpa_str}
    }

    \stex_execute_in_module:x {
      \prop_set_from_keyval:cn {l_stex_instance_\l_stex_current_module_str?\l__stex_structures_name_str _prop}{
        domain = \l_stex_get_structure_module_str ,
        \prop_to_keyval:N \l_tmpa_prop
      }
      \tl_set:cn{ #1 }{\stex_invoke_instance:n{ \l_stex_current_module_str?\l__stex_structures_name_str} }
    }
    \stex_debug:nn{instantiate}{
      Instance~\l_stex_current_module_str?\l__stex_structures_name_str \\
      \prop_to_keyval:N \l_tmpa_prop
    }
    \exp_args:Nxx \stex_symdecl_do:nn {
      type={\STEXsymbol{module-type}{
        \STEXInternalTermMathOMSiiii {
          \l_stex_get_structure_module_str
        }{}{0}{}
      }}
    }{\l__stex_structures_name_str}
      \str_set:Nx \l_stex_get_symbol_uri_str {\l_stex_current_module_str?\l__stex_structures_name_str}
      \tl_set:Nn \l_stex_notation_after_do_tl {\__stex_notation_final:}
      \stex_notation_do:nnnnn{}{0}{}{}{\comp{#4}}
 %   }
    %\exp_args:Nx \notation{\l__stex_structures_name_str}{\comp{#5}}
  \endgroup
  \stex_smsmode_do:\ignorespacesandpars
}

\cs_new_protected:Nn \stex_symbol_or_var:n {
  \cs_if_exist:cTF{#1}{
    \cs_set_eq:Nc \l_tmpa_tl { #1 }
    \str_set:Nx \l_tmpa_str { \cs_argument_spec:N \l_tmpa_tl }
    \str_if_empty:NTF \l_tmpa_str {
      \exp_args:Nx \cs_if_eq:NNTF { \tl_head:N \l_tmpa_tl }
        \stex_invoke_variable:n {
          \bool_set_true:N \l_stex_symbol_or_var_bool
          \bool_set_false:N \l_stex_instance_or_symbol_bool
          \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
          \tl_set:Nx \l_tmpa_tl {\exp_after:wN \use:n \l_tmpa_tl}
          \str_set:Nx \l_stex_get_symbol_uri_str {
            \exp_after:wN \use:n \l_tmpa_tl
          }
        }{ % TODO \stex_invoke_varinstance:n
          \exp_args:Nx \cs_if_eq:NNTF { \tl_head:N \l_tmpa_tl } \stex_invoke_varinstance:n {
            \bool_set_true:N \l_stex_symbol_or_var_bool
            \bool_set_true:N \l_stex_instance_or_symbol_bool
            \tl_set:Nx \l_tmpa_tl {\tl_tail:N \l_tmpa_tl}
            \tl_set:Nx \l_tmpa_tl {\exp_after:wN \use:n \l_tmpa_tl}
            \str_set:Nx \l_stex_get_symbol_uri_str {
              \exp_after:wN \use:n \l_tmpa_tl
            }
          }{
            \bool_set_false:N \l_stex_symbol_or_var_bool
            \stex_get_symbol:n{#1}
          }
        }
    }{
      \__stex_structures_symbolorvar_from_string:n{ #1 }
    }
  }{
    \__stex_structures_symbolorvar_from_string:n{ #1 }
  }
}

\cs_new_protected:Nn \__stex_structures_symbolorvar_from_string:n {
  \prop_if_exist:cTF {l_stex_symdecl_var://#1 _prop}{
    \bool_set_true:N \l_stex_symbol_or_var_bool
    \str_set:Nn \l_stex_get_symbol_uri_str { #1 }
  }{
    \bool_set_false:N \l_stex_symbol_or_var_bool
    \stex_get_symbol:n{#1}
  }
}

\keys_define:nn { stex / varinstantiate } {
  name        .str_set_x:N  = \l__stex_structures_name_str,
  bind        .choices:nn   =
      {forall,exists}
      {\str_set:Nx \l__stex_structures_bind_str {\l_keys_choice_tl}}

}
\cs_new_protected:Nn \__stex_structures_varinstantiate_args:n {
  \str_clear:N \l__stex_structures_name_str
  \str_clear:N \l__stex_structures_bind_str
  \keys_set:nn { stex / varinstantiate } { #1 }
}

\NewDocumentCommand \varinstantiate {m O{} m m O{}}{
  \begingroup
    \stex_get_structure:n {#3}
    \__stex_structures_varinstantiate_args:n { #2 }
    \str_if_empty:NT \l__stex_structures_name_str {
      \str_set:Nn \l__stex_structures_name_str { #1 }
    }
    \stex_if_do_html:TF{
      \stex_annotate:nnn{varinstance}{\l__stex_structures_name_str}
    }{\use:n}
    {
      \stex_if_do_html:T{
        \stex_annotate_invisible:nnn{domain}{\l_stex_get_structure_module_str}{}
      }
      \seq_clear:N \l__stex_structures_fields_seq
      \exp_args:Nx \stex_collect_imports:n \l_stex_get_structure_module_str
      \seq_map_inline:Nn \l_stex_collect_imports_seq {
        \seq_map_inline:cn {c_stex_module_##1_constants}{
          \seq_put_right:Nx \l__stex_structures_fields_seq { ##1 ? ####1 }
        }
      }
      \exp_args:No \stex_activate_module:n \l_stex_get_structure_module_str
      \prop_clear:N \l_tmpa_prop
      \tl_if_empty:nF {#5} {
        \seq_set_split:Nnn \l_tmpa_seq , {#5}
        \seq_map_inline:Nn \l_tmpa_seq {
          \seq_set_split:Nnn \l_tmpb_seq = { ##1 }
          \int_compare:nNnF { \seq_count:N \l_tmpb_seq } = 2 {
            \msg_error:nnn{stex}{error/keyval}{##1}
          }
          \exp_args:Nx \stex_get_symbol_in_seq:nn {\seq_item:Nn \l_tmpb_seq 1} \l__stex_structures_fields_seq
          \str_set_eq:NN \l__stex_structures_dom_str \l_stex_get_symbol_uri_str
          \exp_args:NNx \seq_remove_all:Nn \l__stex_structures_fields_seq \l_stex_get_symbol_uri_str
          \exp_args:Nx \stex_symbol_or_var:n {\seq_item:Nn \l_tmpb_seq 2}
          \stex_if_do_html:T{
            \stex_annotate:nnn{assign}{\l__stex_structures_dom_str,
            \bool_if:NTF\l_stex_symbol_or_var_bool{var://}{}\l_stex_get_symbol_uri_str}{}
          }
          \bool_if:NTF \l_stex_symbol_or_var_bool {
            \exp_args:Nxx \str_if_eq:nnF
              {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
              {\prop_item:cn{l_stex_symdecl_var://\l_stex_get_symbol_uri_str _prop}{args}}{
              \msg_error:nnxxxx{stex}{error/incompatible}
                {\l__stex_structures_dom_str}
                {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
                {\l_stex_get_symbol_uri_str}
                {\prop_item:cn{l_stex_symdecl_var://\l_stex_get_symbol_uri_str _prop}{args}}
            }
            \prop_put:Nxx \l_tmpa_prop {\seq_item:Nn \l_tmpb_seq 1} {\stex_invoke_variable:n {\l_stex_get_symbol_uri_str}}
          }{
            \exp_args:Nxx \str_if_eq:nnF
              {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
              {\prop_item:cn{l_stex_symdecl_\l_stex_get_symbol_uri_str _prop}{args}}{
              \msg_error:nnxxxx{stex}{error/incompatible}
                {\l__stex_structures_dom_str}
                {\prop_item:cn{l_stex_symdecl_\l__stex_structures_dom_str _prop}{args}}
                {\l_stex_get_symbol_uri_str}
                {\prop_item:cn{l_stex_symdecl_\l_stex_get_symbol_uri_str _prop}{args}}
            }
            \prop_put:Nxx \l_tmpa_prop {\seq_item:Nn \l_tmpb_seq 1} {\stex_invoke_symbol:n {\l_stex_get_symbol_uri_str}}
          }
        }
      }
      \tl_gclear:N \g__stex_structures_aftergroup_tl
      \seq_map_inline:Nn \l__stex_structures_fields_seq {
        \str_set:Nx \l_tmpa_str {\l__stex_structures_name_str . \prop_item:cn {l_stex_symdecl_##1_prop}{name} }
        \stex_debug:nn{varinstantiate}{Field~\l_tmpa_str :~##1}
        \seq_if_empty:cF{l_stex_symdecl_##1_notations}{
          \stex_find_notation:nn{##1}{}
          \cs_gset_eq:cc{g__stex_structures_tmpa_\l_tmpa_str _cs}
            {stex_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}
          \stex_debug:nn{varinstantiate}{Notation:~\cs_meaning:c{g__stex_structures_tmpa_\l_tmpa_str _cs}}
          \cs_if_exist:cT{stex_op_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}{
            \cs_gset_eq:cc {g__stex_structures_tmpa_op_\l_tmpa_str _cs}
              {stex_op_notation_##1\c_hash_str \l_stex_notation_variant_str _cs}
              \stex_debug:nn{varinstantiate}{Operator~Notation:~\cs_meaning:c{g__stex_structures_tmpa_op_\l_tmpa_str _cs}}
          }
        }

        \exp_args:NNx \tl_gput_right:Nn \g__stex_structures_aftergroup_tl {
          \prop_set_from_keyval:cn { l_stex_symdecl_ var://\l_tmpa_str _prop}{
            name   = \l_tmpa_str ,
            args   = \prop_item:cn {l_stex_symdecl_##1_prop}{args} ,
            arity  = \prop_item:cn {l_stex_symdecl_##1_prop}{arity} ,
            assocs = \prop_item:cn {l_stex_symdecl_##1_prop}{assocs} ,
            argnames = {\prop_item:cn {l_stex_symdecl_##1_prop}{argnames}} ,
          }
          \cs_set_eq:cc {stex_var_notation_\l_tmpa_str _cs}
            {g__stex_structures_tmpa_\l_tmpa_str _cs}
          \cs_set_eq:cc {stex_var_op_notation_\l_tmpa_str _cs}
            {g__stex_structures_tmpa_op_\l_tmpa_str _cs}
        }
        \prop_put:Nxx \l_tmpa_prop {\prop_item:cn {l_stex_symdecl_##1_prop}{name}}{\stex_invoke_variable:n {\l_tmpa_str}}
      }
      \exp_args:NNx \tl_gput_right:Nn \g__stex_structures_aftergroup_tl {
        \prop_set_from_keyval:cn {l_stex_varinstance_\l__stex_structures_name_str _prop }{
          domain = \l_stex_get_structure_module_str ,
          \prop_to_keyval:N \l_tmpa_prop
        }
        \tl_set:cn { #1 }{\stex_invoke_varinstance:n {\l__stex_structures_name_str}}
        \tl_set:cn {l_stex_varinstance_\l__stex_structures_name_str _op_tl}{
          \exp_args:Nnx \exp_not:N \use:nn {
            \str_set:Nn \exp_not:N \STEXInternalCurrentSymbolStr {var://\l__stex_structures_name_str}
            \_stex_term_omv:nn {var://\l__stex_structures_name_str}{
              \exp_not:n{
                \_varcomp{#4}
              }
            }
          }{
            \exp_not:n{\_stex_reset:N \STEXInternalCurrentSymbolStr}
          }
        }
      }
    }
    \stex_debug:nn{varinstantiate}{\expandafter\detokenize\expandafter{\g__stex_structures_aftergroup_tl}}
    \aftergroup\g__stex_structures_aftergroup_tl
  \endgroup
  \stex_smsmode_do:\ignorespacesandpars
}

\cs_new_protected:Nn \stex_invoke_instance:n {
  \peek_charcode_remove:NTF ! {
    \stex_invoke_symbol:n{#1}
  }{
    \_stex_invoke_instance:nn {#1}
  }
}

\cs_new_protected:Nn \stex_invoke_varinstance:n {
  \peek_charcode_remove:NTF ! {
    \exp_args:Nnx \use:nn {
      \def\comp{\_varcomp}
      \use:c{l_stex_varinstance_#1_op_tl}
    }{
      \_stex_reset:N \comp
    }
  }{
    \_stex_invoke_varinstance:nn {#1}
  }
}

\cs_new_protected:Nn \_stex_invoke_instance:nn {
  \prop_if_in:cnTF {l_stex_instance_ #1 _prop}{#2}{
    \exp_args:Nx \stex_invoke_symbol:n {\prop_item:cn{l_stex_instance_ #1 _prop}{#2}}
  }{
    \prop_set_eq:Nc \l_tmpa_prop{l_stex_instance_ #1 _prop}
    \msg_error:nnxxx{stex}{error/unknownfield}{#2}{#1}{
      \prop_to_keyval:N \l_tmpa_prop
    }
  }
}

\cs_new_protected:Nn \_stex_invoke_varinstance:nn {
  \prop_if_in:cnTF {l_stex_varinstance_ #1 _prop}{#2}{
    \prop_get:cnN{l_stex_varinstance_ #1 _prop}{#2}\l_tmpa_tl
    \l_tmpa_tl
  }{
    \msg_error:nnnnn{stex}{error/unknownfield}{#2}{#1}{}
  }
}
\cs_new_protected:Nn \stex_invoke_structure:nnn {
  \tl_if_empty:nTF{ #3 }{
    \prop_set_eq:Nc \l__stex_structures_structure_prop {
      c_stex_feature_ #2 _prop
    }
    \tl_clear:N \l_tmpa_tl
    \prop_get:NnN \l__stex_structures_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
      \cs_if_exist:cT {
        stex_notation_ #1/\l_tmpa_str \c_hash_str\c_hash_str _cs
      }{
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_put_right:Nn \l_tmpa_tl {,}
        }
        \tl_put_right:Nx \l_tmpa_tl {
          \stex_invoke_symbol:n {#1/\l_tmpa_str}!
        }
      }
    }
    \exp_args:No \mathstruct \l_tmpa_tl
  }{
    \stex_invoke_symbol:n{#1/#3}
  }
}

%%%%%%%%%%%%%   features.dtx   %%%%%%%%%%%%%


\def\titleemph#1{\textbf{#1}}
\keys_define:nn {stex / definiendum }{
  pre     .tl_set:N     = \l__stex_statements_definiendum_pre_tl,
  post    .tl_set:N     = \l__stex_statements_definiendum_post_tl,
  root    .str_set_x:N  = \l__stex_statements_definiendum_root_str,
  gfa     .str_set_x:N  = \l__stex_statements_definiendum_gfa_str
}
\cs_new_protected:Nn \__stex_statements_definiendum_args:n {
  \str_clear:N \l__stex_statements_definiendum_root_str
  \tl_clear:N \l__stex_statements_definiendum_post_tl
  \str_clear:N \l__stex_statements_definiendum_gfa_str
  \keys_set:nn { stex / definiendum }{ #1 }
}
\NewDocumentCommand \definiendum { O{} m m} {
  \__stex_statements_definiendum_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \str_if_empty:NTF \l__stex_statements_definiendum_root_str {
    \tl_if_empty:NTF \l__stex_statements_definiendum_post_tl {
      \tl_set:Nn \l_tmpa_tl { #3 }
    } {
      \str_set:Nx \l__stex_statements_definiendum_root_str { #3 }
      \tl_set:Nn \l_tmpa_tl {
        \l__stex_statements_definiendum_pre_tl\l__stex_statements_definiendum_root_str\l__stex_statements_definiendum_post_tl
       }
    }
  } {
    \tl_set:Nn \l_tmpa_tl { #3 }
  }

  % TODO root
  \stex_html_backend:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { \l_tmpa_tl }
  } {
    \exp_args:Nnx \defemph@uri { \l_tmpa_tl } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \definiendum {definition~environments}

\NewDocumentCommand \definame { O{} m } {
  \__stex_statements_definiendum_args:n { #1 }
  % TODO: root
  \stex_get_symbol:n { #2 }
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \stex_html_backend:TF {
    \stex_if_do_html:T {
      \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } {
        \l_tmpa_str\l__stex_statements_definiendum_post_tl
      }
    }
  } {
    \exp_args:Nnx \defemph@uri {
      \l_tmpa_str\l__stex_statements_definiendum_post_tl
    } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \definame {definition~environments}

\NewDocumentCommand \Definame { O{} m } {
  \__stex_statements_definiendum_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \stex_html_backend:TF {
    \stex_if_do_html:T {
      \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } {
        \exp_after:wN \stex_capitalize:n \l_tmpa_str\l__stex_statements_definiendum_post_tl
      }
    }
  } {
    \exp_args:Nnx \defemph@uri {
      \exp_after:wN \stex_capitalize:n \l_tmpa_str\l__stex_statements_definiendum_post_tl
    } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \Definame {definition~environments}

\NewDocumentCommand \premise { O{} m }{
  \tl_if_empty:nF{#1}{
    % TODO
  }
  \noindent\stex_annotate:nnn{ premise }{#1}{\ignorespaces #2 }
}
\NewDocumentCommand \conclusion { m }{
  \noindent\stex_annotate:nnn{ conclusion }{}{\ignorespaces #1 }
}
\NewDocumentCommand \definiens { O{} m }{
  \str_clear:N \l_stex_get_symbol_uri_str
  \tl_if_empty:nF {#1} {
    \stex_get_symbol:n { #1 }
  }
  \str_if_empty:NT \l_stex_get_symbol_uri_str {
    \int_compare:nNnTF {\clist_count:N \l__stex_statements_sdefinition_for_clist} = 1 {
      \str_set:Nx \l_stex_get_symbol_uri_str {\clist_item:Nn \l__stex_statements_sdefinition_for_clist 1}
    }{
      % TODO throw error
    }
  }
  \str_if_eq:eeT {\prop_item:cn {l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}{module}}
    {\l_stex_current_module_str}{
      \str_if_eq:eeF {\prop_item:cn {l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}{defined}}
      {true}{
        \prop_put:cnn{l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}{defined}{true}
        \exp_args:Nx \stex_add_to_current_module:n {
          \prop_put:cnn{l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}{defined}{true}
        }
      }
  }
  \stex_annotate:nnn{ definiens }{\l_stex_get_symbol_uri_str}{ #2 }
}

\NewDocumentCommand \varbindforall {m}{
  \seq_set_split:Nnn \l_tmpa_seq,{#1}
  \seq_map_inline:Nn \l_tmpa_seq {
    \stex_symbol_or_var:n {##1}
    \bool_if:NTF\l_stex_symbol_or_var_bool{
      \stex_if_do_html:T {
        \stex_annotate_invisible:nnn {bindtype}{forall,\l_stex_get_symbol_uri_str}{}
      }
    }{
      % todo throw error
    }
  }
}

\stex_deactivate_macro:Nn \premise {definition,~example~or~assertion~environments}
\stex_deactivate_macro:Nn \conclusion {example~or~assertion~environments}
\stex_deactivate_macro:Nn \definiens {definition~environments}
\stex_deactivate_macro:Nn \varbindforall {definition~or~assertion~environments}


\keys_define:nn {stex / sdefinition }{
  type    .str_set_x:N  = \sdefinitiontype,
  id      .str_set_x:N  = \sdefinitionid,
  name    .str_set_x:N  = \sdefinitionname,
  for     .clist_set:N  = \l__stex_statements_sdefinition_for_clist ,
  title   .tl_set:N     = \sdefinitiontitle
}
\cs_new_protected:Nn \__stex_statements_sdefinition_args:n {
  \str_clear:N \sdefinitiontype
  \str_clear:N \sdefinitionid
  \str_clear:N \sdefinitionname
  \clist_clear:N \l__stex_statements_sdefinition_for_clist
  \tl_clear:N \sdefinitiontitle
  \keys_set:nn { stex / sdefinition }{ #1 }
}

\NewDocumentEnvironment{sdefinition}{O{}}{
  \__stex_statements_sdefinition_args:n{ #1 }
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \stex_reactivate_macro:N \Definame
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \definiens
  \stex_reactivate_macro:N \varbindforall
  \stex_if_smsmode:F{
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sdefinition_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \clist_set_from_seq:NN \l__stex_statements_sdefinition_for_clist \l_tmpb_seq
    \exp_args:Nnnx
    \begin{stex_annotate_env}{definition}{\seq_use:Nn \l_tmpb_seq {,}}
    \str_if_empty:NF \sdefinitiontype {
      \stex_annotate_invisible:nnn{typestrings}{\sdefinitiontype}{}
    }
    \str_if_empty:NF \sdefinitionname {
      \stex_annotate_invisible:nnn{statementname}{\sdefinitionname}{}
    }
    \clist_set:No \l_tmpa_clist \sdefinitiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sdefinition_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {
          \stex_patch_counters:
          \use:c{__stex_statements_sdefinition_##1_start:}
          \stex_unpatch_counters:
        }
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sdefinition_start:
    }{
      \l_tmpa_tl
    }
  }
  \stex_ref_new_doc_target:n \sdefinitionid
  \stex_smsmode_do:
}{
  \stex_suppress_html:n {
    \str_if_empty:NF \sdefinitionname { \stex_symdecl_do:nn{}{\sdefinitionname} }
  }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sdefinitiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sdefinition_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sdefinition_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sdefinition_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}
\cs_new_protected:Nn \__stex_statements_sdefinition_start: {
  \stex_par:\noindent\titleemph{Definition\tl_if_empty:NF \sdefinitiontitle {
    ~(\sdefinitiontitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sdefinition_end: {\stex_par:\medskip}

\newcommand\stexpatchdefinition[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sdefinition_start: { #2 }
      \tl_set:Nn \__stex_statements_sdefinition_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sdefinition_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sdefinition_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlinedef }{
  type    .str_set_x:N  = \sdefinitiontype,
  id      .str_set_x:N  = \sdefinitionid,
  for     .clist_set:N  = \l__stex_statements_sdefinition_for_clist ,
  name    .str_set_x:N  = \sdefinitionname
}
\cs_new_protected:Nn \__stex_statements_inlinedef_args:n {
  \str_clear:N \sdefinitiontype
  \str_clear:N \sdefinitionid
  \str_clear:N \sdefinitionname
  \clist_clear:N \l__stex_statements_sdefinition_for_clist
  \keys_set:nn { stex / inlinedef }{ #1 }
}
\NewDocumentCommand \inlinedef { O{} m } {
  \begingroup
  \__stex_statements_inlinedef_args:n{ #1 }
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \stex_reactivate_macro:N \Definame
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \definiens
  \stex_reactivate_macro:N \varbindforall
  \stex_ref_new_doc_target:n \sdefinitionid
  \stex_if_smsmode:TF{\stex_suppress_html:n {
    \str_if_empty:NF \sdefinitionname { \stex_symdecl_do:nn{}{\sdefinitionname} }
  }}{
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sdefinition_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \clist_set_from_seq:NN \l__stex_statements_sdefinition_for_clist \l_tmpb_seq
    \ifvmode\noindent\fi
    \exp_args:Nnx
    \stex_annotate:nnn{definition}{\seq_use:Nn \l_tmpb_seq {,}}{
      \str_if_empty:NF \sdefinitiontype {
        \stex_annotate_invisible:nnn{typestrings}{\sdefinitiontype}{}
      }
      #2
      \str_if_empty:NF \sdefinitionname {
        \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sdefinitionname}}
        \stex_annotate_invisible:nnn{statementname}{\sdefinitionname}{}
      }
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\keys_define:nn {stex / sassertion }{
  type    .str_set_x:N  = \sassertiontype,
  id      .str_set_x:N  = \sassertionid,
  title   .tl_set:N     = \sassertiontitle ,
  for     .clist_set:N  = \l__stex_statements_sassertion_for_clist ,
  judgment .str_set_x:N = \l__stex_statements_judgment_str ,
  name    .str_set_x:N  = \sassertionname
}
\cs_new_protected:Nn \__stex_statements_sassertion_args:n {
  \str_clear:N \sassertiontype
  \str_clear:N \sassertionid
  \str_clear:N \sassertionname
  \clist_clear:N \l__stex_statements_sassertion_for_clist
  \str_clear:N \l__stex_statements_judgment_str
  \tl_clear:N \sassertiontitle
  \keys_set:nn { stex / sassertion }{ #1 }
}


\NewDocumentEnvironment{sassertion}{O{}}{
  \__stex_statements_sassertion_args:n{ #1 }
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \conclusion
  \stex_reactivate_macro:N \varbindforall
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \str_if_empty:NF \sassertionname {
    \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sassertionname}}
    \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sassertionname}
  }
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sassertion_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{assertion}{\seq_use:Nn \l_tmpb_seq {,}}
    \str_if_empty:NF \sassertiontype {
      \stex_annotate_invisible:nnn{type}{\sassertiontype}{}
    }
    \str_if_empty:NF \sassertionname {
      \stex_annotate_invisible:nnn{statementname}{\sassertionname}{}
    }
    \str_if_empty:NF \l__stex_statements_judgment_str {
      \exp_args:No \stex_get_symbol:n \l__stex_statements_judgment_str
      \stex_annotate_invisible:nnn{judgment} \l_stex_get_symbol_uri_str {}
    }
    \clist_set:No \l_tmpa_clist \sassertiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sassertion_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {
          \stex_patch_counters:
          \use:c{__stex_statements_sassertion_##1_start:}
          \stex_unpatch_counters:
        }
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sassertion_start:
    }{
      \l_tmpa_tl
    }
  }
  \str_if_empty:NTF \sassertionid {
    \str_if_empty:NF \sassertionname {
      \stex_ref_new_doc_target:n {}
    }
  } {
    \stex_ref_new_doc_target:n \sassertionid
  }
  \stex_smsmode_do:
}{
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sassertiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sassertion_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sassertion_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sassertion_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sassertion_start: {
  \stex_par:\noindent\titleemph{Assertion~\tl_if_empty:NF \sassertiontitle {
    (\sassertiontitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sassertion_end: {\stex_par:\medskip}

\newcommand\stexpatchassertion[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sassertion_start: { #2 }
      \tl_set:Nn \__stex_statements_sassertion_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sassertion_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sassertion_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlineass }{
  type    .str_set_x:N  = \sassertiontype,
  id      .str_set_x:N  = \sassertionid,
  for     .clist_set:N  = \l__stex_statements_sassertion_for_clist ,
  judgment .str_set_x:N = \l__stex_statements_judgment_str ,
  name    .str_set_x:N  = \sassertionname
}
\cs_new_protected:Nn \__stex_statements_inlineass_args:n {
  \str_clear:N \sassertiontype
  \str_clear:N \sassertionid
  \str_clear:N \sassertionname
  \str_clear:N \l__stex_statements_judgment_str
  \clist_clear:N \l__stex_statements_sassertion_for_clist
  \keys_set:nn { stex / inlineass }{ #1 }
}
\NewDocumentCommand \inlineass { O{} m } {
  \begingroup
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \conclusion
  \stex_reactivate_macro:N \varbindforall
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \__stex_statements_inlineass_args:n{ #1 }
  \str_if_empty:NTF \sassertionid {
    \str_if_empty:NF \sassertionname {
      \stex_ref_new_doc_target:n {}
    }
  } {
    \stex_ref_new_doc_target:n \sassertionid
  }

  \stex_if_smsmode:TF{
    \str_if_empty:NF \sassertionname {
      \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sassertionname}}
      \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sassertionname}
    }
  }{
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sassertion_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \ifvmode\noindent\fi
    \exp_args:Nnx
    \stex_annotate:nnn{assertion}{\seq_use:Nn \l_tmpb_seq {,}}{
      \str_if_empty:NF \sassertiontype {
        \stex_annotate_invisible:nnn{typestrings}{\sassertiontype}{}
      }
      #2
      \str_if_empty:NF \sassertionname {
        \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sassertionname}}
        \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sassertionname}
        \stex_annotate_invisible:nnn{statementname}{\sassertionname}{}
      }
      \str_if_empty:NF \l__stex_statements_judgment_str {
        \exp_args:No \stex_get_symbol:n \l__stex_statements_judgment_str
        \stex_annotate_invisible:nnn{judgment} \l_stex_get_symbol_uri_str {}
      }
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\keys_define:nn {stex / sexample }{
  type    .str_set_x:N  = \exampletype,
  id      .str_set_x:N  = \sexampleid,
  title   .tl_set:N     = \sexampletitle,
  name    .str_set_x:N  = \sexamplename ,
  for     .clist_set:N  = \l__stex_statements_sexample_for_clist,
}
\cs_new_protected:Nn \__stex_statements_sexample_args:n {
  \str_clear:N \sexampletype
  \str_clear:N \sexampleid
  \str_clear:N \sexamplename
  \tl_clear:N \sexampletitle
  \clist_clear:N \l__stex_statements_sexample_for_clist
  \keys_set:nn { stex / sexample }{ #1 }
}

\NewDocumentEnvironment{sexample}{O{}}{
  \__stex_statements_sexample_args:n{ #1 }
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \conclusion
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sexample_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{example}{\seq_use:Nn \l_tmpb_seq {,}}
    \str_if_empty:NF \sexampletype {
      \stex_annotate_invisible:nnn{typestrings}{\sexampletype}{}
    }
    \str_if_empty:NF \sexamplename {
      \stex_annotate_invisible:nnn{statementname}{\sexamplename}{}
    }
    \clist_set:No \l_tmpa_clist \sexampletype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sexample_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {
          \stex_patch_counters:
          \use:c{__stex_statements_sexample_##1_start:}
          \stex_unpatch_counters:
        }
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sexample_start:
    }{
      \l_tmpa_tl
    }
  }
  \str_if_empty:NF \sexampleid {
    \stex_ref_new_doc_target:n \sexampleid
  }
  \stex_smsmode_do:
}{
  \str_if_empty:NF \sexamplename {
    \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sexamplename}}
  }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sexampletype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sexample_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sexample_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sexample_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sexample_start: {
  \stex_par:\noindent\titleemph{Example~\tl_if_empty:NF \sexampletitle {
    (\sexampletitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sexample_end: {\stex_par:\medskip}

\newcommand\stexpatchexample[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sexample_start: { #2 }
      \tl_set:Nn \__stex_statements_sexample_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sexample_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sexample_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlineex }{
  type    .str_set_x:N  = \sexampletype,
  id      .str_set_x:N  = \sexampleid,
  for     .clist_set:N  = \l__stex_statements_sexample_for_clist ,
  name    .str_set_x:N  = \sexamplename
}
\cs_new_protected:Nn \__stex_statements_inlineex_args:n {
  \str_clear:N \sexampletype
  \str_clear:N \sexampleid
  \str_clear:N \sexamplename
  \clist_clear:N \l__stex_statements_sexample_for_clist
  \keys_set:nn { stex / inlineex }{ #1 }
}
\NewDocumentCommand \inlineex { O{} m } {
  \begingroup
  \stex_reactivate_macro:N \premise
  \stex_reactivate_macro:N \conclusion
  \__stex_statements_inlineex_args:n{ #1 }
  \str_if_empty:NF \sexampleid {
    \stex_ref_new_doc_target:n \sexampleid
  }
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sexamplename {
      \stex_suppress_html:n{\stex_symdecl_do:nn{}{\examplename}}
    }
  }{
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sexample_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \ifvmode\noindent\fi
    \exp_args:Nnx
    \stex_annotate:nnn{example}{\seq_use:Nn \l_tmpb_seq {,}}{
      \str_if_empty:NF \sexampletype {
        \stex_annotate_invisible:nnn{typestrings}{\sexampletype}{}
      }
      #2
      \str_if_empty:NF \sexamplename {
        \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sexamplename}}
        \stex_annotate_invisible:nnn{statementname}{\sexamplename}{}
      }
    }
  }
  \endgroup
  \stex_smsmode_do:
}
\keys_define:nn { stex / sparagraph} {
  id      .str_set_x:N   = \sparagraphid ,
  title   .tl_set:N      = \l_stex_sparagraph_title_tl ,
  type    .str_set_x:N   = \sparagraphtype ,
  for     .clist_set:N   = \l__stex_statements_sparagraph_for_clist ,
  from    .tl_set:N      = \sparagraphfrom ,
  to      .tl_set:N      = \sparagraphto ,
  start   .tl_set:N      = \l_stex_sparagraph_start_tl ,
  name    .str_set:N     = \sparagraphname ,
  imports .tl_set:N      = \l__stex_statements_sparagraph_imports_tl
}

\cs_new_protected:Nn \stex_sparagraph_args:n {
  \tl_clear:N \l_stex_sparagraph_title_tl
  \tl_clear:N \sparagraphfrom
  \tl_clear:N \sparagraphto
  \tl_clear:N \l_stex_sparagraph_start_tl
  \tl_clear:N \l__stex_statements_sparagraph_imports_tl
  \str_clear:N \sparagraphid
  \str_clear:N \sparagraphtype
  \clist_clear:N \l__stex_statements_sparagraph_for_clist
  \str_clear:N \sparagraphname
  \keys_set:nn { stex / sparagraph }{ #1 }
}
\newif\if@in@omtext\@in@omtextfalse

\NewDocumentEnvironment {sparagraph} { O{} } {
  \stex_sparagraph_args:n { #1 }
  \tl_if_empty:NTF \l_stex_sparagraph_start_tl {
    \tl_set_eq:NN \sparagraphtitle \l_stex_sparagraph_title_tl
  }{
    \tl_set_eq:NN \sparagraphtitle \l_stex_sparagraph_start_tl
  }
  \@in@omtexttrue
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sparagraph_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{paragraph}{\seq_use:Nn \l_tmpb_seq {,}}
    \str_if_empty:NF \sparagraphtype {
      \stex_annotate_invisible:nnn{typestrings}{\sparagraphtype}{}
    }
    \str_if_empty:NF \sparagraphfrom {
      \stex_annotate_invisible:nnn{from}{\sparagraphfrom}{}
    }
    \str_if_empty:NF \sparagraphto {
      \stex_annotate_invisible:nnn{to}{\sparagraphto}{}
    }
    \str_if_empty:NF \sparagraphname {
      \stex_annotate_invisible:nnn{statementname}{\sparagraphname}{}
    }
    \clist_set:No \l_tmpa_clist \sparagraphtype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \sparagraphtype {
      \tl_if_exist:cT {__stex_statements_sparagraph_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {
          \stex_patch_counters:
          \use:c{__stex_statements_sparagraph_##1_start:}
          \stex_unpatch_counters:
        }
      }
    }
    \stex_csl_to_imports:No \usemodule \l__stex_statements_sparagraph_imports_tl
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sparagraph_start:
    }{
      \l_tmpa_tl
    }
  }
  \clist_set:No \l_tmpa_clist \sparagraphtype
  \exp_args:NNx \clist_if_in:NnT \l_tmpa_clist {\tl_to_str:n{symdoc}}
  {
    \stex_reactivate_macro:N \definiendum
    \stex_reactivate_macro:N \definame
    \stex_reactivate_macro:N \Definame
    \stex_reactivate_macro:N \premise
    \stex_reactivate_macro:N \definiens
  }
  \str_if_empty:NTF \sparagraphid {
    \str_if_empty:NTF \sparagraphname {
      \exp_args:NNx \clist_if_in:NnT \l_tmpa_clist {\tl_to_str:n{symdoc}}{
        \stex_ref_new_doc_target:n {}
      }
    } {
      \stex_ref_new_doc_target:n {}
    }
  } {
    \stex_ref_new_doc_target:n \sparagraphid
  }
  \exp_args:NNx
  \clist_if_in:NnT \l_tmpa_clist {\tl_to_str:n{symdoc}}{
    \clist_map_inline:Nn \l__stex_statements_sparagraph_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
      }
    }
  }
  \stex_smsmode_do:
  \ignorespacesandpars
}{
  \str_if_empty:NF \sparagraphname {
    \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sparagraphname}}
    \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sparagraphname}
  }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sparagraphtype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sparagraph_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sparagraph_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sparagraph_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sparagraph_start: {
  \stex_par:\noindent\tl_if_empty:NTF \l_stex_sparagraph_start_tl {
    \tl_if_empty:NF \l_stex_sparagraph_title_tl {
      \titleemph{\l_stex_sparagraph_title_tl}:~
    }
  }{
    \titleemph{\l_stex_sparagraph_start_tl}~
  }
}
\cs_new_protected:Nn \__stex_statements_sparagraph_end: {\stex_par:\medskip}

\newcommand\stexpatchparagraph[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sparagraph_start: { #2 }
      \tl_set:Nn \__stex_statements_sparagraph_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sparagraph_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sparagraph_#1_end:\endcsname{ #3 }
    }
}

\keys_define:nn { stex / inlinepara} {
  id      .str_set_x:N   = \sparagraphid ,
  type    .str_set_x:N   = \sparagraphtype ,
  for     .clist_set:N   = \l__stex_statements_sparagraph_for_clist ,
  from    .tl_set:N      = \sparagraphfrom ,
  to      .tl_set:N      = \sparagraphto ,
  name    .str_set:N     = \sparagraphname
}
\cs_new_protected:Nn \__stex_statements_inlinepara_args:n {
  \tl_clear:N \sparagraphfrom
  \tl_clear:N \sparagraphto
  \str_clear:N \sparagraphid
  \str_clear:N \sparagraphtype
  \clist_clear:N \l__stex_statements_sparagraph_for_clist
  \str_clear:N \sparagraphname
  \keys_set:nn { stex / inlinepara }{ #1 }
}
\NewDocumentCommand \inlinepara { O{} m } {
  \begingroup
  \__stex_statements_inlinepara_args:n{ #1 }
  \clist_set:No \l_tmpa_clist \sparagraphtype
  \str_if_empty:NTF \sparagraphid {
    \str_if_empty:NTF \sparagraphname {
      \exp_args:NNx \clist_if_in:NnT \l_tmpa_clist {\tl_to_str:n{symdoc}}{
        \stex_ref_new_doc_target:n {}
      }
    } {
      \stex_ref_new_doc_target:n {}
    }
  } {
    \stex_ref_new_doc_target:n \sparagraphid
  }
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sparagraphname {
      \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sparagraphname}}
      \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sparagraphname}
    }
  }{
    \seq_clear:N \l_tmpb_seq
    \clist_map_inline:Nn \l__stex_statements_sparagraph_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \ifvmode\noindent\fi
    \exp_args:Nnx
    \stex_annotate:nnn{paragraph}{\seq_use:Nn \l_tmpb_seq {,}}{
      \str_if_empty:NF \sparagraphtype {
        \stex_annotate_invisible:nnn{typestrings}{\sparagraphtype}{}
      }
      \str_if_empty:NF \sparagraphfrom {
        \stex_annotate_invisible:nnn{from}{\sparagraphfrom}{}
      }
      \str_if_empty:NF \sparagraphto {
        \stex_annotate_invisible:nnn{to}{\sparagraphto}{}
      }
      \str_if_empty:NF \sparagraphname {
        \stex_suppress_html:n{\stex_symdecl_do:nn{}{\sparagraphname}}
        \stex_annotate_invisible:nnn{statementname}{\sparagraphname}{}
        \stex_ref_new_sym_target:n {\l_stex_current_module_str ? \sparagraphname}
      }
      \exp_args:NNx \clist_if_in:NnT \l_tmpa_clist {\tl_to_str:n{symdoc}}{
        \clist_map_inline:Nn \l_tmpb_seq {
          \stex_ref_new_sym_target:n {##1}
        }
      }
      #2
    }
  }
  \endgroup
  \stex_smsmode_do:
}



%%%%%%%%%%%%%   sproof.dtx   %%%%%%%%%%%%%

\keys_define:nn { stex / spf } {
  id          .str_set_x:N  = \spfid,
  for         .clist_set:N  = \l__stex_sproof_spf_for_clist ,
  from        .tl_set:N     = \l__stex_sproof_spf_from_tl ,
  proofend    .tl_set:N     = \l__stex_sproof_spf_proofend_tl,
  type        .str_set_x:N  = \spftype,
  title       .tl_set:N     = \spftitle,
  continues   .tl_set:N     = \l__stex_sproof_spf_continues_tl,
  functions   .tl_set:N     = \l__stex_sproof_spf_functions_tl,
  term        .tl_set:N     = \l__stex_sproof_spf_term_tl,
  method      .tl_set:N     = \l__stex_sproof_spf_method_tl,
  hide        .bool_set:N   = \l__stex_sproof_spf_hide_bool
}
\cs_new_protected:Nn \__stex_sproof_spf_args:n {
\str_clear:N \spfid
\tl_clear:N \l__stex_sproof_spf_for_tl
\tl_clear:N \l__stex_sproof_spf_from_tl
\tl_set:Nn \l__stex_sproof_spf_proofend_tl {\sproof@box}
\str_clear:N \spftype
\tl_clear:N \spftitle
\tl_clear:N \l__stex_sproof_spf_continues_tl
\tl_clear:N \l__stex_sproof_spf_term_tl
\tl_clear:N \l__stex_sproof_spf_functions_tl
\tl_clear:N \l__stex_sproof_spf_method_tl
  \bool_set_false:N \l__stex_sproof_spf_hide_bool
\keys_set:nn { stex / spf }{ #1 }
}
\bool_set_true:N \l__stex_sproof_inc_counter_bool
\str_set:Nn\c__stex_sproof_flow_str{inline}
\intarray_new:Nn\l__stex_sproof_counter_intarray{50}
\cs_new_protected:Npn \sproofnumber {
  \int_set:Nn \l_tmpa_int {1}
  \bool_while_do:nn {
    \int_compare_p:nNn {
      \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int
    } > 0
  }{
    \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int .
    \int_incr:N \l_tmpa_int
  }
}
\cs_new_protected:Npn \__stex_sproof_inc_counter: {
  \int_set:Nn \l_tmpa_int {1}
  \bool_while_do:nn {
    \int_compare_p:nNn {
      \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int
    } > 0
  }{
    \int_incr:N \l_tmpa_int
  }
  \int_compare:nNnF \l_tmpa_int = 1 {
    \int_decr:N \l_tmpa_int
  }
  \intarray_gset:Nnn \l__stex_sproof_counter_intarray \l_tmpa_int {
    \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int + 1
  }
}

\cs_new_protected:Npn \__stex_sproof_add_counter: {
  \int_set:Nn \l_tmpa_int {1}
  \bool_while_do:nn {
    \int_compare_p:nNn {
      \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int
    } > 0
  }{
    \int_incr:N \l_tmpa_int
  }
  \intarray_gset:Nnn \l__stex_sproof_counter_intarray \l_tmpa_int { 1 }
}

\cs_new_protected:Npn \__stex_sproof_remove_counter: {
  \int_set:Nn \l_tmpa_int {1}
  \bool_while_do:nn {
    \int_compare_p:nNn {
      \intarray_item:Nn \l__stex_sproof_counter_intarray \l_tmpa_int
    } > 0
  }{
    \int_incr:N \l_tmpa_int
  }
  \int_decr:N \l_tmpa_int
  \intarray_gset:Nnn \l__stex_sproof_counter_intarray \l_tmpa_int { 0 }
}
\def\sproof@box{
  \ltx@ifpackageloaded{amssymb}{$\square$}{
    \hbox{\vrule\vbox{\hrule width 6 pt\vskip 6pt\hrule}\vrule}
  }
}
\def\sproofend{
  \tl_if_empty:NF \l__stex_sproof_spf_proofend_tl {
    \hfil\null\nobreak\hfill\l__stex_sproof_spf_proofend_tl\par\smallskip
  }
}
\def\spf@proofsketch@kw{Proof~Sketch}
\def\spf@proof@kw{Proof}
\def\spf@step@kw{Step}
\AddToHook{begindocument}{
  \ltx@ifpackageloaded{babel}{
    \makeatletter
    \clist_set:Nx \l_tmpa_clist {\bbl@loaded}
    \clist_if_in:NnT \l_tmpa_clist {ngerman}{
      \input{sproof-ngerman.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {finnish}{
      \input{sproof-finnish.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {french}{
      \input{sproof-french.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {russian}{
      \input{sproof-russian.ldf}
    }
    \makeatother
  }{}
}
\newcommand\spfsketch[2][]{
  \begingroup
  \let \premise \stex_proof_premise:
  \__stex_sproof_spf_args:n{#1}
  \stex_if_smsmode:TF {
    \str_if_empty:NF \spfid {
      \stex_ref_new_doc_target:n \spfid
    }
  }{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_sproof_spf_for_clist {
      \tl_if_empty:nF{ ##1 }{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnx
    \stex_annotate:nnn{proofsketch}{\seq_use:Nn \l_tmpa_seq {,}}{
      \str_if_empty:NF \spftype {
        \stex_annotate_invisible:nnn{type}{\spftype}{}
      }
      \clist_set:No \l_tmpa_clist \spftype
      \tl_set:Nn \l_tmpa_tl {
        \titleemph{
          \tl_if_empty:NTF \spftitle {
            \spf@proofsketch@kw
          }{
            \spftitle
          }
        }:~
      }
      \clist_map_inline:Nn \l_tmpa_clist {
        \exp_args:No \str_if_eq:nnT \c__stex_sproof_flow_str {##1} {
          \tl_clear:N \l_tmpa_tl
        }
      }
      \str_if_empty:NF \spfid {
        \stex_ref_new_doc_target:n \spfid
      }
      \l_tmpa_tl #2 \sproofend
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\bool_set_false:N \l__stex_sproof_in_spfblock_bool

\cs_new_protected:Nn \__stex_sproof_maybe_comment: {
  \bool_if:NF \l__stex_sproof_in_spfblock_bool {
    \par \setbox \l_tmpa_box \vbox \bgroup \everypar{\__stex_sproof_start_comment:}
  }
}
\cs_new_protected:Nn \__stex_sproof_maybe_comment_end: {
  \bool_if:NF \l__stex_sproof_in_spfblock_bool { \egroup }
}
\cs_new_protected:Nn \__stex_sproof_start_comment: {
  \egroup\csname @ @ par\endcsname\item[]\bgroup\stexcommentfont
}

\cs_new_protected:Npn \stexcommentfont {
  \small\itshape
}
\cs_new_protected:Nn \__stex_sproof_start_env_nolist:nnn {
  \seq_clear:N \l_tmpa_seq
  \clist_map_inline:Nn \l__stex_sproof_spf_for_clist {
    \tl_if_empty:nF{ ##1 }{
      \stex_get_symbol:n { ##1 }
      \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
        \l_stex_get_symbol_uri_str
      }
    }
  }
  \exp_args:Nnnx
  \begin{stex_annotate_env}{#1}{\seq_use:Nn \l_tmpa_seq {,}}
  \str_if_empty:NF \spftype {
    \stex_annotate_invisible:nnn{type}{\spftype}{}
  }
  #3 {~\stex_annotate:nnn{spftitle}{}{#2}}
  \str_if_empty:NF \spfid {
    \stex_ref_new_doc_target:n \spfid
  }
  \begin{stex_annotate_env}{spfbody}{\bool_if:NTF \l__stex_sproof_spf_hide_bool {false}{true}}
  \bool_if:NT \l__stex_sproof_spf_hide_bool{
    \stex_html_backend:F{\setbox\l_tmpa_box\vbox\bgroup}
  }
}
\cs_new_protected:Nn \__stex_sproof_start_env:nnn {
  \__stex_sproof_start_env_nolist:nnn{#1}{#2}{#3}
  \begin{list}{}{
    \setlength\topsep{0pt}
    \setlength\parsep{0pt}
    \setlength\rightmargin{0pt}

  }\__stex_sproof_maybe_comment:
}
\cs_new_protected:Nn \__stex_sproof_end_env:n {
  \stex_if_smsmode:F{
    \__stex_sproof_maybe_comment_end:
    \end{list}
    \bool_if:NT \l__stex_sproof_spf_hide_bool{
      \stex_html_backend:F{\egroup}
    }
    \clist_set:No \l_tmpa_clist \spftype
    #1
    \end{stex_annotate_env}
    \end{stex_annotate_env}
  }
}
\NewDocumentEnvironment{sproof}{O{} m}{
  \intarray_gzero:N \l__stex_sproof_counter_intarray
  \intarray_gset:Nnn \l__stex_sproof_counter_intarray 1 1
  \stex_reactivate_macro:N \yield
  \stex_reactivate_macro:N \eqstep
  \stex_reactivate_macro:N \assumption
  \stex_reactivate_macro:N \conclude
  \stex_reactivate_macro:N \spfstep
  \__stex_sproof_spf_args:n{#1}
  \stex_if_smsmode:TF {
    \str_if_empty:NF \spfid {
      \stex_ref_new_doc_target:n \spfid
    }
  }{
    \__stex_sproof_start_env:nnn{sproof}{#2}{
      \clist_set:No \l_tmpa_clist \spftype
      \tl_clear:N \l_tmpa_tl
      \clist_map_inline:Nn \l_tmpa_clist {
        \tl_if_exist:cT {__stex_sproof_sproof_##1_start:}{
          \tl_set:Nn \l_tmpa_tl {\use:c{__stex_sproof_sproof_##1_start:}}
        }
        \exp_args:No \str_if_eq:nnT \c__stex_sproof_flow_str {##1} {
          \tl_set:Nn \l_tmpa_tl {\use:n{}}
        }
      }
      \tl_if_empty:NTF \l_tmpa_tl {
        \__stex_sproof_sproof_start:
      }{
        \l_tmpa_tl
      }
    }
  }
  \stex_smsmode_do:
}{\__stex_sproof_end_env:n{
  \tl_clear:N \l_tmpa_tl
  \clist_map_inline:Nn \l_tmpa_clist {
    \tl_if_exist:cT {__stex_sproof_sproof_##1_end:}{
      \tl_set:Nn \l_tmpa_tl {\use:c{__stex_sproof_sproof_##1_end:}}
    }
  }
  \tl_if_empty:NTF \l_tmpa_tl {
    \__stex_sproof_sproof_end:
  }{
    \l_tmpa_tl
  }
}}

\NewDocumentEnvironment{sproof*}{O{}}{
  \stex_reactivate_macro:N \yield
  \stex_reactivate_macro:N \eqstep
  \stex_reactivate_macro:N \assumption
  \stex_reactivate_macro:N \conclude
  \stex_reactivate_macro:N \spfstep
  \__stex_sproof_spf_args:n{#1}
  \stex_if_smsmode:TF {
    \str_if_empty:NF \spfid {
      \stex_ref_new_doc_target:n \spfid
    }
  }{
    \__stex_sproof_start_env_nolist:nnn{sproof}{}{
      \clist_set:No \l_tmpa_clist \spftype
      \tl_clear:N \l_tmpa_tl
      \clist_map_inline:Nn \l_tmpa_clist {
        \tl_if_exist:cT {__stex_sproof_sproof_##1_start:}{
          \tl_set:Nn \l_tmpa_tl {\use:c{__stex_sproof_sproof_##1_start:}}
        }
        \exp_args:No \str_if_eq:nnT \c__stex_sproof_flow_str {##1} {
          \tl_set:Nn \l_tmpa_tl {\use:n{}}
        }
      }
      \tl_if_empty:NTF \l_tmpa_tl {
        \__stex_sproof_sproof_start:
      }{
        \l_tmpa_tl
      }
    }
  }
  \bool_set_true:N \l__stex_sproof_in_spfblock_bool
  \stex_smsmode_do:
}{
  \stex_if_smsmode:F{
    \bool_if:NT \l__stex_sproof_spf_hide_bool{
      \stex_html_backend:F{\egroup}
    }
    \clist_set:No \l_tmpa_clist \spftype

  \tl_clear:N \l_tmpa_tl
  \clist_map_inline:Nn \l_tmpa_clist {
    \tl_if_exist:cT {__stex_sproof_sproof_##1_end:}{
      \tl_set:Nn \l_tmpa_tl {\use:c{__stex_sproof_sproof_##1_end:}}
    }
  }
  \tl_if_empty:NTF \l_tmpa_tl {
    \__stex_sproof_sproof_end:
  }{
    \l_tmpa_tl
  }
    \end{stex_annotate_env}
    \end{stex_annotate_env}
  }
}

\NewDocumentEnvironment{subproof}{s O{} m}{
  \__stex_sproof_spf_args:n{#2}
  \stex_if_smsmode:TF {
    \str_if_empty:NF \spfid {
      \stex_ref_new_doc_target:n \spfid
    }
  }{
    \__stex_sproof_start_env:nnn{subproof}{
      \stex_html_backend:T{\csname @ @ par\endcsname}\item[\sproofnumber]\ignorespacesandpars #3}{}
  }
  \__stex_sproof_add_counter:
  \stex_smsmode_do:
}{\__stex_sproof_remove_counter:\__stex_sproof_end_env:n{}
  \bool_if:NT \l__stex_sproof_inc_counter_bool {
    \__stex_sproof_inc_counter:
  }
  \aftergroup\__stex_sproof_maybe_comment:
}
\AddToHook{env/subproof/before}{\__stex_sproof_maybe_comment_end:}

\cs_new_protected:Nn \__stex_sproof_sproof_start: {
  \par\noindent\titleemph{
    \tl_if_empty:NTF \spftype {
      \spf@proof@kw
    }{
      \spftype
    }
  }:
}
\cs_new_protected:Nn \__stex_sproof_sproof_end: {\sproofend}

\newcommand\stexpatchproof[3][] {
  \str_set:Nx \l_tmpa_str{ #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \tl_set:Nn \__stex_sproof_sproof_start: { #2 }
    \tl_set:Nn \__stex_sproof_sproof_end: { #3 }
  }{
    \exp_after:wN \tl_set:Nn \csname __stex_sproof_sproof_#1_start:\endcsname{ #2 }
    \exp_after:wN \tl_set:Nn \csname __stex_sproof_sproof_#1_end:\endcsname{ #3 }
  }
}

\keys_define:nn { stex / spfsteps } {
  id          .str_set_x:N  = \spfstepid,
  for         .clist_set:N  = \l__stex_sproof_spf_for_clist ,
  type        .str_set_x:N  = \spftype,
  title       .tl_set:N     = \spftitle,
  method      .tl_set:N     = \l__stex_sproof_spf_method_tl,
  term        .tl_set:N     = \l__stex_sproof_spf_term_tl,
  name        .str_set_x:N  = \l__stex_sproof_spf_name_str
}
\cs_new_protected:Nn \__stex_sproof_spfstep_args:n {
\str_clear:N \spfstepid
\clist_clear:N \l__stex_sproof_spf_for_clist
\str_clear:N \spftype
  \str_clear:N \l__stex_sproof_spf_name_str
\tl_clear:N \l__stex_sproof_spf_method_tl
\tl_clear:N \l__stex_sproof_spf_term_tl
  %\bool_set_false:N \l__stex_sproof_inc_counter_bool
\keys_set:nn { stex / spfsteps }{ #1 }
}

\cs_new_protected:Nn \__stex_sproof_make_step_macro:Nnnnn {
  \NewDocumentCommand #1 {s O{} +m} {
    \__stex_sproof_maybe_comment_end:

    \__stex_sproof_spfstep_args:n{##2}
    \stex_annotate:nnn{spfstep}{#2}{
      \bool_if:NTF \l__stex_sproof_in_spfblock_bool {
        #4
      }{
        \stex_html_backend:T{\csname @ @ par\endcsname}
        \item[\IfBooleanTF ##1 {}{#3}]
      }
      \str_if_empty:NF \l__stex_sproof_spf_name_str {
        \stex_debug:nn{spfstep}{Name:\l__stex_sproof_spf_name_str}
        \stex_annotate_invisible:nnn{spfname}{}{\l__stex_sproof_spf_name_str}
        \stex_suppress_html:n{
          \exp_args:NNx\exp_args:Nnx\vardef{v\l__stex_sproof_spf_name_str}{\exp_not:N\comp{\l__stex_sproof_spf_name_str}}
        }
      }
      \tl_if_empty:NF \l__stex_sproof_spf_term_tl {
        \stex_annotate_invisible:nnn{spfyield}{}{$\l__stex_sproof_spf_term_tl$}
      }
      \ignorespacesandpars ##3
    }
    \bool_if:NF \l__stex_sproof_in_spfblock_bool { \IfBooleanTF ##1 {}{ #5 } }
    \__stex_sproof_maybe_comment:
  }
  \stex_deactivate_macro:Nn #1 {sproof~environments}
}

\__stex_sproof_make_step_macro:Nnnnn \assumption {assumption} \sproofnumber {} \__stex_sproof_inc_counter:
\__stex_sproof_make_step_macro:Nnnnn \conclude {conclusion} {$\Rightarrow$} {} {}
\__stex_sproof_make_step_macro:Nnnnn \spfstep {} \sproofnumber {} \__stex_sproof_inc_counter:

\NewDocumentCommand \eqstep {s m}{
  \__stex_sproof_maybe_comment_end:
  \bool_if:NTF \l__stex_sproof_in_spfblock_bool {
    $=$
  }{
    \item[$=$]
  }
  $\stex_annotate:nnn{spfstep}{eq}{ #2 }$
  \__stex_sproof_maybe_comment:
}
\stex_deactivate_macro:Nn \eqstep {sproof~environments}

\NewDocumentCommand \yield {+m}{
  \stex_annotate:nnn{spfyield}{}{ #1 }
}
\stex_deactivate_macro:Nn \yield {sproof~environments}

\NewDocumentEnvironment{spfblock}{}{
  \item[]
  \bool_set_true:N \l__stex_sproof_in_spfblock_bool
}{
  \aftergroup\__stex_sproof_maybe_comment:
}
\AddToHook{env/spfblock/before}{\__stex_sproof_maybe_comment_end:}

\NewDocumentCommand\spfidea{O{} +m}{
  \__stex_sproof_spf_args:n{#1}
  \titleemph{
    \tl_if_empty:NTF \spftype {Proof~Idea}{
      \spftype
    }:
  }~#2
  \sproofend
}
\newcommand\spfjust[1]{
  \stex_annotate:nnn{justification}{}{#1}
}

%%%%%%%%%%%%%   metatheory.dtx   %%%%%%%%%%%%%

\str_const:Nn \c_stex_metatheory_ns_str {http://mathhub.info/sTeX/meta}
\begingroup
\stex_module_setup:nn{
  ns=\c_stex_metatheory_ns_str,
  meta=NONE
}{Metatheory}
\stex_reactivate_macro:N \symdecl
\stex_reactivate_macro:N \notation
\stex_reactivate_macro:N \symdef
\ExplSyntaxOff
\csname stex_suppress_html:n\endcsname{
  % is-a (a:A, a \in A, a is an A, etc.)
  \symdecl{isa}[args=ai]
  \notation{isa}[typed,op=:]{#1 \comp{:} #2}{##1 \comp, ##2}
  \notation{isa}[in]{#1 \comp\in #2}{##1 \comp, ##2}
  \notation{isa}[pred]{#2\comp(#1 \comp)}{##1 \comp, ##2}

  % bind (\forall, \Pi, \lambda etc.)
  \symdecl{bind}[args=Bi,assoc=pre]
  \notation{bind}[depfun,prec=nobrackets,op={(\cdot)\;\to\;\cdot}]{\comp( #1 \comp{)\;\to\;} #2}{##1 \comp, ##2}
  \notation{bind}[forall]{\comp\forall #1.\;#2}{##1 \comp, ##2}
  \notation{bind}[Pi]{\comp\prod_{#1}#2}{##1 \comp, ##2}

  % implicit bind
  \symdecl{implicitbind}[args=Bi,assoc=pre]
  \notation{implicitbind}[braces,prec=nobrackets,op={\{\cdot\}_I\;\cdot}]{\comp\{ #1 \comp{\}_I\;} #2}{##1 \comp, ##2}
  \notation{implicitbind}[depfun,prec=nobrackets]{\comp( #1 \comp{)\;\to_I\;} #2}{##1 \comp, ##2}
  \notation{implicitbind}[Pi]{\comp\prod^I_{#1}#2}{##1\comp,##2}

  % dummy variable
  \symdecl{dummyvar}
  \notation{dummyvar}[underscore]{\comp\_}
  \notation{dummyvar}[dot]{\comp\cdot}
  \notation{dummyvar}[dash]{\comp{{\rm --}}}

  %fromto (function space, Hom-set, implication etc.)
  \symdecl{fromto}[args=ai]
  \notation{fromto}[xarrow]{#1 \comp\to #2}{##1 \comp\times ##2}
  \notation{fromto}[arrow]{#1 \comp\to #2}{##1 \comp\to ##2}

  % mapto (lambda etc.)
  %\symdecl{mapto}[args=Bi]
  %\notation{mapto}[mapsto]{#1 \comp\mapsto #2}{#1 \comp, #2}
  %\notation{mapto}[lambda]{\comp\lambda #1 \comp.\; #2}{#1 \comp, #2}
  %\notation{mapto}[lambdau]{\comp\lambda_{#1} \comp.\; #2}{#1 \comp, #2}

  % function/operator application
  \symdecl{apply}[args=ia]
  \notation{apply}[prec=0;0x\infprec,parens,op=\cdot(\cdot)]{#1 \comp( #2 \comp)}{##1 \comp, ##2}
  \notation{apply}[prec=0;0x\infprec,lambda]{#1 \; #2 }{##1 \; ##2}

  % collection of propositions/booleans/truth values
  \symdecl{prop}[name=proposition]
  \notation{prop}[prop]{\comp{{\rm prop}}}
  \notation{prop}[BOOL]{\comp{{\rm BOOL}}}

  \symdecl{judgmentholds}[args=1]
  \notation{judgmentholds}[vdash,op=\vdash]{\comp\vdash\; #1}

  % sequences
  \symdecl{seqtype}[args=1]
  \notation{seqtype}[kleene]{#1^{\comp\ast}}

  \symdecl{seqexpr}[args=a]
  \notation{seqexpr}[angle,prec=nobrackets]{\comp\langle #1\comp\rangle}{##1\comp,##2}

  \symdef{seqmap}[args=abi,setlike]{\comp\{#3 \comp| #2\comp\in \dobrackets{#1} \comp\}}{##1 \comp, ##2}
  \symdef{seqprepend}[args=ia]{#1 \comp{::} #2}{##1 \comp, ##2}
  \symdef{seqappend}[args=ai]{#1 \comp{::} #2}{##1 \comp, ##2}
  \symdef{seqfoldleft}[args=iabbi]{ \comp{foldl}\dobrackets{#1,#2}\dobrackets{#3\comp,#4\comp\mapsto#5}}{##1 \comp, ##2}
  \symdef{seqfoldright}[args=iabbi,op=foldr]{ \comp{foldr}\dobrackets{#1,#2}\dobrackets{#3\comp,#4\comp\mapsto#5}}{##1 \comp, ##2}
  \symdef{seqhead}[args=a]{\comp{head}\dobrackets{#1}}{##1 \comp, ##2}
  \symdef{seqtail}[args=a]{\comp{tail}\dobrackets{#1}}{##1 \comp, ##2}
  \symdef{seqlast}[args=a]{\comp{last}\dobrackets{#1}}{##1 \comp, ##2}
  \symdef{seqinit}[args=a]{\comp{tail}\dobrackets{#1}}{##1 \comp, ##2}

  \symdef{sequence-index}[args=2,li,prec=nobrackets]{{#1}_{#2}}
  \notation{sequence-index}[ui,prec=nobrackets]{{#1}^{#2}}

  \symdef{aseqdots}[args=a,prec=nobrackets]{#1\comp{,\ellipses}}{##1\comp,##2}
  \symdef{aseqfromto}[args=ai,prec=nobrackets]{#1\comp{,\ellipses,}#2}{##1\comp,##2}
  \symdef{aseqfromtovia}[args=aii,prec=nobrackets]{#1\comp{,\ellipses,}#2\comp{,\ellipses,}#3}{##1\comp,##2}

  % nat literals
  \symdef{natliteral}{\comp{\mathtt{Ord}}}

  % letin (``let'', local definitions, variable substitution)
  \symdecl{letin}[args=bii]
  \notation{letin}[let]{\comp{{\rm let}}\;#1\comp{=}#2\;\comp{{\rm in}}\;#3}
  \notation{letin}[subst]{#3 \comp[ #1 \comp/ #2 \comp]}
  \notation{letin}[frac]{#3 \comp[ \frac{#2}{#1} \comp]}

  % structures
  \symdecl*{module-type}[args=1]
  \notation{module-type}{\comp{\mathtt{MOD}} #1}
  \symdecl{mathstruct}[name=mathematical-structure,args=a] % TODO
  \notation{mathstruct}[angle,prec=nobrackets]{\comp\langle #1 \comp\rangle}{##1 \comp, ##2}

  % objects
  \symdecl{object}
  \notation{object}{\comp{\mathtt{OBJECT}}}

}


  \ExplSyntaxOn
  \stex_add_to_current_module:n{
    \def\livar{\csname sequence-index\endcsname[li]}
    \def\uivar{\csname sequence-index\endcsname[ui]}
  }
\__stex_modules_end_module:
\endgroup

\str_set:Nn \l_stex_metatheory_str {http://mathhub.info/sTeX/meta?Metatheory}

\NewDocumentCommand \setmetatheory {O{} m}{
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_import_require_module:nnnn
  { \l_stex_import_ns_str } { \l_stex_import_archive_str }
  { \l_stex_import_path_str } { \l_stex_import_name_str }
  \str_set:Nx \l_stex_metatheory_str { \l_stex_import_ns_str ? \l_stex_import_name_str }
  \stex_smsmode_do:
}


%%%%%%%%%%%%%   others.dtx   %%%%%%%%%%%%%

  % None
\NewDocumentCommand \MSC {m} {
  % TODO
}
\@ifpackageloaded{tikzinput}{
  \RequirePackage{stex-tikzinput}
}{}

\bool_if:NT \c_stex_persist_mode_bool {
  \let\__stex_notation_restore_notation_old:nnnnn
    \__stex_notation_restore_notation:nnnnn
  \def\__stex_notation_restore_notation_new:nnnnn#1#2#3#4#5{
    \__stex_notation_restore_notation_old:nnnnn{#1}{#2}{#3}{#4}{#5}
    \ExplSyntaxOn
  }
  \def\__stex_notation_restore_notation:nnnnn{
    \ExplSyntaxOff
    \catcode`~10
    \__stex_notation_restore_notation_new:nnnnn
  }
  \input{\jobname.sms}
  \let\__stex_notation_restore_notation:nnnnn
    \__stex_notation_restore_notation_old:nnnnn
  \prop_if_exist:NT\c_stex_mathhub_main_manifest_prop{
    \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id}
      \l_tmpa_str
    \prop_set_eq:cN { c_stex_mathhub_\l_tmpa_str _manifest_prop }
      \c_stex_mathhub_main_manifest_prop
    \exp_args:Nx \stex_set_current_repository:n { \l_tmpa_str }
  }
}

\stex_get_document_uri:
>>>>>>> main
\endinput
%%
%% End of file `stex.sty'.
