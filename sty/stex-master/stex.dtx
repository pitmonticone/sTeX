%^^A An Infrastructure for Semantic Macros and Module Scoping
%^^A Copyright (c) 2019 Michael Kohlhase, all rights reserved
%^^A               this file is released under the
%^^A               LaTeX Project Public License (LPPL)
%^^A
%^^A The original of this file is in the public repository at 
%^^A http://github.com/sLaTeX/sTeX/
%
%^^A TODO update copyright
%  
% \iffalse
%
%<*driver>
\documentclass{ltxdoc}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[showmods,debug,lang={de,en}]{stex}
\usepackage{url,array,float,textcomp}
\usepackage[show]{ed}
\usepackage[hyperref=auto,style=alphabetic]{biblatex}
\addbibresource{kwarcpubs.bib}
\addbibresource{extpubs.bib}
\addbibresource{kwarccrossrefs.bib}
\addbibresource{extcrossrefs.bib}
\usepackage{listings,amssymb}
\usepackage{amsfonts}
\usepackage{ctangit}
\usepackage{xspace}
\usepackage{hyperref}
\makeindex
\floatstyle{boxed}
\newfloat{exfig}{thp}{lop}
\floatname{exfig}{Example}
\def\githubissue#1{\cite{sTeX:github:on}, \hyperlink{https://github.com/sLaTeX/sTeX/issues/#1}{issue #1}}
\begin{document}
\RecordChanges
\DocInput{stex.dtx}
\end{document} 
%</driver>
% \fi
% 
% \iffalse\CheckSum{802}\fi
% 
% \GetFileInfo{stex.sty}
% 
% \MakeShortVerb{\|}
%\def\scsys#1{{{\sc #1}}\index{#1@{\sc #1}}\xspace}
% \def\xml{\scsys{Xml}}
% \def\mathml{\scsys{MathML}}
% \def\omdoc{\scsys{OMDoc}}
% \def\openmath{\scsys{OpenMath}}
% \def\latexml{\scsys{LaTeXML}}
% \def\perl{\scsys{Perl}}
% \def\cmathml{Content-{\sc MathML}\index{Content {\sc MathML}}\index{MathML@{\sc MathML}!content}}
% \def\activemath{\scsys{ActiveMath}}
% \def\twin#1#2{\index{#1!#2}\index{#2!#1}}
% \def\twintoo#1#2{{#1 #2}\twin{#1}{#2}}
% \def\atwin#1#2#3{\index{#1!#2!#3}\index{#3!#2 (#1)}}
% \def\atwintoo#1#2#3{{#1 #2 #3}\atwin{#1}{#2}{#3}}
% \def\cT{\mathcal{T}}\def\cD{\mathcal{D}}
% \title{{\texttt{stex.sty}}: {\stex2.0}\thanks{Version {\fileversion} (last revised
% {\filedate})}}
% \author{Michael Kohlhase, Dennis M\"uller\\
%    FAU Erlangen-N\"urnberg\\
%    \url{http://kwarc.info/}}
% \maketitle
%
% \makeatletter
% \def\testwrite{\begingroup\catcode`\\=12\catcode`\#=12\catcode`\&=12\testwrite@}
% \def\testwrite@#1{\expandafter\gdef\expandafter\test@content\expandafter{\detokenize{#1}}\expandafter\immediate\expandafter\write\expandafter\testoutfile\expandafter{\test@content}\endgroup}
% \def\testwriteI{\begingroup\catcode`\\=12\catcode`\#=12\catcode`\&=12\testwriteI@}
% \newcount\test@counter\test@counter=0
% \def\testwriteI@#1{\expandafter\gdef\expandafter\test@content\expandafter{\detokenize{#1}}\immediate\write\testoutfile{^^J\detokenize{\advance\test@counter by 1\begingroup\paragraph{Test \the\test@counter:}}\ ^^J}\expandafter\immediate\expandafter\write\expandafter\testoutfile\expandafter{\test@content}\immediate\write\testoutfile{^^J\endgroup^^J}\endgroup\@test}
% \newwrite\testoutfile\immediate\openout\testoutfile=alltests.tex
% \testwrite{\documentclass{article}^^J\usepackage[showmods,debug]{stex}^^J\begin{document}\makeatletter^^J}
% \testwrite{\newcount\test@counter\test@counter=0}
% \def\test{\begingroup\makeatletter\testwriteI}
% \long\def\@test{\global\advance\test@counter by 1\paragraph{\textcolor{blue}{Test \the\test@counter:}}\ \textcolor{blue}{\expandafter\scantokens\expandafter{\test@content}}\endgroup}
% \makeatother
%
%
% \begin{abstract}
%    TODO
% \end{abstract}
%
% \newpage\setcounter{tocdepth}{2}\tableofcontents\newpage
%
% \section{Introduction}\label{sec:intro}
% TODO
%
% \section{Implementation}\label{sec:impl}
%
%\test{
%  \gdef\present#1{\texttt{>>\meaning#1<<}}
%  \gdef\printltx#1{\texttt{\detokenize{#1}}}^^J
%}
%
%    \begin{macrocode}
%    \end{macrocode}
%
% \subsection{The \sTeX document class}
%    \begin{macrocode}
%<*cls>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplClass{stex}{2021/08/01}{1.9}{bla}
%\RequirePackage{xkeyval}
%\DeclareOptionX{lang}{\def\stex@babeloption{#1}}
%\DeclareOptionX*{\PassOptionsToPackage{\CurrentOption}{stex}}
%\ProcessOptionsX
\LoadClass[border=1px,varwidth]{standalone}
\setlength\textwidth{15cm}
\g@addto@macro{\@parboxrestore}{\setlength\parskip{\baselineskip}}

\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{stex}}
\ProcessOptions

\message{^^J\meaning\l_stex_cls_option_clist ^^J}

\RequirePackage{stex}
%</cls>
%    \end{macrocode}
%
% \subsection{Preliminaries}
%
% Pakages and options
%
%    \begin{macrocode}
%<*package>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplPackage{stex}{2021/08/01}{1.9}{bla}

\keys_define:nn { stex } {
  debug     .bool_set:N   = \c_stex_debug_bool ,
  showmods  .bool_set:N   = \c_stex_showmods_bool ,
  lang      .clist_set:N  = \c_stex_languages_clist ,
  mathhub   .tl_set_x:N   = \mathhub ,
  persist   .bool_set:N   = \c_stex_persist_mode_bool
}

\ProcessKeysOptions { stex }

%    \end{macrocode}
%
% The \sTeX logo:
%    \begin{macrocode}
\protected\def\stex{%
  \@ifundefined{texorpdfstring}%
  {\let\texorpdfstring\@firstoftwo}%
  {}%
  \texorpdfstring{\raisebox{-.5ex}S\kern-.5ex\TeX}{sTeX}\xspace%
}
\def\sTeX{\stex}
%    \end{macrocode}
%
% Messages
%
%    \begin{macrocode}
\msg_new:nnn{stex}{debug}{}
\msg_new:nnn{stex}{warning/nomathhub}{
  MATHHUB~system~variable~not~found~and~no~
  \detokenize{\mathhub}-value~set!
}
%    \end{macrocode}
%
% Debug mode
%
%    \begin{macrocode}

\cs_new_protected:Nn \stex_debug:n {
  \bool_if:nT{\c_stex_debug_bool}{
    \exp_args:Nnnx\msg_set:nnn{stex}{debug}{\\Debug:~#1\\}
    \msg_term:nn{stex}{debug} % should be \msg_note:nn
  }
}

\stex_debug:n{Debug~mode~on}
%    \end{macrocode}
%
% Experiments:
%
% Maps as a datatype:
%
%    \begin{macrocode}
\cs_new_protected:Nn \_map_set:nnn {
  \tl_set:cn { __map_#1_value_#2_tl } { #3 }
}
\cs_new_protected:Nn \_map_gset:nnn {
  \tl_gset:cn { __map_#1_value_#2_tl } { #3 }
}
\cs_new_protected:Nn \_map_set:nnN {
  \exp_args:Nnno \_map_set:nnn {#1} {#2} #3
}
\cs_new_protected:Nn \_map_gset:nnN {
  \exp_args:Nnno \_map_gset:nnn {#1} {#2} #3
}
\cs_new_protected:Nn \_map_get:nnN {
  \cs_if_exist:cTF { __map_#1_value_#2_tl } {
    \exp_args:NNNo \exp_args:NNo \tl_set:Nn #3 {
      \use:c { __map_#1_value_#2_tl }
    }
    \exp_args:NNNo \exp_args:NNo \tl_set:Nn #3 { #3 }
  }{
    \tl_clear:N #3
  }
}
\cs_new_protected:Nn \_map_gget:nnN {
  \cs_if_exist:cTF { __map_#1_value_#2_tl } {
    \exp_args:NNNo \exp_args:NNo \tl_set:Nn #3 {
      \use:c { __map_#1_value_#2_tl }
    }
    \exp_args:NNNo \exp_args:NNo \tl_gset:Nn #3 { #3 }
  }{
    \tl_gclear:N #3
  }
}
\protected \def \_map_use:nw  #1 [ #2 ] {
  \exp_args:No \peek_meaning_remove:NTF \c_colon_str {
    \_map_guse:nw { #1 } [ #2 ]
  }{
    \peek_meaning_remove:NTF : {
      \_map_guse:nw { #1 } [ #2 ]
    }{
      \peek_meaning_remove:NTF = {
        \peek_catcode:NTF \relax {
          \_map_set:nnN {#1} {#2}
        } {
          \_map_set:nnn {#1} {#2}
        }
      }{
        \peek_meaning_remove:NTF > {
          \_map_get:nnN {#1} {#2}
        }{
          \use:c { __map_#1_value_#2_tl }
        }
      }
    }
  }
}
\protected \def \_map_guse:nw  #1 [ #2 ] {
  \peek_meaning_remove:NTF = {
    \peek_catcode:NTF \relax {
      \_map_gset:nnN {#1} {#2}
    } {
      \_map_gset:nnn {#1} {#2}
    }
  }{
    \peek_meaning_remove:NTF > {
      \_map_gget:nnN {#1} {#2}
    }{}
  }
}

\cs_new_protected:Nn \map_new:N {
  \exp_args:NNNo \exp_args:NNo \tl_set:Nn #1 { 
    \exp_args:Ne \_map_use:nw { \cs_to_str:N #1 } 
  }
}
\cs_new_protected:Nn \map_gnew:N {
  \exp_args:NNNo \exp_args:NNo \tl_gset:Nn #1 { 
    \exp_args:Ne \_map_use:nw { \cs_to_str:N #1 } 
  }
}
\cs_generate_variant:Nn \map_new:N { c }
\cs_generate_variant:Nn \map_gnew:N { c }
%    \end{macrocode}
%\test{
%  \ExplSyntaxOn
%    \map_new:N\testmap
%    \present\testmap\\
%    \testmap[bla]={narf}
%    \testmap[bla]>\testb
%    \present\testb
%  \ExplSyntaxOff
%}
%
% \subsubsection{\latexml and \ScaLaTeX}
%
%    \begin{macrocode}
\RequirePackage{scalatex}
\ifcsname if@latexml\endcsname\else
    \expandafter\newif\csname if@latexml\endcsname\@latexmlfalse
\fi

\scalatex_add_Namespace:nn{stex}{http://kwarc.info/ns/sTeX}

\prg_new_conditional:Nnn \latexml_if: {p, T, F, TF} {
  \if@latexml
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
%    \end{macrocode}
%
% \subsubsection{HTML Annotations}
%
%    \begin{macrocode}
\tl_new:N \l_stex_annotate_arg_tl
\tl_const:Nx \c_stex_annotate_emptyarg_tl {
  \scalatex_if:TF {
    \scalatex_direct_HTML:n { \c_ampersand_str lrm; }
  }{~}
}

\cs_new_protected:Nn \stex_annotate_checkempty:n {
  \tl_set:Nx \l_stex_annotate_arg_tl { #1 }
  \tl_if_empty:NT \l_stex_annotate_arg_tl {
    \tl_set_eq:NN \l_stex_annotate_arg_tl \c_stex_annotate_emptyarg_tl
  }
}
%    \end{macrocode}
%
% We define four macros for introducing attributes in the HTML
% output. The definitions depend on the ``backend'' used
% (\latexml, \scalatex, \texttt{pdflatex}). 
%
% The \texttt{pdflatex}-macros largely do nothing; the
% \scalatex-implementations are pretty clear in what they do,
%  the \latexml-implementations resort to perl bindings.
%
%    \begin{macrocode}
\scalatex_if:TF{
  \cs_new_protected:Nn \stex_annotate:nnn {
    \stex_annotate_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2"
    } {
      \tl_use:N \l_stex_annotate_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:n {
    \stex_annotate_checkempty:n { #1 }
    \scalatex_annotate_HTML:nn {
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_stex_annotate_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:nnn {
    \stex_annotate_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2" ~
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_stex_annotate_arg_tl
    }
  }
  \NewDocumentEnvironment{stex_annotate_env} { m m } {
    \par
    \scalatex_annotate_HTML_begin:n {
      property="stex:#1" ~
      resource="#2"
    }
  }{
    \scalatex_annotate_HTML_end:
  }
}{
  \latexml_if:TF {
    \cs_new_protected:Nn \stex_annotate:nnn {
      \stex_annotate_checkempty:n { #3 }
      \mode_if_math:TF {
        \cs:w latexml@annotate@math\cs_end:{#1}{#2}{
          \tl_use:N \l_stex_annotate_arg_tl
        }
      }{
        \cs:w latexml@annotate@text\cs_end:{#1}{#2}{
          \tl_use:N \l_stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:n {
      \stex_annotate_checkempty:n { #1 }
      \mode_if_math:TF {
        \cs:w latexml@invisible@math\cs_end:{
          \tl_use:N \l_stex_annotate_arg_tl
        }
      } {
        \cs:w latexml@invisible@text\cs_end:{
          \tl_use:N \l_stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {
      \stex_annotate_checkempty:n { #3 }
      \cs:w latexml@annotate@invisible\cs_end:{#1}{#2}{
        \tl_use:N \l_stex_annotate_arg_tl
      }
    }
    \NewDocumentEnvironment{stex_annotate_env} { m m } {
      \par\begin{latexml@annotateenv}
    }{
      \end{latexml@annotateenv}
    }
  }{
    \cs_new_protected:Nn \stex_annotate:nnn {#3}
    \cs_new_protected:Nn \stex_annotate_invisible:n {}
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {}
    \NewDocumentEnvironment{stex_annotate_env} { m m } {\par}{}
  }
}
%    \end{macrocode}

% \subsubsection{Languages}
%
% We store language abbreviations in two (inverse) maps:
%
%    \begin{macrocode}
\map_new:N \c_stex_languages_map
\map_new:N \c_stex_language_abbrevs_map

\c_stex_languages_map[en] := {english}
\c_stex_languages_map[de] := {ngerman}
\c_stex_languages_map[ar] := {arabic}
\c_stex_languages_map[bg] := {bulgarian}
\c_stex_languages_map[ru] := {russian}
\c_stex_languages_map[fi] := {finnish}
\c_stex_languages_map[ro] := {romanian}
\c_stex_languages_map[tr] := {turkish}
\c_stex_languages_map[fr] := {french}

\c_stex_language_abbrevs_map[english]   := {en}
\c_stex_language_abbrevs_map[ngerman]   := {de}
\c_stex_language_abbrevs_map[arabic]    := {ar}
\c_stex_language_abbrevs_map[bulgarian] := {bg}
\c_stex_language_abbrevs_map[russian]   := {ru}
\c_stex_language_abbrevs_map[finnish]   := {fi}
\c_stex_language_abbrevs_map[romanian]  := {ro}
\c_stex_language_abbrevs_map[turkish]   := {tr}
\c_stex_language_abbrevs_map[french]    := {fr}

% todo: chinese simplified (zhs)
%       chinese traditional (zht)

\clist_if_empty:NF \c_stex_languages_clist {
  \clist_clear:N \l_tmpa_clist
  \clist_map_inline:Nn \c_stex_languages_clist {
    \c_stex_languages_map[#1] > \l_tmpa_str
    \str_if_empty:NT \l_tmpa_str {
      % TODO throw an error
    }
    \clist_put_right:No \l_tmpa_clist \l_tmpa_str
  }
  \stex_debug:n {Languages:~\clist_use:Nn \l_tmpa_clist {,~} }
  \RequirePackage[\clist_use:Nn \l_tmpa_clist ,]{babel}
}

%    \end{macrocode}
%
% \subsection{Files, Paths and URIs}
%
% \subsubsection{Generic Path Handling}
%
% We treat paths as \LaTeX3-sequences (of the individual
% path segments, i.e. separated by a /-character) unix-style;
% i.e. a path is absolute if the sequence starts with an empty 
% entry.
%
%    \begin{macrocode}

%% TODO Windows paths

\cs_new_protected:Nn \stex_path_from_string:Nn {
  \exp_args:NNe\str_set:Nn \l_tmpa_tl { #2 }
  \tl_trim_spaces:N \l_tmpa_tl
  \str_if_empty:NTF \l_tmpa_tl {
    \seq_set_eq:NN #1 \c_empty_seq
  }{
    \exp_args:NNNo \seq_set_split:Nnn #1 / { \l_tmpa_tl }
    \stex_path_canonicalize:N #1
  }
}

\cs_new_protected:Nn \stex_path_to_string:NN {
  \exp_args:NNe \str_set:Nn #2 { \seq_use:Nn #1 / }
}

\cs_new:Nn \stex_path_to_string:N {
  \seq_use:Nn #1 /
}

\str_const:Nn \c_stex_path_dot_str {.}
\str_const:Nn \c_stex_path_up_str {..}
\cs_new_protected:Nn \stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_clear:N \l_tmpa_seq
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NT \l_tmpa_tl {
      \seq_put_right:Nn \l_tmpa_seq {}
    }
    \seq_map_inline:Nn #1 {
      \str_set:Nn \l_tmpa_tl { ##1 }
      \str_if_eq:NNTF \l_tmpa_tl \c_stex_path_dot_str {} {
        \str_if_eq:NNTF \l_tmpa_tl \c_stex_path_up_str {
          \seq_if_empty:NTF \l_tmpa_seq {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
              \c_stex_path_up_str
            }
          }{
            \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
            \str_if_eq:NNTF \l_tmpa_tl \c_stex_path_up_str {
              \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
                \c_stex_path_up_str
              }
            }{
              \seq_pop_right:NN \l_tmpa_seq \l_tmpb_tl
            }
          }
        }{
          \str_if_empty:NF \l_tmpa_tl {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq { \l_tmpa_tl }
          }
        }
      }
    }
    \seq_gset_eq:NN #1 \l_tmpa_seq
  }
}

\prg_new_conditional:Npnn \stex_path_if_absolute:N #1 {p, T, F, TF} {
  \seq_if_empty:NTF #1 {
    \prg_return_false:
  }{
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NTF \l_tmpa_tl {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
%\ExplSyntaxOn\makeatletter
%\test{\ExplSyntaxOn
% \gdef\cpath@print#1{^^A
%    \stex_path_from_string:Nn\l_tmpb_seq{#1}^^A
%    \stex_path_to_string:NN\l_tmpb_seq\l_tmpa_str^^A
%    \str_use:N\l_tmpa_str^^A
%}\ExplSyntaxOff}
%\makeatother\ExplSyntaxOff
% \test{
% \begin{center}
% \begin{tabular}{|l|l|l|}\hline
%   path & canonicalized path & expected\\\hline
%   aaa & \cpath@print{aaa} & aaa \\
%   ../../aaa & \cpath@print{../../aaa} &  ../../aaa\\
%   aaa/bbb & \cpath@print{aaa/bbb} & aaa/bbb \\
%   aaa/.. & \cpath@print{aaa/..} &\\
%   ../../aaa/bbb & \cpath@print{../../aaa/bbb} & ../../aaa/bbb\\
%   ../aaa/../bbb & \cpath@print{../aaa/../bbb} & ../bbb \\
%   ../aaa/bbb & \cpath@print{../aaa/bbb} &  ../aaa/bbb\\
%   aaa/bbb/../ddd & \cpath@print{aaa/bbb/../ddd} & aaa/ddd\\
%   aaa/bbb/./ddd & \cpath@print{aaa/bbb/./ddd} & aaa/bbb/ddd\\
%   ./ & \cpath@print{./} & \\
%   aaa/bbb/../.. & \cpath@print{aaa/bbb/../..} & \\\hline
% \end{tabular}
% \end{center}
% }
%
% \subsubsection{PWD and kpsewhich}
%
% |\stex_kpsewhich:n| executes kpsewhich and stores the return
% in\\ |\l_stex_kpsewhich_return_str|. This does not require
% shell escaping.
%    \begin{macrocode}
\str_new:N\l_stex_kpsewhich_return_str
\cs_new_protected:Nn \stex_kpsewhich:n {
  \sys_get_shell:nnN { kpsewhich ~ #1 } { } \l_tmpa_tl
  \exp_args:NNo\str_set:Nn\l_stex_kpsewhich_return_str{\l_tmpa_tl}
  \tl_trim_spaces:N \l_stex_kpsewhich_return_str
}
%    \end{macrocode}
%
% We determine the PWD
%
%    \begin{macrocode}
\sys_if_platform_windows:TF{
  \stex_kpsewhich:n{-expand-var~\c_percent_str CD\c_percent_str}
}{
  \stex_kpsewhich:n{-var-value~PWD}
}

\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:n {PWD:~\str_use:N\c_stex_pwd_str}
%
%    \end{macrocode}
%
% \subsubsection{File Hooks and Tracking}
%
% We introduce hooks for file inputs that keep track of the
% absolute paths of files used. This will be useful to keep track
% of modules, their archives, namespaces etc.
%
% Note that the absolute paths are only accurate in |\input|-statements
% for paths relative to the PWD, so they shouldn't be relied upon
% in any other setting than for \sTeX-purposes.
%
%    \begin{macrocode}
\seq_gclear_new:N\g_stex_file_stack
\seq_gclear_new:N\g_stex_currentfile_seq
\stex_path_from_string:Nn\c_stex_mainfile_seq{
  \c_stex_pwd_str/\g_file_curr_name_str.tex
}

\AddToHook{file/before}{
  \stex_path_from_string:Nn\g_stex_currentfile_seq{\CurrentFilePath}
  \stex_path_if_absolute:NTF\g_stex_currentfile_seq{
    \exp_args:NNe\seq_put_right:Nn\g_stex_currentfile_seq{\CurrentFile}
  }{
    \stex_path_from_string:Nn\g_stex_currentfile_seq{
      \c_stex_pwd_str/\CurrentFilePath/\CurrentFile
    }
  }
  \seq_gset_eq:NN\g_stex_currentfile_seq\g_stex_currentfile_seq
  \exp_args:NNo\seq_gpush:Nn\g_stex_file_stack\g_stex_currentfile_seq
}
\AddToHook{file/after}{
  \seq_if_empty:NF\g_stex_file_stack{
    \seq_gpop:NN\g_stex_file_stack\l_tmpa_seq
  }
  \seq_if_empty:NTF\g_stex_file_stack{
    \seq_gset_eq:NN\g_stex_currentfile_seq\c_stex_mainfile_seq
  }{
    \seq_get:NN\g_stex_file_stack\l_tmpa_seq
    \seq_gset_eq:NN\g_stex_currentfile_seq\l_tmpa_seq
  }
}
%    \end{macrocode}
%
% \subsubsection{MathHub Repositories}
%
% We determine the path to the local MathHub folder via one of
% three means:
% \begin{enumerate}
%   \item The |\mathhub|-macro, if it has been defined before
%     the |\usepackage{stex}|-statement,
%   \item the |mathhub| package option, or
%   \item the |MATHHUB| system variable.
% \end{enumerate}  
% 
%    \begin{macrocode}
\str_if_empty:NTF\mathhub{
  \stex_kpsewhich:n{-var-value~MATHHUB}
  \str_set_eq:NN\c_stex_mathhub_str\l_stex_kpsewhich_return_str
  
  \str_if_empty:NTF\c_stex_mathhub_str{
    \msg_warning:nn{stex}{warning/nomathhub}
  }{
    \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
    \stex_path_from_string:Nn\c_stex_mathhub_seq\c_stex_mathhub_str
  }
}{
  \stex_path_from_string:Nn\c_stex_mathhub_seq\mathhub
  \stex_path_to_string:NN\c_stex_mathhub_seq\c_stex_mathhub_str
}
%    \end{macrocode}
%
% The next two methods find and parse the |MANIFEST.MF| file
% of an \sTeX/MMT-repository, respectively.
%
% Stores the file path in |\l_stex_mathhub_manifest_file_seq|:
%
%    \begin{macrocode}
\str_new:N\l_stex_mathhub_manifest_file_seq

\cs_new_protected:Nn \stex_find_manifest:N {
  \seq_set_eq:NN\l_tmpa_seq #1
  \bool_set_true:N\l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_if_empty:NTF \l_tmpa_seq {
      \bool_set_false:N\l_tmpa_bool
    }{
      \file_if_exist:nTF{
        \stex_path_to_string:N\l_tmpa_seq/MANIFEST.MF
      }{
        \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
        \bool_set_false:N\l_tmpa_bool
      }{
        \file_if_exist:nTF{
          \stex_path_to_string:N\l_tmpa_seq/META-INF/MANIFEST.MF
        }{
          \seq_put_right:Nn\l_tmpa_seq{META-INF}
          \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
          \bool_set_false:N\l_tmpa_bool
        }{
          \file_if_exist:nTF{
            \stex_path_to_string:N\l_tmpa_seq/meta-inf/MANIFEST.MF
          }{
            \seq_put_right:Nn\l_tmpa_seq{meta-inf}
            \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
            \bool_set_false:N\l_tmpa_bool
          }{
            \seq_pop_right:NN\l_tmpa_seq\l_tmpa_tl
          }
        }
      }
    }
  }
  \seq_set_eq:NN\l_stex_mathhub_manifest_file_seq\l_tmpa_seq
}
%    \end{macrocode}
%
% Stores the entries in manifest file in the map\\
% |\c_stex_archive_<ID>_manifest_map| and the id in 
% |\l_stex_manifest_id_str|:
%    \begin{macrocode}
\ior_new:N \c_stex_manifest_ior
\str_new:N \l_stex_manifest_id_str
\cs_new_protected:Nn \stex_parse_manifest:N {
  \seq_set_eq:NN \l_tmpa_seq #1
  \ior_open:Nn \c_stex_manifest_ior {\stex_path_to_string:N \l_tmpa_seq}
  \ior_map_inline:Nn \c_stex_manifest_ior {
    \str_set:Nn \l_tmpa_str {##1}
    \exp_args:NNoo \seq_set_split:Nnn 
        \l_tmpb_seq \c_colon_str \l_tmpa_str
    \seq_pop_left:NNTF \l_tmpb_seq \l_tmpa_tl {
      \exp_args:NNe \str_set:Nn \l_tmpb_tl { 
        \exp_args:NNo \seq_use:Nn \l_tmpb_seq \c_colon_str 
      }
      \exp_args:No \str_case:nnTF \l_tmpa_tl {
        {id} { 
          \map_gnew:c { c_stex_archive_\l_tmpb_tl _manifest_map }
          \exp_args:NNo \str_set:Nn \l_stex_manifest_id_str { 
            \l_tmpb_tl 
            }
          \use:c { c_stex_archive_\l_tmpb_tl _manifest_map } 
              [id] := \l_tmpb_tl
        }
        {narration-base} {
          \use:c { 
            c_stex_archive_\l_stex_manifest_id_str _manifest_map 
            } [narr] := \l_tmpb_tl
        }
        {source-base} { 
          \use:c { 
            c_stex_archive_\l_stex_manifest_id_str _manifest_map 
          } [ns] := \l_tmpb_tl
        }
        {ns} { 
          \use:c { 
            c_stex_archive_\l_stex_manifest_id_str _manifest_map 
          } [ns] := \l_tmpb_tl
        }
        {dependencies} {
          \use:c { 
            c_stex_archive_\l_stex_manifest_id_str _manifest_map 
          } [deps] := \l_tmpb_tl
        }
      }{}{}
    }{}
  }
  \ior_close:N \c_stex_manifest_ior
}

%    \end{macrocode}
% 
% \test{
%  \global\newwrite\testfile
%  \immediate\openout\testfile=./tests/FOO/META-INF/MANIFEST.MF
%  \immediate\write\testfile{id: FOO/BAR}
%  \immediate\write\testfile{ns: http://mathhub.info/FOO/BAR}
%  \immediate\closeout\testfile
%  \csname stex_path_from_string:Nn\endcsname\mhtest{\csname c_stex_pwd_str\endcsname/tests/FOO/source}
%  In: \\\csname stex_path_to_string:N\endcsname\mhtest:\\
%  \csname stex_find_manifest:N\endcsname\mhtest
%  Manifest file: \\\csname stex_path_to_string:N\expandafter\endcsname\csname l_stex_mathhub_manifest_file_seq\endcsname\\
%  \csname stex_parse_manifest:N\expandafter\endcsname\csname l_stex_mathhub_manifest_file_seq\endcsname\ \\
%  id: \csname c_stex_archive_FOO/BAR_manifest_map\endcsname[id]\ \\
%  narr: \csname c_stex_archive_FOO/BAR_manifest_map\endcsname[narr]\ \\
%  ns: \csname c_stex_archive_FOO/BAR_manifest_map\endcsname[ns]\ \\
%  deps: \csname c_stex_archive_FOO/BAR_manifest_map\endcsname[deps]\ \\
% }
%
% The current repository, a method for setting its info and a hook
% for setting it at |\begin{document}|:
%
%    \begin{macrocode}
\map_new:N \l_stex_current_repository_map

\cs_new_protected:Nn \stex_set_current_repository:n {
  \tl_set_eq:Nc \l_stex_current_repository_map { 
    c_stex_archive_#1_manifest_map 
  }
}


\AddToHook{begindocument}{
  \stex_find_manifest:N \c_stex_pwd_seq
  \seq_if_empty:NTF \l_stex_mathhub_manifest_file_seq {
    \stex_debug:n{Not~currently~in~a~MathHub~repository}
  } {
    \stex_parse_manifest:N \l_stex_mathhub_manifest_file_seq
    \stex_set_current_repository:n \l_stex_manifest_id_str
    \stex_debug:n{Current~repository:~
      \l_stex_current_repository_map[id]
    }
  }
}
%    \end{macrocode}
%
% \subsection{Module System}
%
% A module is stored as a map. |\l_stex_current_module_map|
% points to the current module (if existent).
%
% Most importantly, the |[content]|-field stores all the code
% to execute on activation; i.e. when this module is being included
%
%    \begin{macrocode}
\map_new:N \l_stex_current_module_map
%name:      _str
%ns:        _str
%imports:   _seq
%constants: _seq
%content:   _tl
%file:      _seq
%lang:      _str
%sig:       _str
%meta:      _str

\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \l_stex_current_module_map[name] > \l_tmpa_str
  \str_if_empty:NTF \l_tmpa_str \prg_return_false: \prg_return_true:
}

\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \str_set:Nx \l_tmpa_str { #1 }
  \cs_if_exist_p:cTF { c_stex_module_\l_tmpa_str }
    \prg_return_true: \prg_return_false:
}

\cs_new_protected:Nn \stex_add_to_current_module:n {
  \tl_set_eq:Nn \l_tmpa_tl { #1 }
  \l_stex_current_module_map[content] > \l_tmpb_tl
  \tl_put_right:NV \l_tmpb_tl \l_tmpa_tl
  \l_stex_current_module_map[content] := \l_tmpb_tl
}

\cs_new_protected:Nn \stex_add_constant_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \l_stex_current_module_map[constants] > \l_tmpb_seq
  \tl_put_right:NV \l_tmpb_seq \l_tmpa_str
  \l_stex_current_module_map[constants] := \l_tmpb_seq
}

\cs_new_protected:Nn \stex_add_import_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \l_stex_current_module_map[imports] > \l_tmpb_seq
  \tl_put_right:NV \l_tmpb_seq \l_tmpa_str
  \l_stex_current_module_map[imports] := \l_tmpb_seq
}
%    \end{macrocode}
%
% \subsubsection{SMS Mode}
%
% ``SMS Mode'' is used when loading modules from external tex files.
% It deactivates any output and ignores all \TeX\ commands
% not explicitly allowed via the following lists:
%    \begin{macrocode}
% macros that are executed as is
\tl_new:N \g_stex_smsmode_allowedmacros_tl
% macros that are executed with category codes restored
\tl_new:N \g_stex_smsmode_allowedmacros_escape_tl
% environments (\begin is always executed with 
% category codes restored)
\seq_new:N \g_stex_smsmode_allowedenvs_seq

\tl_set:Nn \g_stex_smsmode_allowedmacros_tl {
  \makeatletter
  \makeatother
}

\tl_set:Nn \g_stex_smsmode_allowedmacros_escape_tl {
%  \symdef
%  \abbrdef
%  \module@export
%  \importmodule
%  \mmt@symdecl
%  \instantiates
%  \setnotation
%  \importmhmodule
%  \gimport
%  \symvariant
%  \structural@feature
%  \symi
%  \symii
%  \symiii
%  \symiv
%  \notation
%  \symdecl
%  \defi
%  \defii
%  \defiii
%  \defiv
%  \adefi
%  \adefii
%  \adefiii
%  \adefiv
%  \defis
%  \defiis
%  \defiiis
%  \defivs
%  \Defi
%  \Defii
%  \Defiii
%  \Defiv
%  \Defis
%  \Defiis
%  \Defiiis
%  \Defivs
}

\exp_args:NNx \seq_set_from_clist:Nn \g_stex_smsmode_allowedenvs_seq {
  \tl_to_str:n {
    module,
    @module
%   modsig,
%   mhmodsig,
%   mhmodnl,
%   modnl,
%   @structural@feature
  }
}
%    \end{macrocode}
%
% Conditionals for SMS mode and corresponding catcodes:
%
%    \begin{macrocode}
\bool_new:N \g_stex_smsmode_bool
\bool_set_false:N \g_stex_smsmode_bool
\bool_new:N \g_stex_smsmode_catcode_bool
\bool_set_false:N \g_stex_smsmode_catcode_bool

\prg_new_conditional:Nnn \stex_if_smsmode_catcodes: { p, T, F, TF } {
  \bool_if:NTF \g_stex_smsmode_catcode_bool 
    \prg_return_true: \prg_return_false:
}

\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g_stex_smsmode_bool \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
%
% Turn on/off SMS mode and set category codes accordingly:
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_smsmode_set_codes: {
  \stex_if_smsmode:T {
    \stex_if_smsmode_catcodes:F {
      \bool_gset_true:N \g_stex_smsmode_catcode_bool
      \exp_after:wN \char_gset_active_eq:NN 
        \c_backslash_str \stex_smsmode_cs:
      \tex_global:D \char_set_catcode_active:N \\
      \tex_global:D \char_set_catcode_other:N $
      \tex_global:D \char_set_catcode_other:N ^
      \tex_global:D \char_set_catcode_other:N _
      \tex_global:D \char_set_catcode_other:N &
      \tex_global:D \char_set_catcode_other:N ##
    }
  }
}

\cs_new_protected:Nn \stex_smsmode_unset_codes: {
  \stex_if_smsmode_catcodes:T {
    \bool_gset_false:N \g_stex_smsmode_catcode_bool
    \exp_after:wN \tex_global:D \exp_after:wN 
      \char_set_catcode_escape:N \c_backslash_str
    \tex_global:D \char_set_catcode_math_toggle:N $
    \tex_global:D \char_set_catcode_math_superscript:N ^
    \tex_global:D \char_set_catcode_math_subscript:N _
    \tex_global:D \char_set_catcode_alignment:N &
    \tex_global:D \char_set_catcode_parameter:N ##
  }
}

\cs_new_protected:Nn \stex_in_smsmode:nn {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_eq:cN { l_stex_smsmode_#1_bool } \g_stex_smsmode_bool
    \bool_gset_true:N \g_stex_smsmode_bool
    \stex_smsmode_set_codes:
    #2
    \bool_gset_eq:Nc \g_stex_smsmode_bool { l_stex_smsmode_#1_bool }
    \stex_if_smsmode:F {
      \stex_smsmode_unset_codes:
    }
  }
  \box_clear:N \l_tmpa_box
}
%    \end{macrocode}
%
% |\stex_smsmode_cs:| is executed on encountering |\| in smsmode.
% It checks whether the corresponding command is allowed and executes
% or ignores it accordingly:
%
%    \begin{macrocode}
\str_const:Nn \c_stex_begin_str { begin }
\str_const:Nn \c_stex_end_str { end }

\cs_new_protected:Nn \stex_smsmode_cs: {
  \str_clear:N \l_tmpa_str
  \peek_analysis_map_inline:n {
    % #1: token (one expansion)
    % #2: charcode
    % #3 catcode
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpa_str { ##1 }
    } {
      \str_if_empty:NTF \l_tmpa_str {
        % we don't allow (or need) single non-letter CSs
        % for now
        \peek_analysis_map_break: 
      }{
        \str_if_eq:nnTF \l_tmpa_str \c_stex_begin_str {
          \peek_analysis_map_break:n { 
            \exp_after:wN \stex_smsmode_checkbegin:n ##1
          }
        } {
          \str_if_eq:nnTF \l_tmpa_str \c_stex_end_str {
            \peek_analysis_map_break:n { 
              \exp_after:wN \stex_smsmode_checkend:n ##1
            }
          } {
          \tl_set:Nn \l_tmpa_tl { \use:c{\l_tmpa_str} }
          \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
            \g_stex_smsmode_allowedmacros_tl 
              { \use:c{\l_tmpa_str} } {
              \peek_analysis_map_break:n { 
                \exp_after:wN \l_tmpa_tl ##1
              }
            } {
              \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
              \g_stex_smsmode_allowedmacros_escape_tl 
                { \use:c{\l_tmpa_str} } {
                \exp_args:NNNo \exp_args:No 
                \token_if_eq_charcode_p:NNTF \c_backslash_str ##1 {
                  \peek_analysis_map_break:n {
                    \stex_smsmode_unset_codes:
                    \stex_smsmode_rescan_cs:
                  }
                } {
                  \peek_analysis_map_break:n {
                    \stex_smsmode_unset_codes:
                    \exp_after:wN \l_tmpa_tl ##1
                  }
                }
              } {
                \peek_analysis_map_break:n { ##1 }
              }
            }
          }
        }
      }
    }
  }
}
%    \end{macrocode}
%
% If the last token gobbled by |\stex_smsmode_cs:| happened to be
% a |\|, we need to rescan the cs name and reinsert it into the input
% stream:
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_smsmode_rescan_cs: {
  \str_clear:N \l_tmpb_str
  \peek_analysis_map_inline:n {
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpb_str { ##1 }
    } {
      \peek_analysis_map_break:n {
        \exp_after:wN \use:c \exp_after:wN { 
          \exp_after:wN \l_tmpa_str\exp_after:wN 
        } \use:c { \l_tmpb_str \exp_after:wN } ##1
      }
    }
  }
}

\cs_new_protected:Nn \stex_smsmode_checkbegin:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \stex_smsmode_unset_codes:
    \begin{#1}
  }
}
\cs_new_protected:Nn \stex_smsmode_checkend:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \end{#1}
  }
}
%    \end{macrocode}
%\test{
% \immediate\openout\testfile=./tests/sometest.tex
% \immediate\write\testfile{\detokenize{\this is \a test}^^J}
% \immediate\write\testfile{\detokenize{this \is a \test}}
% \immediate\closeout\testfile
% \csname stex_in_smsmode:nn\endcsname { foo } { 
%   \input{tests/sometest.tex} 
% }  
%}
%
%
%
%
%
%
%
%
% \subsubsection{The module environment}
%
% |module| arguments:
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_module_initialize:n {
  \map_gnew:c { c_stex_module_#1 }
  \tl_set_eq:Nc \l_stex_current_module_map { c_stex_module_#1 }
  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \l_stex_current_module_map[import]    := \l_tmpa_seq
  \l_stex_current_module_map[constants] := \l_tmpa_seq
  \l_stex_current_module_map[content]   := \l_tmpa_tl
  \l_stex_current_module_map[file]      := \g_stex_currentfile_seq
  \l_stex_current_module_map[lang]      := \l_tmpa_str
  \l_stex_current_module_map[sig]       := \l_tmpa_str
  \l_stex_current_module_map[meta]      := \l_tmpa_str
}
%    \end{macrocode}
%
%
%
%    \begin{macrocode}
\keys_define:nn { stex / module } {
  title .tl_set_x:N  = \l_stex_module_title_str ,
  name  .tl_set_x:N  = \l_stex_module_name_str ,
  ns    .tl_set_x:N  = \l_stex_module_ns_str ,
  lang  .tl_set_x:N  = \l_stex_module_lang_str ,
  sig   .tl_set_x:N  = \l_stex_module_sig_str ,
  meta  .tl_set_x:N  = \l_stex_module_meta_str
}

% module parameters here? In the body?

\cs_new_protected:Nn \stex_modules_args:n {
  \str_clear:N \l_stex_module_title_str
  \str_clear:N \l_stex_module_name_str
  \str_clear:N \l_stex_module_ns_str
  \str_clear:N \l_stex_module_lang_str
  \str_clear:N \l_stex_module_sig_str
  \str_clear:N \l_stex_module_meta_str
  \keys_set:nn { stex / module } { #1 }
  \exp_args:NNo \str_set:Nn \l_stex_module_title_str 
    \l_stex_module_title_str
  \exp_args:NNo \str_set:Nn \l_stex_module_name_str 
    \l_stex_module_name_str
  \exp_args:NNo \str_set:Nn \l_stex_module_ns_str 
    \l_stex_module_ns_str
  \exp_args:NNo \str_set:Nn \l_stex_module_lang_str 
    \l_stex_module_lang_str
  \exp_args:NNo \str_set:Nn \l_stex_module_sig_str 
    \l_stex_module_sig_str
  \exp_args:NNo \str_set:Nn \l_stex_module_meta_str 
    \l_stex_module_meta_str
}
%    \end{macrocode}
%
% Namespace
%
%   To compute the \meta{uri} of a module, 
%  |\stex_modules_current_namespace:| computes the namespace, if
%   none is provided as an optional argument, as follows:
%
%   If the file of the module is |/some/path/file.tex| and we are not in a |MathHub|
%   repository, the namespace is |file:///some/path|.
%
%   If the file of the module is |.../source/sub/file.tex|
%   and |repo/sitory| is an archive in the |MathHub| root, and the |MANIFEST.MF| of
%   |repo/sitory| declares a namespace |http://some.namespace/foo|, then the namespace of
%   the module is |http://some.namespace/foo/sub|.
%
%    \begin{macrocode}
% compute current namespace
\cs_new_protected:Nn \stex_modules_current_namespace: {
  \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
  \seq_pop_right:NN \l_tmpa_seq \l_tmpa_tl
  \l_stex_current_repository_map[ns] > \l_tmpa_str
  \str_if_empty:NTF \l_tmpa_str {
    \str_set:Nx \l_stex_module_ns_str { 
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }{  
    \bool_set_true:N \l_tmpa_bool
    \bool_while_do:Nn \l_tmpa_bool {
      \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
      \exp_args:No \str_case:nnTF { \l_tmpb_str } {
        {source} { \bool_set_false:N \l_tmpa_bool }
      }{}{
        \seq_if_empty:NT \l_tmpa_seq {
          \bool_set_false:N \l_tmpa_bool
          \str_set:Nx \l_tmpb_str { \l_tmpa_str/\l_tmpa_tl }
        }
      }
    }
    \seq_if_empty:NTF \l_tmpa_seq {
      \str_set_eq:NN \l_stex_module_ns_str \l_tmpa_str
    }{
      \str_set:Nx \l_stex_module_ns_str { 
        \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
      }
    }
  }
}
%    \end{macrocode}
%\test{
% \global\let\ex\expandafter
% \ex\let\ex\testa\csname stex_modules_current_namespace:\endcsname
% \ex\let\ex\testb\csname l_stex_module_ns_str\endcsname
% \ex\let\ex\testc\csname stex_set_current_repository:n\endcsname
% \testa
% \ex\let\ex\testb\csname l_stex_module_ns_str\endcsname
% Namespace 1: \testb\\
% Faking a repository:
% \testc{FOO/BAR}
% \csname seq_pop_right:NN\ex\endcsname\csname g_stex_currentfile_seq\endcsname\testtemp
% \edef\testtempb{\detokenize{source}}
% \csname seq_put_right:Nn\ex\endcsname\csname g_stex_currentfile_seq\ex\endcsname\ex{\testtempb}
% \edef\testtempb{\detokenize{test}}
% \csname seq_put_right:Nn\ex\endcsname\csname g_stex_currentfile_seq\ex\endcsname\ex{\testtempb}
% \csname seq_put_right:Nn\ex\endcsname\csname g_stex_currentfile_seq\ex\endcsname\ex{\testtemp}
% \testa
% \ex\let\ex\testb\csname l_stex_module_ns_str\endcsname
% Namespace 2: \testb
%}
%
% Compute module name (if necessary)
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_current_name: {
  % Name
  \str_if_empty:NT \l_stex_module_name_str {
    \int_zero:N \l_tmpa_int
    \seq_get_right:NN \l_tmpa_str \g_stex_currentfile_seq
    \bool_set_true:N \l_tmpa_bool
    \bool_while_do:Nn \l_tmpa_bool {
      \int_incr:N \l_tmpa_int
      \stex_if_module_exists:nF {
        \l_stex_module_ns_str?\l_tmpa_str 
        \int_use:N \l_tmpa_int
      } {
        \bool_set_false:N \l_tmpa_bool
      }
    }
    \exp_args:NNe \str_set_eq:Nn \l_stex_module_name_str
      { \l_tmpa_str \int_use:N \l_tmpa_int }
  }
}
%    \end{macrocode}
%
% The |@module|-environment
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_begin_module:n {
  \par
  \stex_modules_args:n { #1 }
  % Nested module?
  \stex_if_in_module:TF {
    % Nested module
    \l_stex_current_module_map[ns] > \l_stex_module_ns_str
    \stex_modules_current_name:
    \str_set:Nx \l_stex_module_name_str {
      \l_stex_current_module_map[name] / \l_stex_module_name_str
    }
  }{
    % not nested:
    \str_if_empty:NT \l_stex_module_ns_str {
      \stex_modules_current_namespace:
    }
    \stex_modules_current_name:
  }

  % initialize module
  \stex_module_initialize:n { 
    \l_stex_module_ns_str?\l_stex_module_name_str
  }
  \l_stex_current_module_map[ns]   := \l_stex_module_ns_str
  \l_stex_current_module_map[name] := \l_stex_module_name_str

  % language
  \str_if_empty:NTF \l_stex_module_lang_str {
    \clist_if_empty:NF \c_stex_languages_clist {
      \str_set:Nx \l_stex_module_lang_str \languagename
    }
  } {
    \c_stex_languages_map[\l_stex_module_lang_str] > \l_tmpa_str
    \exp_args:Nx \selectlanguage { \l_tmpa_str }
  }
  
  \l_stex_current_module_map[lang] := \l_stex_module_lang_str

  % signature
  \str_if_empty:NF \l_stex_module_sig_str {
    \str_if_empty:NT \l_stex_module_lang_str {
      % TODO throw error
    }

  }
  
  \l_stex_current_module_map[sig] := \l_stex_module_sig_str

  % metatheory
  \str_if_empty:NTF \l_stex_module_meta_str {

  } {

  }

  \stex_debug:n{
    New~module:\\
    Namespace:~\l_stex_module_ns_str\\
    Name:~\l_stex_module_name_str\\
    Language:~\l_stex_module_lang_str\\
    Signature:~\l_stex_module_sig_str\\
    Metatheory:~\l_stex_module_meta_str\\
    File:~\stex_path_to_string:N \g_stex_currentfile_seq
  }
  
  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env} {theory} {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }

    \stex_annotate_invisible:nnn{header}{} {
      \stex_annotate:nnn{language}{ \l_stex_module_lang_str }{}
      \stex_annotate:nnn{signature}{ \l_stex_module_sig_str }{}
      % TODO metatheory
    }
  }
}

\cs_new_protected:Nn \stex_modules_end_module: {
  \stex_if_smsmode:F {
    \end{stex_annotate_env}
  }
}

\NewDocumentEnvironment { @module } { O{} } {
  \stex_modules_begin_module:n { #1 }
} { 
  \stex_modules_end_module:
}
%    \end{macrocode}
%
%\ExplSyntaxOn
%\test{
% \ExplSyntaxOn
% \stex_set_current_repository:n {FOO/BAR}
% \begin{@module}[name=Foo]
%  Module~path:~ 
%  \l_stex_current_module_map[ns]?
%  \l_stex_current_module_map[name]\\
%  Language:~\l_stex_current_module_map[lang]\\
%  Signature:~\l_stex_current_module_map[sig]\\
%  Metatheory:~\l_stex_current_module_map[meta]\\
% \end{@module}
% \ExplSyntaxOff
%}\ExplSyntaxOff
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%
%    \begin{macrocode}
% Tests:


%    \end{macrocode}
%
%
%\testwrite{^^J\end{document}}
%\immediate\closeout\testoutfile
% \endinput