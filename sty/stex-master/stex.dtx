%^^A An Infrastructure for Semantic Macros and Module Scoping
%^^A Copyright (c) 2019 Michael Kohlhase, all rights reserved
%^^A               this file is released under the
%^^A               LaTeX Project Public License (LPPL)
%^^A
%^^A The original of this file is in the public repository at 
%^^A http://github.com/sLaTeX/sTeX/
%
%^^A TODO update copyright
%  
% \iffalse
%
%<*driver>
\documentclass[full,kernel]{l3doc}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[showmods,debug,lang={de,en}, mathhub=./tests]{stex}
\usepackage{url,array,float,textcomp}
\usepackage[show]{ed}
\usepackage[hyperref=auto,style=alphabetic]{biblatex}
\addbibresource{kwarcpubs.bib}
\addbibresource{extpubs.bib}
\addbibresource{kwarccrossrefs.bib}
\addbibresource{extcrossrefs.bib}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{ctangit}
\usepackage{xspace}
\usepackage{hyperref}

\usepackage{morewrites}

\makeindex
\floatstyle{boxed}
\newfloat{exfig}{thp}{lop}
\floatname{exfig}{Example}
\def\githubissue#1{\cite{sTeX:github:on}, \hyperlink{https://github.com/sLaTeX/sTeX/issues/#1}{issue #1}}

\ExplSyntaxOn
\prg_new_conditional:Nnn \stex_indtx: { T } {
  \prg_return_true:
}
\ExplSyntaxOff

\input{stextests.sty}

\begin{document}
\RecordChanges
\DocInput{stex.dtx}
\end{document}
%</driver>
% \fi
% 
% \iffalse\CheckSum{802}\fi
% 
% \GetFileInfo{stex.sty}
% 
% \MakeShortVerb{\|}
%\def\scsys#1{{{\sc #1}}\index{#1@{\sc #1}}\xspace}
% \def\mmt{\textsc{Mmt}\xspace}
% \def\xml{\scsys{Xml}}
% \def\mathml{\scsys{MathML}}
% \def\omdoc{\scsys{OMDoc}}
% \def\openmath{\scsys{OpenMath}}
% \def\latexml{\scsys{LaTeXML}}
% \def\perl{\scsys{Perl}}
% \def\cmathml{Content-{\sc MathML}\index{Content {\sc MathML}}\index{MathML@{\sc MathML}!content}}
% \def\activemath{\scsys{ActiveMath}}
% \def\twin#1#2{\index{#1!#2}\index{#2!#1}}
% \def\twintoo#1#2{{#1 #2}\twin{#1}{#2}}
% \def\atwin#1#2#3{\index{#1!#2!#3}\index{#3!#2 (#1)}}
% \def\atwintoo#1#2#3{{#1 #2 #3}\atwin{#1}{#2}{#3}}
% \def\cT{\mathcal{T}}\def\cD{\mathcal{D}}
% \title{{\texttt{stex.sty}}: {\stex2.0}\thanks{Version {\fileversion} (last revised
% {\filedate})}}
% \author{Michael Kohlhase, Dennis M\"uller\\
%    FAU Erlangen-N\"urnberg\\
%    \url{http://kwarc.info/}}
% \maketitle
%
%
% \begin{abstract}
%    TODO
% \end{abstract}
%
% \section{Introduction}\label{sec:intro}
%     TODO
%
%   \newpage\setcounter{tocdepth}{2}\tableofcontents\newpage
%
%   \section{Manual}
%
% \subsection{Modules}
%
% |{module}|, |{@module}|
%
% \subsection{Semantic Macros and Notations}
%
% Semantic macros invoke a formally declared symbol.
%
% To declare a symbol (in a module), we use \cs{symdecl},
% which takes as argument the name of the corresponding
% semantic macro, e.g. |\symdecl{foo}| introduces the macro
% \cs{foo}. Additionally, \cs{symdecl} takes several options,
% the most important one being its arity. |foo| as declared above
% yields a \emph{constant} symbol. To introduce an \emph{operator}
% which takes arguments, we have to specify which arguments it takes.
%
% \begin{@module}{SemanticMacrosExample}
%   For example, to introduce binary multiplication,
%   we can do |\symdecl[args=2]{mult}|. We can then supply
%   the semantic macro with arbitrarily many notations, such as
%   |\notation{mult}{#1 #2}|.
%   
%   \stexexample{
% \symdecl[args=2]{mult}
% \notation{mult}{#1 #2}
% $\mult{a}{b}$
%}
%
% Since usually, a freshly introduced symbol also comes with a
% notation from the start, the \cs{symdef} command combines
% \cs{symdecl} and \cs{notation}. So instead of the above,
% we could have also written
% \begin{center} |\symdef[args=2]{mult}{#1 #2}| \end{center}
%
% \symdecl[args=2]{mult}
% \notation{mult}{#1 #2}
%
%   \notation[cdot]{mult}{#1 \comp{\cdot} #2}
%   \notation[times]{mult}{#1 \comp{\times} #2}
%   Adding more notations like
%   |\notation[cdot]{mult}{#1 \comp{\cdot} #2}| or 
%   |\notation[times]{mult}{#1 \comp{\times} #2}|
%   allows us to write |$\mult[cdot]{a}{b}$| and
%   |$\mult[times]{a}{b}$|:
%   \stexexample{
%   \notation[cdot]{mult}{#1 \comp{\cdot} #2}
%   \notation[times]{mult}{#1 \comp{\times} #2}
% $\mult[cdot]{a}{b}$ and $\mult[times]{a}{b}$
%}
%   \notation[cdot]{mult}{#1 \comp{\cdot} #2}
%   \notation[times]{mult}{#1 \comp{\times} #2}
%
%   Not using an explicit option with a semantic macro yields
%   the first declared notation, unless changed\ednote{TODO}.
%
%   Outside of math mode, or by using the starred variant
%   |\foo*|, allows to provide a custom notation, where
%   notational (or textual) components can be given
%   explicitly in square brackets.
%   \stexexample{
% $\mult*{a}[\comp{\ast}]{b}$ is the 
% \mult[\comp{product of} ]{$a$}[ \comp{and} ]{$b$}
%}
%
%   In custom mode, prefixing an argument with a star will not
%   print that argument, but still export it to \omdoc:
%   \stexexample{
% \mult[\comp{Multiplying}]*{$\mult{a}{b}$}[ again by ]{$b$} yields...
%}
%   The syntax |*[|\meta{int}|]| allows switching
%   the order of arguments. For example, given a 2-ary semantic
%   macro |\forevery| with exemplary notation
%   |\forall #1. #2|, we can write
%   \stexexample{
%     \symdecl[args=2]{forevery}
%     \forevery*[2]{The proposition $P$}[ \comp{holds for every} ]*[1]{$x\in A$}
%}
%
% When using |*[|$n$|]|, after reading the provided ($n$th) argument,
%  the ``argument counter'' automatically 
% continues where we left off, so the |*[1]| in the above example
% can be omitted.
%
%   For a macro with arity $>0$, we can refer to the operator
%   \emph{itself} semantically by suffixing the semantic macro
%   with an exclamation point |!| in either text or math mode.
%   For that reason \cs{notation} (and thus \cs{symdef}) take an
%   additional optional argument |op=|, which allows to assign
%   a notation for the operator itself. e.g.
%   \stexexample{
%     \symdef[args=2,op={+}]{add}{#1 \comp+ #2}
%     The operator $\add!$ adds two elements, as in $\add ab$.
%   }
%
%  |*| is composable with |!| for custom notations, as in:
%
%   \stexexample{
% \mult![\comp{Multiplication}] (denoted by $\mult*![\comp\cdot]$) is defined by...
%}
%
% The macro \cs{comp} as used everywhere above is responsible
% for highlighting, linking, and tooltips, and should be wrapped
% around the notation (or text) components that should be treated
% accordingly. While it is attractive to just wrap a whole notation,
% this would also wrap around e.g. the arguments themselves, so
% instead, the user is tasked with marking the notation components
% themself.
%
% The precise behaviour of \cs{comp} is governed by
% the macro \cs{@comp}, which takes two arguments: The tex code
% of the text
% (unexpanded) to highlight, and the URI of the current symbol.
% \cs{@comp} can be safely redefined to customize the behaviour.
%
%
% The starred variant |\symdecl*{foo}| does not introduce a semantic
% macro, but still declares a corresponding symbol. |foo| (like
% any other symbol, for that matter) can
% then be accessed via \cs{STEXsymbol}|{foo}| or (if |foo| was declared
% in a module |Foo|) via \cs{STEXModule}|{Foo}?{foo}|.
%
% both \cs{STEXsymbol} and \cs{STEXModule} take any
% arbitrary ending segment of a full URI to determine
% which symbol or module is meant. e.g.
% \cs{STEXsymbol}|{Foo?foo}| is also valid, as are e.g.
% \cs{STEXModule}|{path?Foo}?{foo}| or
% \cs{STEXsymbol}|{path?Foo?foo}|
%
% There's also a convient shortcut \cs{symref}|{?foo}{some text}| for
% \cs{STEXsymbol}|{?foo}![some text]|.
%
% \end{@module}
%
% \subsubsection{Other Argument Types}
%
% So far, we have stated the arity of a semantic macro directly.
% This works if we only have ``normal'' (or more precisely: |i|-type) arguments.
%  To make use of other argument types, instead of providing the arity
% numerically, we can provide it as a sequence of characters representing
% the argument types -- e.g. instead of writing |args=2|, we
% can equivalently write |args=ii|, indicating that the macro
% takes two |i|-type arguments.
%
% Besides |i|-type arguments, \sTeX has two other types, which we will
% discuss now.
%
% The first are \emph{binding} (|b|-type) arguments, representing
% variables that are \emph{bound} by the operator. This is the
% case for example in the above \cs{forevery}-macro:
% The first argument is not actually an argument that the
% |forevery| ``function'' is ``applied'' to; rather, the first argument
% is a new variable (e.g. $x$) that is \emph{bound} in the subsequent
% argument. More accurately, the macro should therefore have been
% implemented thusly:
%   \begin{center}|\symdef[args=bi]{forevery}{\forall #1.\; #2}|\end{center}
%
% \begin{@module}{OtherArgs}
% |b|-type arguments are indistinguishable from |i|-type arguments
% within \sTeX, but are treated very differently in \omdoc and by \mmt.
% More interesting \emph{within} \sTeX are |a|-type arguments,
% which represent (associative) arguments of flexible arity, which are
% provided as comma-separated lists.
% This allows e.g. better representing the \cs{mult}-macro above:
% 
%   \stexexample{
% \symdef[args=a]{mult}{#1}{#1 \comp\cdot #2}
% $\mult{a,b,c,{d^e},f}$
%}
% As the example above shows, notations get a little more complicated
% for associative arguments. For every |a|-type argument, the
% \cs{notation}-macro takes an additional argument that declares
% how individual entries in an |a|-type argument list are aggregated.
% The first notation argument then describes how the aggregated
% expression is combined into the full representation.
%
% For a more interesting example, consider a flexary operator
% for ordered sequences in ordered set, that taking 
% arguments |{a,b,c}| and |\mathbb{R}| prints
% $a \leq b \leq c\in \mathbb R$. This operator takes
% two arguments (an |a|-type argument and an |i|-type argument),
% aggregates the individuals of the associative argument using |\leq|,
% and combines the result with |\in| and the second argument thusly:
%
%   \stexexample{
% \symdef[args=ai]{numseq}{#1 \comp\in #2}{#1 \comp\leq #2}
% $\numseq{a,b,c}{\mathbb R}$
%}
%
% Finally, |B|-type arguments combine the functionalities of |a|
% and |b|, i.e. they represent flexary binding operator arguments.
%
%\ednote{what about e.g. \detokenize{\int_x\int_y\int_z f dx dy dz}?}
%\ednote{``decompose'' a-type arguments into fixed-arity operators?}
%
% \end{@module}
%
% \subsubsection{Precedences}
%
% Every notation has an (upwards) \emph{operator precedence} and
% for each argument a (downwards) \emph{argument precedence}
% used for automated bracketing. For example, a notation
% for a binary operator \cs{foo} could be declared like this:
% \begin{center} |\notation[prec=200;500x600]{foo}{#1 \comp{+} #2}| \end{center}
% assigning an operator precedence of 200, an argument precedence
% of 500 for the first argument, and an argument precedence of 600
% for the second argument.
%
% \sTeX insert brackets thusly: Upon encountering a semantic
% macro (such as \cs{foo}), its operator precedence (e.g. 200)
% is compared to the current downwards precedence (initially 
% \cs{neginfprec}). If the operator precedence is \emph{larger}
% than the current downwards precedence, parentheses are inserted
% around the semantic macro.
%
% Notations for symbols of arity 0 have a default precedence of \cs{infprec},
% i.e. by default, parentheses are never inserted around constants.
% Notations for symbols with arity $>0$ have a default operator
% precedence of $0$.
% If no argument precedences are explicitly provided, then by
% default they are equal to the operator precedence.
%
% Consequently, if some operator $A$ should bind stronger than
% some operator $B$, then $A$s operator precedence should be
% smaller than $B$s argument precedences.
%
% For example:
% \begin{@module}{NotationsEx}
% \symdecl[args=2]{plus}
% \symdecl[args=2]{times}
% \stexexample{
%\notation[prec=100]{plus}{#1 \comp{+} #2}
%\notation[prec=50]{times}{#1 \comp{\cdot} #2}
%$\plus{a}{\times{b}{c}}$ and $\times{a}{\plus{b}{c}}$
%}
%
%
% \end{@module}
%
% \subsection{Archives and Imports}
%
% \subsubsection{Namespaces}
%   Ideally, \sTeX would use arbitrary URIs for modules, with no
%   forced relationships between the \emph{logical} namespace
%   of a module and the \emph{physical} location of the file
%   declaring the module -- like \mmt does things.
%
%   Unfortunately, \TeX\ only provides very restricted access to
%   the file system, so we are forced to generate namespaces
%   systematically in such a way that they reflect the physical
%   location of the associated files, so that \sTeX can resolve
%   them accordingly. Largely, users need not concern themselves
%   with namespaces at all, but for completenesses sake, we describe
%   how they are constructed:
%
%   \begin{itemize}
%     \item If \cs{begin}|{module}{Foo}| occurs in a file
%       |/path/to/file/Foo[.|\meta{lang}|].tex| which does not belong
%       to an archive, the namespace is |file://path/to/file|.
%     \item If the same statement occurs in a file
%       |/path/to/file/bar[.|\meta{lang}|].tex|, the namespace is 
%       |file://path/to/file/bar|.
%   \end{itemize}
%
%   In other words: outside of archives, the namespace corresponds to
%   the file URI with the filename dropped iff it is equal to the
%   module name, and ignoring the (optional) language suffix^^A
%   \footnote{which is internally attached to the module name instead,
%   but a user need not worry about that.}.
%
%   If the current file is in an archive, the procedure is the same
%   except that the initial segment of the file path up to the archive's
%   |source|-folder is replaced by the archive's namespace URI.
%
% \subsubsection{Paths in Import-Statements}
%
% Conversely, here is how namespaces/URIs and file paths are computed
% in import statements, examplary \cs{importmodule}:
%
% \begin{itemize}
%   \item \cs{importmodule}|{Foo}| outside of an archive refers 
%     to module |Foo| in the current namespace. Consequently, |Foo|
%     must have been declared earlier in the same document or, if not,
%     in a file |Foo[.|\meta{lang}|].tex| in the same directory.
%   \item The same statement \emph{within} an archive refers to either
%     the module |Foo| declared earlier in the same document, or
%     otherwise to the module |Foo| in the archive's top-level namespace.
%     In the latter case, is has to be declared in a file |Foo[.|\meta{lang}|].tex|
%     directly in the archive's |source|-folder.
%   \item Similarly, in \cs{importmodule}|{some/path?Foo}| the path
%     |some/path| refers to either the sub-directory and relative 
%     namespace path of the current directory and namespace outside of an archive,
%     or relative to the current archive's top-level namespace and |source|-folder,
%     respectively.
%
%     The module |Foo| must either be declared in the file
%     \meta{top-directory}|/some/path/Foo[.|\meta{lang}|].tex|, or in
%     \meta{top-directory}|/some/path[.|\meta{lang}|].tex| (which are
%     checked in that order).
%   \item Similarly, \cs{importmodule}|[Some/Archive]{some/path?Foo}|
%     is resolved like the previous cases, but relative to the archive
%     |Some/Archive| in the mathhub-directory.
%   \item Finally, \cs{importmodule}|{full://uri?Foo}| naturally refers to the
%     module |Foo| in the namespace |full://uri|. Since the file this module
%     is declared in can not be determined directly from the URI, the module
%     must be in memory already, e.g. by being referenced earlier in the
%     same document.
%
%     Since this is less compatible with a modular development, using full
%     URIs directly is discouraged.
%
% \end{itemize} 
%
%
% \begin{documentation}
%
%   \section{Documentation}
%
%   \subsection{Utils}
%
% \begin{function}{\sTeX , \stex}
%   both print this \stex logo.
% \end{function}
%
% \begin{function}{\stex_debug:n}
%   \begin{syntax}
%     \cs{stex_debug:n} \Arg{message} ^^A \meta{comma list}
%   \end{syntax}
% Logs \meta{message}, if the package option |debug| is used.
% \end{function}
%
% \begin{function}{\stex_kpsewhich:n}
% |\stex_kpsewhich:n| executes kpsewhich and stores the return
% in\\ |\l_stex_kpsewhich_return_str|. This does not require
% shell escaping.
% \end{function}
%
% \begin{function}{\stex_addtosms:n}
% Adds the provided code to the |.sms|-file of the document.
% \end{function}
%
%   \subsubsection{\scalatex, \latexml and HTML Annotations}
%
% \begin{function}{\if@latexml,\latexml_if_p:,\latexml_if:T,\latexml_if:F,\latexml_if:TF}
%   \LaTeX2e and \LaTeX3 conditionals for \latexml.
% \end{function}
%
% We have four macros for annotating generated HTML (via \latexml
% or \scalatex) with attributes:
%
% \begin{function}{\stex_annotate:nnn, \stex_annotate_invisible:nnn,
%   \stex_annotate_invisible:n}
%   \begin{syntax} \cs{stex_annotate:nnn} \Arg{property} \Arg{resource} \Arg{content} \end{syntax}
% Annotates the HTML generated by \meta{content} with\\
% \begin{center}
%  |property="stex:|\meta{property}|", resource="|\meta{resource}|"|.
% \end{center}
%
% \cs{stex_annotate_invisible:n} adds the attributes\\
% \begin{center}
% |stex:visible="false", style="display:none"|.
% \end{center}
%
% \cs{stex_annotate_invisible:nnn} combines the functionality of both.
% \end{function}
%
% \begin{environment}{stex_annotate_env}
%   \begin{syntax} \cs{begin}|{stex_annotate_env}|\Arg{property}\Arg{resource}
%       \meta{content}
%     \cs{end}|{stex_annotate_env}|
%\end{syntax}
% behaves like \cs{stex_annotate:nnn} \Arg{property} \Arg{resource}
%     \Arg{content}.
% \end{environment}
%
%  \subsubsection{Languages}
%
% \begin{variable}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
%   Map language abbreviations to their full babel names and vice versa.
%   e.g. \cs{c_stex_languages_prop}|{en}| yields |english|, and
%   \cs{c_stex_language_abbrevs_prop}|{english}| yields |en|.
% \end{variable}
%
%   \subsection{Files, Paths, URIs}
%
% \begin{function}{\stex_path_from_string:Nn, 
%    \stex_path_from_string:NV,
%    \stex_path_from_string:cn,
%    \stex_path_from_string:cV
%    }
%
%   \begin{syntax} \cs{stex_path_from_string:Nn} \meta{path-variable} \Arg{string} \end{syntax}
%   turns the \meta{string} into a path by splitting it at |/|-characters
%   and stores the result in \meta{path-variable}. Also applies
%   \cs{stex_path_canonicalize:N}.
% \end{function}
%
% \begin{function}{\stex_path_to_string:NN, \stex_path_to_string:N}
%   The inverse; turns a path into a string and stores it in the second
% argument variable, or leaves it in the input stream.
% \end{function}
%
% \begin{function}{\stex_path_canonicalize:N}
%   Canonicalizes the path provided; in particular, resolves |.| and |..|
%   path segments.
% \end{function}
%
% \begin{function}[pTF]{\stex_path_if_absolute:N}
%   Checks whether the path provided is \emph{absolute}, i.e. starts
%   with an empty segment
% \end{function}
%
% \begin{variable}{\c_stex_pwd_seq, \c_stex_pwd_str, \c_stex_mainfile_seq}
%   Store the current working directory as path-sequence and string,
%   respectively, and the (heuristically guessed) full path to the
%   main file, based on the PWD and |\jobname|.
% \end{variable}
%
% \begin{variable}{\g_stex_currentfile_seq}
%   The file being currently processed (respecting |\input| etc.)
% \end{variable}
%
% \stextest{
% \ExplSyntaxOn
% \def\cpath@print#1{
%    \stex_path_from_string:Nn \l_tmpb_seq { #1 }
%    \stex_path_to_string:NN \l_tmpb_seq \l_tmpa_str
%    \str_use:N \l_tmpa_str
%  }
% \ExplSyntaxOff
% \begin{center}
% \begin{tabular}{|l|l|l|}\hline
%   path & canonicalized path & expected\\\hline
%   aaa & \cpath@print{aaa} & aaa \\
%   ../../aaa & \cpath@print{../../aaa} &  ../../aaa\\
%   aaa/bbb & \cpath@print{aaa/bbb} & aaa/bbb \\
%   aaa/.. & \cpath@print{aaa/..} &\\
%   ../../aaa/bbb & \cpath@print{../../aaa/bbb} & ../../aaa/bbb\\
%   ../aaa/../bbb & \cpath@print{../aaa/../bbb} & ../bbb \\
%   ../aaa/bbb & \cpath@print{../aaa/bbb} &  ../aaa/bbb\\
%   aaa/bbb/../ddd & \cpath@print{aaa/bbb/../ddd} & aaa/ddd\\
%   aaa/bbb/./ddd & \cpath@print{aaa/bbb/./ddd} & aaa/bbb/ddd\\
%   ./ & \cpath@print{./} & \\
%   aaa/bbb/../.. & \cpath@print{aaa/bbb/../..} & \\\hline
% \end{tabular}
% \end{center}
% }
%
%
%  \subsection{MathHub Archives}
%
% \begin{variable}{\mathhub, \c_stex_mathhub_seq, \c_stex_mathhub_str}
% We determine the path to the local MathHub folder via one of
% three means, in order of precedence:
% \begin{enumerate}
%   \item The |mathhub| package option, or
%   \item the |\mathhub|-macro, if it has been defined before
%     the |\usepackage{stex}|-statement, or
%   \item the |MATHHUB| system variable.
% \end{enumerate}
% In all three cases, \cs{c_stex_mathhub_seq} and
% \cs{c_stex_mathhub_str} are set accordingly.
% \end{variable}
%
% \begin{variable}{\l_stex_current_repository_prop}
%   Always points to the \emph{current} MathHub repository (if
%   we currently are in one). Has the fields |id|, |ns| (namespace),
%   |narr| (narrative namespace; currently not in use) and
%   |deps| (dependencies; currently not in use).
% \end{variable}
%
% \begin{function}{\stex_set_current_repository:n}
%   Sets the current repository to the one with the provided ID.
%   calls \cs{__stex_mathhub_do_manifest:n}, so works whether this
%   repository's |MANIFEST.MF|-file has already been read or not.
% \end{function}
%
% \begin{function}{\stex_require_repository:n}
%   Calls \cs{__stex_mathhub_do_manifest:n} iff the corresponding
%   archive property list does not already exist, and
%   adds a corresponding definition to the |.sms|-file.
% \end{function}
%
% \begin{function}{\libinput}
%   \begin{syntax} \cs{libinput}\Arg{filename} \end{syntax}
%   Inputs \meta{filename}|.tex| from the |lib| folders in the
%   current archive and the |meta-inf|-archive of the current archive group
%   (if existent). Throws an error if no file by that name exists in
%   either folder, includes both if both exist.
% \end{function}
%
% \stextest{
%  \ExplSyntaxOn
%  \stex_require_repository:n { Foo/Bar }
%  id:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {id}\ \\
%  narr:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {narr}\ \\
%  ns:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {ns}\ \\
%  deps:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {deps}\ \\
% \stex_require_repository:n { Bar/Foo }
%  \ExplSyntaxOff
% }
%
% \subsection{The Module System}
%
% \begin{variable}{\l_stex_current_module_prop}
% All information of a module is stored as a property list. 
% \cs{l_stex_current_module_prop}
% always points to the current module (if existent).
%
% Most importantly, the |content|-field stores all the code
% to execute on activation; i.e. when this module is being included.
%
% Additionally, it stores:
% \begin{itemize}
%   \item The \emph{name} in field |name|,
%   \item the \emph{namespace} in field |ns|,
%   \item this module's \emph{language} in field |lang|,
%   \item if a language module that translates some other
%     modules, the \emph{original} module in field |sig| (for signature),
%   \item the \emph{metatheory} in field |meta|,
%   \item the URIs of all \emph{imported modules} in field |imports|,
%   \item the names of all \emph{declarations} in field |constants|,
%   \item the \emph{file} this module was declared in in field |file|,
% \end{itemize}
% \end{variable}
%
% \begin{function}[pTF]{\stex_if_in_module:}
%   Conditional for whether we are currently in a module
% \end{function}
%
% \begin{function}[pTF]{\stex_if_module_exists:n}
%   Conditional for whether a module with the provided URI
%   is already known.
% \end{function}
%
% \begin{function}{\stex_add_to_current_module:n,\STEXexport}
%   Adds the provided tokens to the |content| field of the current
%   module.
% \end{function}
%
% \begin{function}{\stex_add_constant_to_current_module:n}
%   Adds the declaration with the provided name to the |constants|
%   field of the current module.
% \end{function}
%
% \begin{function}{\stex_add_import_to_current_module:n}
%   Adds the module with the provided full URI to the |imports|
%   field of the current module.
% \end{function}
%
% \begin{function}{\stex_modules_compute_namespace:nN}
%   \begin{syntax} \cs{stex_modules_compute_namespace:nN} 
%     \Arg{namespace} \Arg{path}
%   \end{syntax}
%   Computes the namespace for file \meta{path} in repository
%   with namespace \meta{namespace} as follows:
%
%   If the file is |.../source/sub/file.tex|
%   and the namespace |http://some.namespace/foo|, then the namespace of
%   is |http://some.namespace/foo/sub/file|.
% \end{function}
%
% \begin{function}{\stex_modules_current_namespace:}
%   Computes the current namespace
% \end{function}
%
%\stextest{
% \ExplSyntaxOn
% \stex_modules_current_namespace:
% Namespace~1:\\ \l_stex_modules_ns_str \\
% Faking~a~repository:\\
% \stex_set_current_repository:n{Foo/Bar}
% \seq_pop_right:NN \g_stex_currentfile_seq \testtemp
% \edef\testtempb{\detokenize{source}}
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtempb }
% \edef\testtempb{\detokenize{test}}
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtempb }
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtemp }
% \stex_modules_current_namespace:
% Namespace~2:\\ \l_stex_modules_ns_str
% \ExplSyntaxOff
%}
%
% \subsubsection{The \texttt{module}-environment}
%
% \begin{environment}{module}
%   \begin{syntax} \cs{begin}|{module}[|\meta{options}|]|\Arg{name}\end{syntax}
% 
%   Opens a new module with name \meta{name}.
%
%   TODO document options.
% \end{environment}
%
% \begin{function}{\stex_modules_heading:}
%   Takes care of the module header, if the |showmods| package option
%   is true. This macro can be overridden for customization.
% \end{function}
%
% \begin{environment}{@module}
%   \begin{syntax} \cs{begin}|{@module}[|\meta{options}|]|\Arg{name}\end{syntax}
%
%   Core functionality of the |module|-environment without a header.
%
% \end{environment}
%
%\stextest{
% \ExplSyntaxOn
% \stex_set_current_repository:n {Foo/Bar}
% \seq_pop_right:NN \g_stex_currentfile_seq \l_tmpa_tl
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{tests} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Bar} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{source} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo.tex} }
% \begin{@module}{Foo}
%  Module~path:~ 
%  \prop_item:Nn \l_stex_current_module_prop { ns }?
%  \prop_item:Nn \l_stex_current_module_prop { name }\\
%  Language:~\prop_item:Nn \l_stex_current_module_prop { lang }\\
%  Signature:~\prop_item:Nn \l_stex_current_module_prop { sig }\\
%  Metatheory:~\prop_item:Nn \l_stex_current_module_prop { meta }\\
% \end{@module}
% \ExplSyntaxOff
%}
%
%\stextest{
% \ExplSyntaxOn
% \stex_set_current_repository:n {Foo/Bar}
% \stex_debug:n{Test:~\stex_path_to_string:N \g_stex_currentfile_seq }
% \seq_pop_right:NN \g_stex_currentfile_seq \l_tmpa_tl
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{tests} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Bar} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{source} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo.tex} }
% \stex_debug:n{Test:~\stex_path_to_string:N \g_stex_currentfile_seq }
% \begin{module}[title=Foo Bar]{Bar}
%  Module~path:~ 
%  \prop_item:Nn \l_stex_current_module_prop { ns }?
%  \prop_item:Nn \l_stex_current_module_prop { name }\\
%  Language:~\prop_item:Nn \l_stex_current_module_prop { lang }\\
%  Signature:~\prop_item:Nn \l_stex_current_module_prop { sig }\\
%  Metatheory:~\prop_item:Nn \l_stex_current_module_prop { meta }\\
% \end{module}
% \ExplSyntaxOff
%}
%
% \begin{variable}{\l_stex_all_modules_seq}
%   Stores full URIs for all
%   modules currently in scope.
% \end{variable}
%
% \begin{function}{\STEXModule}
%   \begin{syntax} \cs{STEXModule} \Arg{fragment} \end{syntax}
%   Attempts to find a module whose URI ends with \meta{fragment}
%   in the current scope and passes the full URI on to
%   \cs{stex_invoke_module:n}.
% \end{function}
%
% \begin{function}{\stex_invoke_module:n}
%   Invoked by \cs{STEXModule}. Needs to be followed either
%   by |!|\meta{macro} or |?|\Arg{symbolname}. In the first case,
%   it stores the full URI in \meta{macro}; in the second
%   case, it invokes the symbol \meta{symbolname} in the
%   selected module.
% \end{function}
%
%\stextest{
%   \begin{module}{STEXModuleTest1}
%     \symdecl{foo}
%   \end{module}
%   \begin{module}{STEXModuleTest2}
%     \importmodule{STEXModuleTest1}
%     \symdecl{foo}
%   \end{module}
%   \begin{module}{STEXModuleTest3}
%     \importmodule{STEXModuleTest2}
%     \symdecl{foo}
%     \STEXModule{STEXModuleTest1}!\teststring
%     \teststring\\
%     \STEXModule{STEXModuleTest2}!\teststring
%     \teststring\\
%     \STEXModule{STEXModuleTest3}!\teststring
%     \teststring\\
%     \STEXModule{STEXModuleTest1}?{foo}[\comp{foo1}]\\
%     \STEXModule{STEXModuleTest2}?{foo}[\comp{foo2}]\\
%     \STEXModule{STEXModuleTest3}?{foo}[\comp{foo3}]\\
%   \end{module}
%}
%
%    \subsubsection{SMS Mode}
% ``SMS Mode'' is used when loading modules from external tex files.
% It deactivates any output and ignores all \TeX\ commands
% not explicitly allowed via the following lists:
%
% \begin{variable}{\g_stex_smsmode_allowedmacros_tl}
%   Macros that are executed as is; i.e. with the category code scheme
%   used in SMS mode.
% \end{variable}
%
% \begin{variable}{\g_stex_smsmode_allowedmacros_escape_tl}
%   Macros that are executed with the category codes restored.
%
%   Importantly, these macros need to call \cs{stex_smsmode_set_codes:}
%   after reading all arguments. Note, that 
%   \cs{stex_smsmode_set_codes:} takes
%   care of checking whether we are in SMS mode in the first place, 
%   so calling this function eagerly is unproblematic.
% \end{variable}
%
% \begin{variable}{\g_stex_smsmode_allowedenvs_seq}
%   The names of environments that should be allowed in SMS mode.
%   The corresponding \cs{begin}-statements are treated like
%   the macros in \cs{g_stex_smsmode_allowedmacros_escape_tl}, so
%   \cs{stex_smsmode_set_codes:} should be called at the end of the
%   \cs{begin}-code. Since \cs{end}-statements take no arguments anyway,
%   those are called with the SMS mode category code scheme active.
% \end{variable}
%
% \begin{function}[pTF]{\stex_if_smsmode:}
%   Tests whether SMS mode is currently active.
% \end{function}
%
% \begin{function}{\stex_smsmode_set_codes:}
%   Sets the current category code scheme to that of the SMS mode, if
%   SMS mode is currently active and if necessary.
%
%   This method should be called at the end of every macro or 
%   \cs{begin} environment code that are allowed in SMS mode.
%
% \end{function}
%
% \begin{function}{\stex_in_smsmode:nn}
%   \begin{syntax} \cs{stex_in_smsmode:nn} \Arg{name} \Arg{code} \end{syntax}
%   Executes \meta{code} in SMS mode. \meta{name} can be arbitrary,
%   but should be distinct, since it allows for nesting 
%   \cs{stex_in_smsmode:nn} without spuriously terminating SMS mode.
% \end{function}
%
%\stextest{
% \immediate\openout\testfile=./tests/sometest.tex
% \immediate\write\testfile{\detokenize{\this is \a test}^^J}
% \immediate\write\testfile{\detokenize{this \is a \test}}
% \immediate\closeout\testfile
% \ExplSyntaxOn
% \stex_in_smsmode:nn { foo } { 
%   \input{tests/sometest.tex} 
% }
% \ExplSyntaxOff
%}
%
%
%    \subsubsection{Imports and Inheritance}
%
% \begin{function}{\importmodule}
%   \begin{syntax} \cs{importmodule}|[|\meta{archive-ID}|]|\Arg{module-path} \end{syntax}
%   Imports a module by reading it from a file and ``activating'' it.
%   \sTeX determines the module and its containing file by passing its
%   arguments on to \cs{stex_import_module_path:nn}.
%   
% \end{function}
%
%\stextest{
%   \begin{module}{Foo}
%     \symdecl[name=foo, args=3]{bar}
%     \symdecl[args=bai]{foobar}
%     Meaning:~\present\bar\\
%   \end{module}
%     Meaning:~\present\bar\\
%   \begin{module}{Importtest}
%     \importmodule{Foo}
%     Meaning:~\present\bar\\
%   \end{module}
%   \begin{module}{Importtest2}
%     \importmodule{Importtest}
%     Meaning:~\present\bar\\
%   \end{module}
%}
%
% \begin{function}{\usemodule}
%   \begin{syntax} \cs{importmodule}|[|\meta{archive-ID}|]|\Arg{module-path} \end{syntax}
%   Like \cs{importmodule}, but does not export its contents;
%   i.e. including the current module will not activate the used module
%   
% \end{function}
%
%\stextest{
%   \begin{module}{UseTest1}
%     \symdecl{foo}
%   \end{module}
%   \begin{module}{UseTest2}
%     \usemodule{UseTest1}
%     \symdecl{bar}
%     Meaning:~\present\foo\\
%   \end{module}
%   \begin{module}{UseTest3}
%     \importmodule{UseTest2}
%     Meaning:~\present\foo\\
%     Meaning:~\present\bar\\
%
%     All modules: \ExplSyntaxOn
%       \seq_use:Nn \l_stex_all_modules_seq {,~} \\
%     All~symbols:~
%       \seq_use:Nn \l_stex_all_symbols_seq {,~}
%     \ExplSyntaxOff 
%   \end{module}
%}
%
%
%\stextest{
% Circular dependencies:
% \begin{module}{CircDep1}
%   \importmodule[Foo/Bar]{circular1?Circular1}
%   \importmodule[Bar/Foo]{circular2?Circular2}
%   \present\fooA\\
%   \present\fooB
% \end{module}
%}
%
% \begin{function}{\stex_import_module_uri:nn}
%   \begin{syntax} \cs{stex_import_module_uri:nn} \Arg{archive-ID} \Arg{module-path} \end{syntax}
%   Determines the URI of a module by splitting
%   \meta{module-path} into \meta{path}|?|\meta{name}. If \meta{module-path}
%   does \emph{not} contain a |?|-character, we consider it to be the \meta{name},
%   and \meta{path} to be empty.
%
%   If \meta{archive-ID} is empty, it is automatically set to the
%   ID of the current archive (if one exists).
%
%   \begin{enumerate}
%   \item If \meta{archive-ID} is empty:
%     \begin{enumerate}
%     \item If \meta{path} is empty, then
%         \meta{name} must have been declared earlier in the same file
%         and retrievable from \cs{g_stex_modules_in_file_seq}, or
%         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
%         in the same folder, containing a module \meta{name}.
%
%         That module should have the same namespace as the current one.
%     \item If \meta{path} is not empty, it must point to the relative
%         path of the containing file as well as the namespace.
%     \end{enumerate}
%   \item Otherwise:
%      \begin{enumerate}
%         \item If \meta{path} is empty, then
%         \meta{name} must have been declared earlier in the same file
%         and retrievable from \cs{g_stex_modules_in_file_seq}, or
%         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
%         in the top |source| folder of the archive, 
%         containing a module \meta{name}.
%
%         That module should lie directly in the namespace 
%         of the archive.
%     \item If \meta{path} is not empty, it must point to the
%         path of the containing file as well as the namespace,
%         relative to the namespace of the archive.
%
%         If a module by that namespace exists, it is returned.
%         Otherwise, we call \cs{stex_require_module:nn} 
%         on the |source| directory of the archive to find the
%         file.
%       \end{enumerate}
%   \end{enumerate}
% \end{function}
%
% \begin{function}{\stex_import_require_module:nnnn}
%    \begin{syntax} \Arg{ns} \Arg{archive-ID} \Arg{path} \Arg{name} \end{syntax}
%     Checks whether a module with URI \meta{ns}|?|\meta{name} already
%     exists. If not, it looks for a plausible file that declares
%     a module with that URI.
%
%     Finally, activates that module by executing its |content|-field.
% \end{function}
%
% \begin{variable}{\g_stex_module_files_prop,\g_stex_modules_in_file_seq}
%   A property list mapping file paths to the lists of all modules
%   declared therein. \cs{g_stex_modules_in_file_seq} always points to
%   the current file(-stream - \cs{input}s are considered the same file).
% \end{variable}
%
% \begin{function}{\stex_activate_module:n}
%   Activate the module with the provided URI; i.e. executes
%   all macro code of the module's |content|-field (does
%   nothing if the module is already activated in the current
%   context)
% \end{function}
%
%
% \subsection{Symbols and Terms}
%
% \begin{function}{\symdecl}
%   \begin{syntax} \cs{symdecl}|[|\meta{args}|]|\Arg{macroname} \end{syntax}
%   Declares a new symbol with semantic macro \cs{macroname}. Optional
%   arguments are:
%   \begin{itemize}
%     \item |name|: An (\omdoc) name. By default equal to \meta{macroname}.
%     \item |type|: An (ideally semantic) term. Not used by \sTeX, but
%         passed on to \mmt for semantic services.
%     \item |local|: A boolean (by default false). If set, this declaration
%         will not be added to the module content, i.e. importing
%         the current module will not make this declaration available.
%     \item |args|: Specifies the ``signature'' of the semantic macro.
%       Can be either an integer $0 \leq n \leq 9$, or a (more precise)
%       sequence of the following characters:
%         \begin{itemize}
%           \item[|i|] a ``normal'' argument, e.g.
%             |\symdecl[args=ii]{plus}| allows for |\plus{2}{2}|.
%           \item[|a|] an \emph{associative} argument; i.e. a sequence of
%             arbitrarily many arguments provided as a comma-separated list,
%             e.g.
%             |\symdecl[args=a]{plus}| allows for |\plus{2,2,2}|.
%           \item[|b|] a \emph{variable} argument. Is treated by \sTeX
%             like an |i|-argument, but an application is turned into
%             an |OMBind| in \omdoc, binding the provided variable
%             in the subsequent arguments of the operator; e.g.
%             |\symdecl[args=bi]{forall}| allows for |\forall{x\in\Nat}{x\geq0}|.
%         \end{itemize}
%   \end{itemize}
% \end{function}
%
% \begin{function}{\stex_symdecl_do:n}
%   Implements the core functionality of \cs{symdecl}, and is
%   called by \cs{symdecl} and \cs{symdef}.
%
%   Ultimately stores the symbol \meta{URI} in the property
%   list |\g_stex_symdecl_|\meta{URI}|_prop| with fields:
%   \begin{itemize}
%     \item |name| (string),
%     \item |module| (string),
%     \item |notations| (sequence of strings; initially empty),
%     \item |local| (boolean),
%     \item |type| (token list),
%     \item |args| (string of |i|s, |a|s and |b|s),
%     \item |arity| (integer string),
%     \item |assocs| (integer string; number of associative arguments),
%   \end{itemize}
% \end{function}
%
%\stextest{
%   \begin{module}{SymdeclTest}
%     \symdecl[name=foo, args=3]{bar}
%     \symdecl[name=foobar, args=iab]{bari}
%     \symdecl[def=\bar* abc]{bardef}
%     \ExplSyntaxOn
%       Meaning:~\present\bar\\
%       \stex_get_symbol:n { bar }
%       Result:~\l_stex_get_symbol_uri_str\\
%       Meaning:~\present\bardef\\
%     \ExplSyntaxOff
%   \end{module}
%}
%
% \begin{variable}{\l_stex_all_symbols_seq}
%   Stores full URIs for all
%   modules currently in scope.
% \end{variable}
%
% \begin{function}{\stex_get_symbol:n}
%   Computes the full URI of a symbol from a macro argument, e.g.
%   the macro name, the macro itself, the full URI...
% \end{function}
%
% \begin{function}{\STEXsymbol}
%   Uses \cs{stex_get_symbol:n} to find the symbol denoted by
%   the first argument and passes the result on to
%   \cs{stex_invoke_symbol:n}
% \end{function}
%
% \begin{function}{\symref}
%   \begin{syntax} \cs{symref}\Arg{symbol}\Arg{text} \end{syntax}
%   shortcut for \cs{STEXsymbol}\Arg{symbol}|![|\meta{text}|]|
% \end{function}
%
% \begin{function}{\stex_invoke_symbol:n}
%   Executes a semantic macro. Outside of math mode or if followed by |*|,
%   it continues to \cs{stex_term_custom:nn}. In math mode,
%   it uses the default or optionally provided notation of
%   the associated symbol.
%
%   If followed by |!|, it will invoke the symbol \emph{itself}
%   rather than its application (and continue to
%   \cs{stex_term_custom:nn}), i.e. it allows to refer to
%   |\plus![addition]| as an operation, rather than
%   |\plus[addition of]{some}{terms}|.
% \end{function}
%
% \begin{function}{\notation}
%   \begin{syntax} \cs{notation}|[|\meta{args}|]|\Arg{symbol}\Arg{notations$^+$} \end{syntax}
%   Introduces a new notation for \meta{symbol}, see \cs{stex_notation_do:nn}
% \end{function}
%
% \begin{function}{\stex_notation_do:nn}
%   \begin{syntax} \cs{stex_notation_do:nn}\Arg{URI}\Arg{notations$^+$}\end{syntax}
%
%   Implements the core functionality of \cs{notation}, and is
%   called by \cs{notation} and \cs{symdef}.
%
%   Ultimately stores the notation in the property
%   list\\ |\g_stex_notation_|\meta{URI}|#|\meta{variant}|#|^^A
%   \meta{lang}|_prop| with fields:
%   \begin{itemize}
%     \item |symbol| (URI string),
%     \item |language| (string),
%     \item |variant| (string),
%     \item |opprec| (integer string),
%     \item |argprecs| (sequence of integer strings)
%   \end{itemize}
% \end{function}
%
%\stextest{
%   \begin{module}{NotationTest}
%     \importmodule{Foo}
%     \notation[foo, prec=500;20x20x20]{bar}{\comp\langle {#1 ^ {#2}}_{#3} \comp\rangle }
%     \notation[foo, prec=500;20x20x20]{foobar}{\comp\langle #1 \comp\mid [ #2 ]^{#3} \comp\rangle }{ {#1}_{\comp :#2} }
%   \end{module}
%}
%
% \begin{function}{\symdef}
%   \begin{syntax} \cs{symdef}|[|\meta{args}|]|\Arg{symbol}\Arg{notations$^+$} \end{syntax}
%   Combines \cs{symdecl} and \cs{notation} by introducing a new
%   symbol and assigning a new notation for it.
% \end{function}
%
%\stextest{
%   \begin{module}{SymdefTest}
%     \symdef[args=a, prec=50]{plus}{ #1 }{#1 \comp+ #2}
%     $\plus{a,b,c}$
%   \end{module}
%}
%
% \begin{function}{\_stex_term_math_oms:nnnn,\_stex_term_math_oma:nnnn,\_stex_term_math_omb:nnnn}
%   \begin{syntax} \meta{URI}\meta{fragment}\meta{precedence}\meta{body} \end{syntax}
%
% Annotates \meta{body} as an \omdoc-term (|OMID|, |OMA| or |OMBIND|, respectively) 
% with head symbol \meta{URI}, generated
% by the specific notation \meta{fragment} with (upwards) operator precedence
% \meta{precedence}. Inserts parentheses according to
% the current downwards precedence and operator precedence.
% \end{function}
%
% \begin{function}{\_stex_term_math_arg:nnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th argument of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec}.
% \end{function}
%
% \begin{function}{\_stex_term_math_assoc_arg:nnnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{notation}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th (associative) \emph{sequence} argument
% (as comma-separated list of terms) of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec} and associative
% notation \meta{notation}.
% 
% \end{function}
%
% \begin{variable}{\infprec, \neginfprec}
%   Maximal and minimal notation precedences.
% \end{variable}
%
% \begin{function}{\dobrackets}
%   \begin{syntax} \cs{dobrackets} \Arg{body} \end{syntax}
%   Puts \meta{body} in parentheses; scaled if in display mode
%   unscaled otherwise. Uses the current \sTeX brackets (by default |(| and |)|),
%   which can be changed temporarily using \cs{withbrackets}.
% \end{function}
%
% \begin{function}{\withbrackets}
%   \begin{syntax} \cs{withbrackets} \meta{left} \meta{right} \Arg{body} \end{syntax}
%   Temporarily (i.e. within \meta{body}) sets the brackets used by \sTeX for automated
%   bracketing (by default |(| and |)|) to \meta{left} and \meta{right}.
%
%   Note that \meta{left} and \meta{right} need to be allowed
%   after \cs{left} and \cs{right} in displaymode.
% \end{function}
%
%\stextest{
%  \begin{module}{MathTest1}
%    \importmodule{Foo}
%    \notation[foo, prec=500;20x20x20]{bar}{\comp\langle {#1 ^ {#2}}_{#3} \comp\rangle }
%    $\bar abc$ and $\bar[foo] abc$.
%
%  \end{module}
%}
%
%\stextest{
%  \begin{module}{MathTest2}
%    \importmodule{Foo}
%     \notation[foo, prec=500;20x20x20]{foobar}{\comp\langle #1 \comp\mid [ #2 ]^{#3} \comp\rangle }{ {#1}_{\comp :#2} }
%     $\foobar a{b,c,d,e,f}g$ and $\foobar[foo] a{b,c}g$ and $\foobar abc$
%
%     \symdecl[args=a]{plus}
%     \symdecl[args=a]{mult}
%     \notation[prec=50]{plus}{#1}{#1 \comp+ #2}
%     \notation[prec=100]{mult}{#1}{#1 \comp\cdot #2}
%     $\plus{a,\mult{b,c}}$ and $\mult{a,\plus{\frac ab,\frac ac}}$
%     \[\plus{a,\mult{b,c}}\text{ and }\mult{a,\plus{\frac ab,\frac ac}}\]
%     $\displaystyle \plus{a,\mult{b,c}}$ and 
%     \withbrackets[]{$\displaystyle
%       \mult{a,\plus{\frac ab,\frac ac}}$}
%  \end{module}
%}
%
% \begin{function}{\stex_term_custom:nn}
%   \begin{syntax} \cs{stex_term_custom:nn}\Arg{URI}\Arg{args}\end{syntax}
% Implements custom one-time notation.
% Invoked by \cs{stex_invoke_symbol:n} in text mode, or if
% followed by |*| in math mode, or whenever followed by |!|.
% \end{function}
%
%\stextest{
%  \begin{module}{TextTest}
%    \importmodule{Foo}
%
%    \bar[some ]a[ and some ]b[ and also some ]c[ here].
%
%   $\bar*[\text{some }]a[\text{ and some }]b[\text{ and also some }]c[\text{ here}]$.
%
%   $\bar![\mathtt{bar}]$
%
%   \bar*{a}*{b}[or just some ]c
%
%   \bar![bar]
%
%   \bar[or first ]*[2]{b}[, then ]*[3]{c}[, and finally ]a
%
%  \end{module}
%}
%
% \begin{function}{\stex_highlight_term:nn}
%   \begin{syntax} \cs{stex_highlight_term:nn}\Arg{URI}\Arg{args}\end{syntax}
% Establishes a context for \cs{comp}. Stores the URI in a variable
% so that \cs{comp} knows which symbol governs the current notation.
% \end{function}
%
% \begin{function}{\comp, \@comp, \@defemph}
%   \begin{syntax} \cs{comp}\Arg{args}\end{syntax}
% Marks \meta{args} as a notation component of the current symbol for
% highlighting, linking, etc.
%
% The precise behavior is governed by \cs{@comp}, which takes as
% additional argument the URI of the current symbol. By default,
% \cs{@comp} adds the URI as a PDF tooltip and colors the highlighted part
% in blue.
%
% \cs{@defemph} behaves like \cs{@comp}, and can be similarly redefined,
% but marks an expression as \emph{definiendum} (used by \cs{definiendum})
% \end{function}
%
% \begin{function}{\STEXinvisible}
% Exports its argument as \omdoc (invisible), but does
% not produce PDF output. Useful e.g. for semantic macros
% that take arguments that are not part of the symbolic
% notation.
% \end{function}
%
% \begin{function}{\ellipses}
%   TODO
% \end{function}
%
% \subsection{Structural Features}
%
% \begin{environment}{symboldoc}
%    \begin{syntax} \cs{begin}\Arg{symboldoc}\Arg{symbols} \meta{text} \cs{end}\Arg{symboldoc} \end{syntax}
%  Declares \meta{text} to be a (natural language, encyclopaedic) description
% of \Arg{symbols} (a comma separated list of symbol identifiers).
% \end{environment}
%
% \subsubsection{Structures}
%
% \begin{environment}{structure}
%   TODO
% \end{environment}
%
%\stextest{
% \begin{module}{StructureTest1}
%   \begin{structure}[name=Magma]{magma}
%     \symdef{universe}{\comp M}
%     \symdef[args=2]{op}{#1 \comp\circ #2}
%       $\isa{\op ab}\universe$
%   \end{structure}
%
%     \ExplSyntaxOn
%     \prop_get:NnN \g_stex_last_feature_prop {fields} \l_tmpa_seq
%     \seq_use:Nn \l_tmpa_seq {,}
%     \ExplSyntaxOff
%
%     \present\magma
%
%     \instantiate{magma}[
%       universe ! {{\comp U}},
%       op ! {{#1 \comp+ #2 }}
%     ]{mM}
%     \notation[op = U]{mM/universe}{\comp U}
%     \notation[op = +]{mM/op}{#1 \comp+ #2}
%
%     Test: $\mM{op}ab$
%
%     Test2: $\mM{}$
% \end{module}
%}
%
%
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}\label{sec:impl}
%
% \subsection{The \sTeX document class}
%    \begin{macrocode}
%<*cls>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplClass{stex}{2021/08/01}{1.9}{bla}
\LoadClass[border=1px,varwidth]{standalone}
\setlength\textwidth{15cm}
%\g@addto@macro{\@parboxrestore}{\setlength\parskip{\baselineskip}}

\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{stex}}
\ProcessOptions

\RequirePackage{stex}
%</cls>
%    \end{macrocode}
%
% \subsection{Preliminaries}
%
%    \begin{macrocode}
%<*package>
\RequirePackage{expl3,l3keys2e,ltxcmds}
\ProvidesExplPackage{stex}{2021/08/01}{1.9}{bla}
%    \end{macrocode}
%
% Package options:
%
%    \begin{macrocode}
\keys_define:nn { stex } {
  debug     .bool_set:N   = \c_stex_debug_bool ,
  showmods  .bool_set:N   = \c_stex_showmods_bool ,
  lang      .clist_set:N  = \c_stex_languages_clist ,
  mathhub   .tl_set_x:N   = \mathhub ,
  sms       .bool_set:N   = \c_stex_persist_mode_bool ,
  image     .bool_set:N   = \c_tikzinput_image_bool
}
\ProcessKeysOptions { stex }
%    \end{macrocode}
%
% \begin{macro}{\sTeX}
%   The \sTeX logo:
%
%    \begin{macrocode}
\protected\def\stex{%
  \@ifundefined{texorpdfstring}%
  {\let\texorpdfstring\@firstoftwo}%
  {}%
  \texorpdfstring{\raisebox{-.5ex}S\kern-.5ex\TeX}{sTeX}\xspace%
}
\def\sTeX{\stex}
%    \end{macrocode}
% \end{macro}
%
% Messages
%
%    \begin{macrocode}
\msg_new:nnn{stex}{debug}{}
\msg_new:nnn{stex}{warning/nomathhub}{
  MATHHUB~system~variable~not~found~and~no~
  \detokenize{\mathhub}-value~set!
}
\msg_new:nnn{stex}{error/norepository}{}
%    \end{macrocode}
% 
% \begin{macro}{\stex_debug:n}
%
%   Debug mode
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_debug:n {
  \bool_if:nT{\c_stex_debug_bool}{
    \exp_args:Nnnx\msg_set:nnn{stex}{debug}{\\Debug:~#1\\}
    \msg_term:nn{stex}{debug} % should be \msg_note:nn
  }
}

\stex_debug:n{Debug~mode~on}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{variable}{\c__stex_sms_iow}
%
%   File variable used for the sms-File
%
%    \begin{macrocode}
\iow_new:N \c__stex_sms_iow
\AddToHook{begindocument}{
  \bool_if:NTF \c_stex_persist_mode_bool {
    \ExplSyntaxOn \input{\jobname.sms} \ExplSyntaxOff
  } {
    \iow_open:Nn \c__stex_sms_iow {\jobname.sms}
  }
}
\AddToHook{enddocument}{
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_close:N \c__stex_sms_iow
  }
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_addtosms:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_addtosms:n {
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_now:Nn \c__stex_sms_iow { #1 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\latexml and \ScaLaTeX}
%
%    \begin{macrocode}
\RequirePackage{scalatex}
%    \end{macrocode}
%
% We add the namespace abbreviation |ns:stex="http://kwarc.info/ns/sTeX"| to \scalatex:
%
%    \begin{macrocode}
\scalatex_add_Namespace:nn{stex}{http://kwarc.info/ns/sTeX}
%    \end{macrocode}
%
% \begin{macro}{\if@latexml}
% \begin{macro}[EXP,pTF]{\latexml_if:}
%
% Conditionals for \latexml:
%
%    \begin{macrocode}
\ifcsname if@latexml\endcsname\else
    \expandafter\newif\csname if@latexml\endcsname\@latexmlfalse
\fi

\prg_new_conditional:Nnn \latexml_if: {p, T, F, TF} {
  \if@latexml
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{HTML Annotations}
%    \begin{macrocode}
%<@@=stex_annotate>
%    \end{macrocode}
%
% \begin{variable}{\l_@@_arg_tl, \c_@@_emptyarg_tl}
%
% Used by annotation macros to ensure that the HTML output to annotate
% is not empty.
%
%    \begin{macrocode}
\tl_new:N \l_@@_arg_tl
\tl_const:Nx \c_@@_emptyarg_tl {
  \scalatex_if:TF {
    \scalatex_direct_HTML:n { \c_ampersand_str lrm; }
  }{~}
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_checkempty:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkempty:n {
  \tl_set:Nn \l_@@_arg_tl { #1 }
  \tl_if_empty:NT \l_@@_arg_tl {
    \tl_set_eq:NN \l_@@_arg_tl \c_@@_emptyarg_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{stex_annotate_env}
% \begin{macro}{\stex_annotate:nnn, \stex_annotate_invisible:n,
%    \stex_annotate_invisible:nnn}
%
% We define four macros for introducing attributes in the HTML
% output. The definitions depend on the ``backend'' used
% (\latexml, \scalatex, \texttt{pdflatex}). 
%
% The \texttt{pdflatex}-macros largely do nothing; the
% \scalatex-implementations are pretty clear in what they do,
%  the \latexml-implementations resort to perl bindings.
%
%    \begin{macrocode}
\scalatex_if:TF{
  \cs_new_protected:Nn \stex_annotate:nnn {
    \_@@_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:n {
    \_@@_checkempty:n { #1 }
    \scalatex_annotate_HTML:nn {
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:nnn {
    \_@@_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2" ~
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \NewDocumentEnvironment{stex_annotate_env} { m m } {
    \par
    \scalatex_annotate_HTML_begin:n {
      property="stex:#1" ~
      resource="#2"
    }
  }{
    \scalatex_annotate_HTML_end:
  }
}{
  \latexml_if:TF {
    \cs_new_protected:Nn \stex_annotate:nnn {
      \_@@_checkempty:n { #3 }
      \mode_if_math:TF {
        \cs:w latexml@annotate@math\cs_end:{#1}{#2}{
          \tl_use:N \l_@@_arg_tl
        }
      }{
        \cs:w latexml@annotate@text\cs_end:{#1}{#2}{
          \tl_use:N \l_@@_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:n {
      \_@@_checkempty:n { #1 }
      \mode_if_math:TF {
        \cs:w latexml@invisible@math\cs_end:{
          \tl_use:N \l_@@_arg_tl
        }
      } {
        \cs:w latexml@invisible@text\cs_end:{
          \tl_use:N \l_@@_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {
      \_@@_checkempty:n { #3 }
      \cs:w latexml@annotate@invisible\cs_end:{#1}{#2}{
        \tl_use:N \l_@@_arg_tl
      }
    }
    \NewDocumentEnvironment{stex_annotate_env} { m m } {
      \par\begin{latexml@annotateenv}{#1}{#2}
    }{
      \end{latexml@annotateenv}
    }
  }{
    \cs_new_protected:Nn \stex_annotate:nnn {#3}
    \cs_new_protected:Nn \stex_annotate_invisible:n {}
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {}
    \NewDocumentEnvironment{stex_annotate_env} { m m } {\par}{}
  }
}
%    \end{macrocode}
% \end{macro}
% \end{environment}
%
% \subsubsection{Languages}
%    \begin{macrocode}
%<@@=stex_language>
%    \end{macrocode}
%
% \begin{variable}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
%
% We store language abbreviations in two (mutually inverse) 
% property lists:
%    \begin{macrocode}
\prop_const_from_keyval:Nn \c_stex_languages_prop {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}

\prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}
% todo: chinese simplified (zhs)
%       chinese traditional (zht)
%    \end{macrocode}
% \end{variable}
%
% we use the |lang|-package option to load the corresponding
% babel languages:
%
%    \begin{macrocode}
\clist_if_empty:NF \c_stex_languages_clist {
  \clist_clear:N \l_tmpa_clist
  \clist_map_inline:Nn \c_stex_languages_clist {
    \prop_get:NnNTF \c_stex_languages_prop { #1 } \l_tmpa_str {
      \clist_put_right:No \l_tmpa_clist \l_tmpa_str
    } {
      \msg_set:nnn{stex}{error/unknownlanguage}{
        Unknown~language~\l_tmpa_str
      }
      \msg_error:nn{stex}{error/unknownlanguage}
    }
  }
  \stex_debug:n {Languages:~\clist_use:Nn \l_tmpa_clist {,~} }
  \RequirePackage[\clist_use:Nn \l_tmpa_clist ,]{babel}
}
%    \end{macrocode}
%
% \subsection{Files, Paths and URIs}
%    \begin{macrocode}
%<@@=stex_path>
%    \end{macrocode}
%
% \subsubsection{Generic Path Handling}
%
% We treat paths as \LaTeX3-sequences (of the individual
% path segments, i.e. separated by a /-character) unix-style;
% i.e. a path is absolute if the sequence starts with an empty 
% entry.
%
% \begin{macro}{\stex_path_from_string:Nn, 
%    \stex_path_from_string:NV,
%    \stex_path_from_string:cn,
%    \stex_path_from_string:cV
%    }
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_from_string:Nn {
  \str_set:Nx \l_tmpa_str { #2 }
  \str_if_empty:NTF \l_tmpa_str {
    \seq_clear:N #1
  }{
    \exp_args:NNNo \seq_set_split:Nnn #1 / { \l_tmpa_str }    
    \sys_if_platform_windows:T{
      \seq_clear:N \l_tmpa_tl
      \seq_map_inline:Nn #1 {
        \seq_set_split:Nnn \l_tmpb_tl \c_backslash_str { ##1 }
        \seq_concat:NNN \l_tmpa_tl \l_tmpa_tl \l_tmpb_tl
      }
      \seq_set_eq:NN #1 \l_tmpa_tl
    }
    \stex_path_canonicalize:N #1
  }
}
\cs_generate_variant:Nn \stex_path_from_string:Nn 
  { NV, cn, cV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_path_to_string:NN,\stex_path_to_string:N}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_to_string:NN {
  \exp_args:NNe \str_set:Nn #2 { \seq_use:Nn #1 / }
}

\cs_new:Nn \stex_path_to_string:N {
  \seq_use:Nn #1 /
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\c_@@_dot_str,\c_@@_up_str}
%
% |.| and |..|, respectively.
%
%    \begin{macrocode}
\str_const:Nn \c_@@_dot_str {.}
\str_const:Nn \c_@@_up_str {..}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_path_canonicalize:N}
%
%  Canonicalizes the path provided; in particular, resolves |.| and |..|
%  path segments.
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_clear:N \l_tmpa_seq
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NT \l_tmpa_tl {
      \seq_put_right:Nn \l_tmpa_seq {}
    }
    \seq_map_inline:Nn #1 {
      \str_set:Nn \l_tmpa_tl { ##1 }
      \str_if_eq:NNTF \l_tmpa_tl \c_@@_dot_str {} {
        \str_if_eq:NNTF \l_tmpa_tl \c_@@_up_str {
          \seq_if_empty:NTF \l_tmpa_seq {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
              \c_@@_up_str
            }
          }{
            \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
            \str_if_eq:NNTF \l_tmpa_tl \c_@@_up_str {
              \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
                \c_@@_up_str
              }
            }{
              \seq_pop_right:NN \l_tmpa_seq \l_tmpb_tl
            }
          }
        }{
          \str_if_empty:NF \l_tmpa_tl {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq { \l_tmpa_tl }
          }
        }
      }
    }
    \seq_gset_eq:NN #1 \l_tmpa_seq
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP,pTF]{\stex_path_if_absolute:N}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_path_if_absolute:N {p, T, F, TF} {
  \seq_if_empty:NTF #1 {
    \prg_return_false:
  }{
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NTF \l_tmpa_tl {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{PWD and kpsewhich}
%
% \begin{macro}{\stex_kpsewhich:n}
%    \begin{macrocode}
\str_new:N\l_stex_kpsewhich_return_str
\cs_new_protected:Nn \stex_kpsewhich:n {
  \sys_get_shell:nnN { kpsewhich ~ #1 } { } \l_tmpa_tl
  \exp_args:NNo\str_set:Nn\l_stex_kpsewhich_return_str{\l_tmpa_tl}
  \tl_trim_spaces:N \l_stex_kpsewhich_return_str
}
%    \end{macrocode}
% \end{macro}
%
% We determine the PWD
%
% \begin{variable}{\c_stex_pwd_seq,\c_stex_pwd_str}
%    \begin{macrocode}
\sys_if_platform_windows:TF{
  \stex_kpsewhich:n{-expand-var~\c_percent_str CD\c_percent_str}
}{
  \stex_kpsewhich:n{-var-value~PWD}
}

\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:n {PWD:~\str_use:N\c_stex_pwd_str}
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{File Hooks and Tracking}
%    \begin{macrocode}
%<@@=stex_files>
%    \end{macrocode}
%
% We introduce hooks for file inputs that keep track of the
% absolute paths of files used. This will be useful to keep track
% of modules, their archives, namespaces etc.
%
% Note that the absolute paths are only accurate in |\input|-statements
% for paths relative to the PWD, so they shouldn't be relied upon
% in any other setting than for \sTeX-purposes.
%
% \begin{variable}{\g_@@_stack}
%
% keeps track of file changes
%
%    \begin{macrocode}
\seq_gclear_new:N\g_@@_stack
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_stex_mainfile_seq}
%    \begin{macrocode}
\stex_path_from_string:Nn \c_stex_mainfile_seq {
  \c_stex_pwd_str/\jobname.tex
}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_stex_currentfile_seq}
%
% Hooks for file inputs that push/pop \cs{g_@@_stack} to update
% \cs{c_stex_mainfile_seq}.
%
%    \begin{macrocode}
\seq_gclear_new:N\g_stex_currentfile_seq
\AddToHook{file/before}{
  \stex_path_from_string:Nn\g_stex_currentfile_seq{\CurrentFilePath}
  \stex_path_if_absolute:NTF\g_stex_currentfile_seq{
    \exp_args:NNe\seq_put_right:Nn\g_stex_currentfile_seq{\CurrentFile}
  }{
    \stex_path_from_string:Nn\g_stex_currentfile_seq{
      \c_stex_pwd_str/\CurrentFilePath/\CurrentFile
    }
  }
  \seq_gset_eq:NN\g_stex_currentfile_seq\g_stex_currentfile_seq
  \exp_args:NNo\seq_gpush:Nn\g_@@_stack\g_stex_currentfile_seq
}
\AddToHook{file/after}{
  \seq_if_empty:NF\g_@@_stack{
    \seq_gpop:NN\g_@@_stack\l_tmpa_seq
  }
  \seq_if_empty:NTF\g_@@_stack{
    \seq_gset_eq:NN\g_stex_currentfile_seq\c_stex_mainfile_seq
  }{
    \seq_get:NN\g_@@_stack\l_tmpa_seq
    \seq_gset_eq:NN\g_stex_currentfile_seq\l_tmpa_seq
  }
}
%    \end{macrocode}
% \end{variable}
%
% \subsection{MathHub Repositories}
%    \begin{macrocode}
%<@@=stex_mathhub>
%    \end{macrocode}
%
% \begin{variable}{\mathhub, \c_stex_mathhub_seq, \c_stex_mathhub_str}
%    \begin{macrocode}
\str_if_empty:NTF\mathhub{
  \stex_kpsewhich:n{-var-value~MATHHUB}
  \str_set_eq:NN\c_stex_mathhub_str\l_stex_kpsewhich_return_str
  
  \str_if_empty:NTF\c_stex_mathhub_str{
    \msg_warning:nn{stex}{warning/nomathhub}
  }{
    \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
    \exp_args:NNo \stex_path_from_string:Nn\c_stex_mathhub_seq\c_stex_mathhub_str
  }
}{
  \stex_path_from_string:Nn \c_stex_mathhub_seq \mathhub
  \stex_path_if_absolute:NF \c_stex_mathhub_seq {
    \exp_args:NNx \stex_path_from_string:Nn \c_stex_mathhub_seq {
      \c_stex_pwd_str/\mathhub
    }
  }
  \stex_path_to_string:NN\c_stex_mathhub_seq\c_stex_mathhub_str
  \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
}
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\_@@_do_manifest:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_do_manifest:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_if_exist:cF {c_stex_mathhub_#1_manifest_prop} {
    \prop_new:c { c_stex_mathhub_#1_manifest_prop }
    \seq_set_split:NnV \l_tmpa_seq / \l_tmpa_str
    \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpa_seq
    \_@@_find_manifest:N \l_tmpa_seq
    \seq_if_empty:NTF \l_@@_manifest_file_seq {
      \msg_set:nnn{stex}{error/norepository}{
        No~archive~#1~found~in~
          \stex_path_to_string:N \c_stex_mathhub_str
      }
      \msg_error:nn{stex}{error/norepository}
    } {
      \exp_args:No \_@@_parse_manifest:n { \l_tmpa_str }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_manifest_file_seq}
%    \begin{macrocode}
\str_new:N\l_@@_manifest_file_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_find_manifest:N}
%
% Attempts to find the |MANIFEST.MF| in some file path and
% stores its path in \cs{l_@@_manifest_file_seq}:
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_find_manifest:N {
  \seq_set_eq:NN\l_tmpa_seq #1
  \bool_set_true:N\l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_if_empty:NTF \l_tmpa_seq {
      \bool_set_false:N\l_tmpa_bool
    }{
      \file_if_exist:nTF{
        \stex_path_to_string:N\l_tmpa_seq/MANIFEST.MF
      }{
        \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
        \bool_set_false:N\l_tmpa_bool
      }{
        \file_if_exist:nTF{
          \stex_path_to_string:N\l_tmpa_seq/META-INF/MANIFEST.MF
        }{
          \seq_put_right:Nn\l_tmpa_seq{META-INF}
          \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
          \bool_set_false:N\l_tmpa_bool
        }{
          \file_if_exist:nTF{
            \stex_path_to_string:N\l_tmpa_seq/meta-inf/MANIFEST.MF
          }{
            \seq_put_right:Nn\l_tmpa_seq{meta-inf}
            \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
            \bool_set_false:N\l_tmpa_bool
          }{
            \seq_pop_right:NN\l_tmpa_seq\l_tmpa_tl
          }
        }
      }
    }
  }
  \seq_set_eq:NN\l_@@_manifest_file_seq\l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\c_@@_manifest_ior}
%
%   File variable used for |MANIFEST|-files
%
%    \begin{macrocode}
\ior_new:N \c_@@_manifest_ior
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_parse_manifest:n}
%
% Stores the entries in manifest file in the
% corresponding property list:
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_parse_manifest:n {
  \seq_set_eq:NN \l_tmpa_seq \l_@@_manifest_file_seq
  \ior_open:Nn \c_@@_manifest_ior {\stex_path_to_string:N \l_tmpa_seq}
  \ior_map_inline:Nn \c_@@_manifest_ior {
    \str_set:Nn \l_tmpa_str {##1}
    \exp_args:NNoo \seq_set_split:Nnn 
        \l_tmpb_seq \c_colon_str \l_tmpa_str
    \seq_pop_left:NNTF \l_tmpb_seq \l_tmpa_tl {
      \exp_args:NNe \str_set:Nn \l_tmpb_tl { 
        \exp_args:NNo \seq_use:Nn \l_tmpb_seq \c_colon_str 
      }
      \exp_args:No \str_case:nnTF \l_tmpa_tl {
        {id} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { id } \l_tmpb_tl
        }
        {narration-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { narr } \l_tmpb_tl
        }
        {source-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { ns } \l_tmpb_tl
        }
        {ns} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { ns } \l_tmpb_tl
        }
        {dependencies} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { deps } \l_tmpb_tl
        }
      }{}{}
    }{}
  }
  \ior_close:N \c_@@_manifest_ior
}
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro}{\stex_set_current_repository:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \prop_set_eq:Nc \l_stex_current_repository_prop { 
    c_stex_mathhub_#1_manifest_prop 
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_require_repository:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \stex_debug:n{Opening~archive:~#1}
    \_@@_do_manifest:n { #1 }
    \exp_args:Nx \stex_addtosms:n {
      \prop_const_from_keyval:cn { c_stex_mathhub_#1_manifest_prop } {
        id   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  id  } ,
        ns   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  ns  } ,
        narr = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { narr } ,
        deps = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { deps }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%\begin{variable}{\l_stex_current_repository_prop}
%
% Current MathHub repository
%
%    \begin{macrocode}
\prop_new:N \l_stex_current_repository_prop

\_@@_find_manifest:N \c_stex_pwd_seq
\seq_if_empty:NTF \l_@@_manifest_file_seq {
  \stex_debug:n{Not~currently~in~a~MathHub~repository}
} {
  \_@@_parse_manifest:n { main }
  \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id} 
    \l_tmpa_str
  \prop_set_eq:cN { c_stex_mathhub_\l_tmpa_str _manifest_prop }
    \c_stex_mathhub_main_manifest_prop
  \exp_args:Nx \stex_set_current_repository:n { \l_tmpa_str }
  \stex_debug:n{Current~repository:~
    \prop_item:Nn \l_stex_current_repository_prop {id}
  }
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\inputref}
%    \begin{macrocode}
\newif \ifinputref \inputreffalse

\cs_new_protected:Nn \inputref:nn {
  \str_set:Nx \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \prop_if_empty:NF \l_stex_current_repository_prop {
      \prop_get:NnN \l_stex_current_repository_prop { id } \l_tmpa_str
    }
  } {
    \stex_require_repository:n \l_tmpa_str
    \str_set:Nx \l_tmpa_str { #1 }
  }
  \str_set:Nx \l_tmpa_str { \c_stex_mathhub_str / \l_tmpa_str / source / #2 }
  \ifinputref
    \input{ \l_tmpa_str }
  \else
    \inputreftrue
    \input{ \l_tmpa_str }
    \inputreffalse
  \fi
}
\NewDocumentCommand \inputref { O{} m}{
  \inputref:nn{ #1 }{ #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\mhpath}
%    \begin{macrocode}
  \def \mhpath #1 #2 {
    \str_if_eq:nnTF{#1}{}{
      \c_stex_mathhub_str / 
        \prop_item:Nn \l_stex_current_repository_prop { id }
        / source / #2
    }{
      \c_stex_mathhub_str / #1 / source / #2
    }
  }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\libinput}
%    \begin{macrocode}
\cs_new_protected:Npn \libinput #1 {
  \prop_get:NnNF \l_stex_current_repository_prop {id} \l_tmpa_str {
    \msg_set:nnn{stex}{error/norepository}{
      \c_backslash_str libinput~needs~to~be~called~in~an~archive
    }
    \msg_error:nn{stex}{error/norepository}
  }
  \bool_set_false:N \l_tmpa_bool
  \tl_clear:N \l_tmpa_tl
  \seq_set_eq:NN \l_tmpa_seq \c_stex_mathhub_seq
  \seq_set_split:NnV \l_tmpb_seq / \l_tmpa_str
  \seq_pop_right:NN \l_tmpb_seq \l_tmpa_str
  \seq_pop_left:NNT \l_tmpb_seq \l_tmpb_str {
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq 
      / meta-inf / lib / #1.tex}{
        \bool_set_true:N \l_tmpa_bool
        \tl_put_right:Nx \l_tmpa_tl {
          \exp_not:N \input { \stex_path_to_string:N \l_tmpa_seq 
          / meta-inf / lib / #1.tex}
        }
      }{}
  }
  \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq
    / \l_tmpa_str / lib / #1.tex
  }{
    \bool_set_true:N \l_tmpa_bool
    \tl_put_right:Nx \l_tmpa_tl {
      \exp_not:N \input { \stex_path_to_string:N \l_tmpa_seq 
      / \l_tmpa_str / lib / #1.tex}
    }
  }{}
  \bool_if:NF \l_tmpa_bool {
    \msg_set:nnn{stex}{error/nofile}{
      \c_backslash_str libinput~no~file~#1.tex~found!
    }
    \msg_error:nn{stex}{error/nofile}
  }
  \l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Module System}
%    \begin{macrocode}
%<@@=stex_module>
%    \end{macrocode}
%
% \begin{variable}{\l_stex_current_module_prop}
%    \begin{macrocode}
\prop_new:N \l_stex_current_module_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[pTF]{stex_if_in_module:}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \prop_if_empty:NTF \l_stex_current_module_prop
    \prg_return_false: \prg_return_true:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{stex_if_module_exists:n}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_to_current_module:n,\STEXexport}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \prop_get:NnN \l_stex_current_module_prop { content } \l_tmpa_tl
  \tl_put_right:Nn \l_tmpa_tl { #1 }
  \prop_put:Nno \l_stex_current_module_prop { content } { \l_tmpa_tl }
}
\NewDocumentCommand \STEXexport { m }{
  \stex_smsmode_set_codes:
  \stex_add_to_current_module:n { #1 }
  #1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_constant_to_current_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_constant_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { constants } \l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_import_to_current_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_import_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { imports } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { imports } \l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_modules_compute_namespace:nN}
%
% stores its return values in:
% \begin{variable}{\l_stex_modules_ns_str}
%    \begin{macrocode}
\str_new:N \l_stex_modules_ns_str
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_compute_namespace:nN {
  \str_set:Nx \l_tmpa_str { #1 }
  \seq_set_eq:NN \l_tmpa_seq #2
  % split off file extension
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \bool_set_true:N \l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:No \str_case:nnTF { \l_tmpb_str } {
      {source} { \bool_set_false:N \l_tmpa_bool }
    }{}{
      \seq_if_empty:NT \l_tmpa_seq {
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }

  \seq_if_empty:NTF \l_tmpa_seq {
    \str_set_eq:NN \l_stex_modules_ns_str \l_tmpa_str
  }{
    \str_set:Nx \l_stex_modules_ns_str { 
      \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_modules_current_namespace:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_current_namespace: {
  \prop_get:NnNTF \l_stex_current_repository_prop { ns } \l_tmpa_str {
    \stex_modules_compute_namespace:nN \l_tmpa_str \g_stex_currentfile_seq
  }{
    % split off file extension
    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
    \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \str_set:Nx \l_stex_modules_ns_str { 
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{The module environment}
%
% \begin{variable}{\l_stex_all_modules_seq}
%   Stores all available modules
%    \begin{macrocode}
\seq_new:N \l_stex_all_modules_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\STEXModule,\stex_invoke_module:n}
%    \begin{macrocode}
\NewDocumentCommand \STEXModule { m } {
  \exp_args:NNx \str_set:Nn \l_tmpa_str { #1 }
  \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
  \tl_set:Nn \l_tmpa_tl {
    \msg_set:nnn{stex}{error/unknownmodule}{
      No~module~#1~found!
    }
    \msg_error:nn{stex}{error/unknownmodule}
  }
  \seq_map_inline:Nn \l_stex_all_modules_seq {
    \str_set:Nn \l_tmpb_str { ##1 }
    \str_if_eq:eeT { \l_tmpa_str } {
      \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
    } {
      \seq_map_break:n {
        \tl_set:Nn \l_tmpa_tl {
          \stex_invoke_module:n { ##1 }
        }
      }
    }
  }
  \l_tmpa_tl
}

\cs_new_protected:Nn \stex_invoke_module:n {
  \stex_debug:n{Invoking~module~#1}
  \peek_charcode_remove:NTF ! {
    \_@@_invoke_uri:nN { #1 }
  } {
    \peek_charcode_remove:NTF ? {
      \_@@_invoke_symbol:nn { #1 }
    } {
      \msg_set:nnn{stex}{error/syntax}{
        Syntax~error:~?~or~!~expected~after~
        \c_backslash_str STEXModule{#1}
      }
      \msg_error:nn{stex}{error/syntax}
    }
  }
}

\cs_new_protected:Nn \_@@_invoke_uri:nN {
  \str_set:Nn #2 { #1 }
}

\cs_new_protected:Nn \_@@_invoke_symbol:nn {
  \stex_invoke_symbol:n{#1?#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{module}
%
% |module| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / module } {
  title         .tl_set_x:N  = \l_stex_module_title_str ,
  ns            .tl_set_x:N  = \l_stex_module_ns_str ,
  lang          .tl_set_x:N  = \l_stex_module_lang_str ,
  sig           .tl_set_x:N  = \l_stex_module_sig_str ,
  creators      .tl_set_x:N  = \l_stex_module_creators_str ,
  contributors  .tl_set_x:N  = \l_stex_module_contributors_str ,
  meta          .tl_set_x:N  = \l_stex_module_meta_str
}

% module parameters here? In the body?

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_stex_module_title_str
  \str_clear:N \l_stex_module_ns_str
  \str_clear:N \l_stex_module_lang_str
  \str_clear:N \l_stex_module_sig_str
  \str_clear:N \l_stex_module_creators_str
  \str_clear:N \l_stex_module_contributors_str
  \str_clear:N \l_stex_module_meta_str
  \keys_set:nn { stex / module } { #1 }
  \exp_args:NNo \str_set:Nn \l_stex_module_title_str 
    \l_stex_module_title_str
  \exp_args:NNo \str_set:Nn \l_stex_module_ns_str 
    \l_stex_module_ns_str
  \exp_args:NNo \str_set:Nn \l_stex_module_lang_str 
    \l_stex_module_lang_str
  \exp_args:NNo \str_set:Nn \l_stex_module_sig_str 
    \l_stex_module_sig_str
  \exp_args:NNo \str_set:Nn \l_stex_module_meta_str 
    \l_stex_module_meta_str
  \exp_args:NNo \str_set:Nn \l_stex_module_creators_str 
    \l_stex_module_creators_str
  \exp_args:NNo \str_set:Nn \l_stex_module_contributors_str 
    \l_stex_module_contributors_str
}
%    \end{macrocode}
%
% \begin{macro}{\_@@_begin_module:}
%
%   implements |\begin{module}|
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_begin_module: {
  % Nested module?
  \stex_if_in_module:TF {
    % Nested module
    \prop_get:NnN \l_stex_current_module_prop
      { ns } \l_stex_module_ns_str
    \str_set:Nx \l_stex_module_name_str {
      \prop_item:Nn \l_stex_current_module_prop
        { name } / \l_stex_module_name_str
    }
  }{
    % not nested:
    \str_if_empty:NT \l_stex_module_ns_str {
      \stex_modules_current_namespace:
      \str_set_eq:NN \l_stex_module_ns_str \l_stex_modules_ns_str
      \exp_args:NNNo \seq_set_split:Nnn \l_tmpa_seq
         / {\l_stex_module_ns_str}
      \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
      \str_if_eq:NNT \l_tmpa_str \l_stex_module_name_str {
        \str_set:Nx \l_stex_module_ns_str {
          \stex_path_to_string:N \l_tmpa_seq
        }
      }
    }
  }

  % language
  \str_if_empty:NT \l_stex_module_lang_str {
    \seq_get_right:NN \g_stex_currentfile_seq \l_tmpa_str
    \seq_set_split:NnV \l_tmpa_seq . \l_tmpa_str
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str % .tex
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_str % <filename>
    \seq_if_empty:NF \l_tmpa_seq { %remaining element should be language
      \stex_debug:n {Language~\l_stex_module_lang_str~
        inferred~from~file~name}
      \seq_pop_left:NN \l_tmpa_seq \l_stex_module_lang_str
    }
  } 
  
  \str_if_empty:NF \l_stex_module_lang_str {
    \prop_get:NVNTF \c_stex_languages_prop \l_stex_module_lang_str 
      \l_tmpa_str {
        \ltx@ifpackageloaded{babel}{
          \exp_args:Nx \selectlanguage { \l_tmpa_str }
        }{}
      } {
        \msg_set:nnn{stex}{error/unknownlanguage}{
          Unknown~language~\l_tmpa_str
        }
        \msg_error:nn{stex}{error/unknownlanguage}
      }
  }

  % signature
  \str_if_empty:NTF \l_stex_module_sig_str {
    \str_clear:N \l_tmpa_str
    \seq_clear:N \l_tmpa_seq
    \tl_clear:N \l_tmpa_tl
    \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
      name      = \l_stex_module_name_str ,
      ns        = \l_stex_module_ns_str ,
      imports   = \exp_not:o { \l_tmpa_seq } ,
      constants = \exp_not:o { \l_tmpa_seq } ,
      content   = \exp_not:o { \l_tmpa_tl }  ,
      file      = \exp_not:o { \g_stex_currentfile_seq } ,
      lang      = \l_stex_module_lang_str ,
      sig       = \l_stex_module_sig_str ,
      meta      = \l_stex_module_meta_str
    }
  }{
    \str_if_empty:NT \l_stex_module_lang_str {
      \msg_set:nnn{stex}{error/siglanguage}{
        Module~\l_stex_module_ns_str?\l_stex_module_name_str~
        declares~signature~\l_stex_module_sig_str,~but~does~not~
        declare~its~language
      }
      \msg_error:nn{stex}{error/siglanguage}
    }

    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
    \seq_set_split:NnV \l_tmpb_seq . \l_tmpa_str
    \seq_pop_right:NN \l_tmpb_seq \l_tmpa_str % .tex
    \seq_pop_left:NN \l_tmpb_seq \l_tmpa_str % <filename>
    \str_set:Nx \l_tmpa_str {
      \stex_path_to_string:N \l_tmpa_seq /
      \l_tmpa_str . \l_stex_module_sig_str .tex
    }
    \IfFileExists \l_tmpa_str {
      \exp_args:No \stex_in_smsmode:nn { \l_tmpa_str } {
        \seq_clear:N \l_stex_all_modules_seq
        \prop_clear:N \l_stex_current_module_prop
        \stex_debug:n{Loading~signature~\l_tmpa_str}
        \input { \l_tmpa_str }
      }
    }{
      \msg_set:nnn{stex}{error/modulemissing}{
        No~file~for~signature~module~\l_tmpa_str~found
      }
      \msg_error:nn{stex}{error/modulemissing}
    }
    \stex_activate_module:n {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }
    \prop_set_eq:Nc \l_stex_current_module_prop {
      c_stex_module_
      \l_stex_module_ns_str ?
      \l_stex_module_name_str
      _prop
    }
  }

  % metatheory
  \str_if_empty:NT \l_stex_module_meta_str {
    \str_set:Nx \l_stex_module_meta_str {
      \c_stex_metatheory_ns_str ? Metatheory
    }
  }


  \stex_debug:n{
    New~module:\\
    Namespace:~\l_stex_module_ns_str\\
    Name:~\l_stex_module_name_str\\
    Language:~\l_stex_module_lang_str\\
    Signature:~\l_stex_module_sig_str\\
    Metatheory:~\l_stex_module_meta_str\\
    File:~\stex_path_to_string:N \g_stex_currentfile_seq
  }

  \seq_put_right:Nx \l_stex_all_modules_seq {
    \l_stex_module_ns_str ? \l_stex_module_name_str
  }

  \seq_gput_right:Nx  \g_stex_modules_in_file_seq
      { \l_stex_module_ns_str ? \l_stex_module_name_str }
  
  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env} {theory} {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }

    \stex_annotate_invisible:nnn{header}{} {
      \stex_annotate:nnn{language}{ \l_stex_module_lang_str }{}
      \stex_annotate:nnn{signature}{ \l_stex_module_sig_str }{}
      \str_if_eq:VnF \l_stex_module_meta_str {NONE} {
        \stex_annotate:nnn{metatheory}{ \l_stex_module_meta_str }{}
      }
    }
  }
  
  \str_if_eq:VnF \l_stex_module_meta_str {NONE} {
    \exp_args:Nx \STEXexport{ 
      \stex_activate_module:n {\l_stex_module_meta_str}
    }
  }
  % TODO: Inherit metatheory for nested modules?
}
\iffalse \end{stex_annotate_env} \fi % make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_end_module:}
%
%   implements |\end{module}|
%
%    \begin{macrocode}
\iffalse \begin{stex_annotate_env} \fi %^^A make syntax highlighting work again
\cs_new_protected:Nn \_@@_end_module: {
  \str_set:Nx \l_tmpa_str {
    c_stex_module_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  %^^A \prop_new:c { \l_tmpa_str }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \stex_debug:n{Closing~module~\prop_item:Nn \l_stex_current_module_prop { name }}
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        c_stex_module_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        imports   = \prop_item:cn { \l_tmpa_str } { imports } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta }
      }
    }
  }{
    \end{stex_annotate_env}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{@module}
%
%  The core environment, with no header
%    
%    \begin{macrocode}
\NewDocumentEnvironment { @module } { O{} m } {
  \str_set:Nx \l_stex_module_name_str { #2 }
  \par
  \_@@_args:n { #1 }
  \_@@_begin_module:
} { 
  \_@@_end_module:
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\stex_modules_heading:}
%
%   Code for document headers
%
%    \begin{macrocode}
\cs_if_exist:NTF \thesection {
  \newcounter{module}[section]
}{
  \newcounter{module}
}

\bool_if:NT \c_stex_showmods_bool {
  \latexml_if:F { \RequirePackage{mdframed} }
}

\cs_new_protected:Nn \stex_modules_heading: {
  \stepcounter{module}
  \par
  \bool_if:NT \c_stex_showmods_bool {
    \noindent{\textbf{Module} ~
      \cs_if_exist:NT \thesection {\thesection.}
      \themodule ~ [\l_stex_module_name_str]
    }
    % TODO references
    % \sref@label@id{Module \thesection.\themodule [\module@name]}%
    \str_if_empty:NTF \l_stex_module_title_str {
    }{
      \quad(\l_stex_module_title_str)\hfill
    }\par
  }
}
%    \end{macrocode}
% \end{macro}
%
% Finally:
%    \begin{macrocode}
\NewDocumentEnvironment { module } { O{} m } {
  \bool_if:NT \c_stex_showmods_bool {
    \begin{mdframed}
  }
  \begin{@module}[#1]{#2}
  \stex_modules_heading:
}{
  \end{@module}
  \bool_if:NT \c_stex_showmods_bool {
    \end{mdframed}
  }
}
%    \end{macrocode}
%
% \end{environment}
%
% \subsubsection{SMS Mode}
%    \begin{macrocode}
%<@@=stex_smsmode>
%    \end{macrocode}
%
% \begin{variable}{
%   \g_stex_smsmode_allowedmacros_tl,
%   \g_stex_smsmode_allowedmacros_escape_tl,
%   \g_stex_smsmode_allowedenvs_seq
% }
%    \begin{macrocode}
\tl_new:N \g_stex_smsmode_allowedmacros_tl
\tl_new:N \g_stex_smsmode_allowedmacros_escape_tl
\seq_new:N \g_stex_smsmode_allowedenvs_seq

\tl_set:Nn \g_stex_smsmode_allowedmacros_tl {
  \makeatletter
  \makeatother
  \ExplSyntaxOn
  \ExplSyntaxOff
}

\tl_set:Nn \g_stex_smsmode_allowedmacros_escape_tl {
  \symdef
  \importmodule
  \notation
  \symdecl
  \STEXexport
}

\exp_args:NNx \seq_set_from_clist:Nn \g_stex_smsmode_allowedenvs_seq {
  \tl_to_str:n {
    module,
    @module
  }
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[pTF]{\stex_if_smsmode:}
%    \begin{macrocode}
\bool_new:N \g_@@_bool
\bool_set_false:N \g_@@_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g_@@_bool \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\_@@_if_catcodes:}
% Checks whether the SMS mode category code scheme is active.
%    \begin{macrocode}
\bool_new:N \g_@@_catcode_bool
\bool_set_false:N \g_@@_catcode_bool
\prg_new_conditional:Nnn \_@@_if_catcodes: { p, T, F, TF } {
  \bool_if:NTF \g_@@_catcode_bool 
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_smsmode_set_codes:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_smsmode_set_codes: {
  \stex_if_smsmode:T {
    \_@@_if_catcodes:F {
      \bool_gset_true:N \g_@@_catcode_bool
      \exp_after:wN \char_gset_active_eq:NN 
        \c_backslash_str \_@@_cs:
      \tex_global:D \char_set_catcode_active:N \\
      \tex_global:D \char_set_catcode_other:N $
      \tex_global:D \char_set_catcode_other:N ^
      \tex_global:D \char_set_catcode_other:N _
      \tex_global:D \char_set_catcode_other:N &
      \tex_global:D \char_set_catcode_other:N ##
    }
  }
} \iffalse $ \fi % to make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_unset_codes:}
%   Sets category code scheme back from the one used in SMS mode.
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_unset_codes: {
  \_@@_if_catcodes:T {
    \bool_gset_false:N \g_@@_catcode_bool
    \exp_after:wN \tex_global:D \exp_after:wN 
      \char_set_catcode_escape:N \c_backslash_str
    \tex_global:D \char_set_catcode_math_toggle:N $
    \tex_global:D \char_set_catcode_math_superscript:N ^
    \tex_global:D \char_set_catcode_math_subscript:N _
    \tex_global:D \char_set_catcode_alignment:N &
    \tex_global:D \char_set_catcode_parameter:N ##
  }
} \iffalse $ \fi % to make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_in_smsmode:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_in_smsmode:nn {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_eq:cN { l_@@_#1_bool } \g_@@_bool
    \bool_gset_true:N \g_@@_bool
    \stex_smsmode_set_codes:
    #2
    \bool_gset_eq:Nc \g_@@_bool { l_@@_#1_bool }
    \stex_if_smsmode:F {
      \_@@_unset_codes:
    }
  }
  \box_clear:N \l_tmpa_box
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_cs:}
% is executed on encountering |\| in smsmode.
% It checks whether the corresponding command is allowed and executes
% or ignores it accordingly:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_cs: {
  \str_clear:N \l_tmpa_str
  \peek_analysis_map_inline:n {
    % #1: token (one expansion)
    % #2: charcode
    % #3 catcode
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpa_str { ##1 }
    } {
      \str_if_empty:NTF \l_tmpa_str {
        % we don't allow (or need) single non-letter CSs
        % for now
        \peek_analysis_map_break: 
      }{
        \str_if_eq:onTF \l_tmpa_str { begin } {
          \peek_analysis_map_break:n { 
            \exp_after:wN \_@@_checkbegin:n ##1
          }
        } {
          \str_if_eq:onTF \l_tmpa_str { end } {
            \peek_analysis_map_break:n { 
              \exp_after:wN \_@@_checkend:n ##1
            }
          } {
          \tl_set:Nn \l_tmpa_tl { \use:c{\l_tmpa_str} }
          \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
            \g_stex_smsmode_allowedmacros_tl 
              { \use:c{\l_tmpa_str} } {
              \stex_debug:n{Executing~1:~\l_tmpa_str}
              \peek_analysis_map_break:n { 
                \exp_after:wN \l_tmpa_tl ##1
              }
            } {
              \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
              \g_stex_smsmode_allowedmacros_escape_tl 
                { \use:c{\l_tmpa_str} } {
                \stex_debug:n{Executing~2:~\l_tmpa_str}
                % TODO \_@@_rescan_cs:
%                \exp_after:wN \exp_after:wN \exp_after:wN
%                \token_if_eq_charcode:NNTF \exp_after:wN \c_backslash_str ##1 {
%                  \peek_analysis_map_break:n {
%                    \_@@_unset_codes:
%                    \_@@_rescan_cs:
%                  }
%                } {
                  \peek_analysis_map_break:n {
                    \_@@_unset_codes:
                    \exp_after:wN \l_tmpa_tl ##1
                  }
%                }
              } {
                \peek_analysis_map_break:n { ##1 }
              }
            }
          }
        }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_@@_rescan_cs:}
% If the last token gobbled by |\stex_smsmode_cs:| happened to be
% a |\|, we need to rescan the cs name and reinsert it into the input
% stream:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_rescan_cs: {
  \str_clear:N \l_tmpb_str
  \peek_analysis_map_inline:n {
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpb_str { ##1 }
    } {
      \peek_analysis_map_break:n {
        \exp_after:wN \use:c \exp_after:wN { 
          \exp_after:wN \l_tmpa_str\exp_after:wN 
        } \use:c { \l_tmpb_str \exp_after:wN } ##1
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_checkbegin:n}
% called on |\begin|; checks whether the environment being opened
% is allowed in SMS mode. 
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkbegin:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \_@@_unset_codes:
    \begin{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_checkend:n}
% called on |\end|; checks whether the environment being opened
% is allowed in SMS mode. 
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkend:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \end{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{Inheritance}
%    \begin{macrocode}
%<@@=stex_importmodule>
%    \end{macrocode}
%
% \begin{macro}{\stex_import_module_uri:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_import_module_uri:nn {
  \str_set:Nx \l_@@_archive_str { #1 }
  \str_set:Nn \l_@@_path_str { #2 }
  \str_if_empty:NT \l_@@_archive_str {
    \prop_if_empty:NF \l_stex_current_repository_prop {
      \prop_get:NnN \l_stex_current_repository_prop { id } \l_@@_archive_str
    }
  }

  \exp_args:NNNo \seq_set_split:Nnn \l_tmpb_seq ? { \l_@@_path_str }
  \seq_pop_right:NN \l_tmpb_seq \l_@@_name_str
  \str_set:Nx \l_@@_path_str { \seq_use:Nn \l_tmpb_seq ? }

  \str_if_empty:NTF \l_@@_archive_str {
    \stex_modules_current_namespace:
    \str_if_empty:NF \l_@@_path_str {
      \str_set:Nx \l_stex_module_ns_str {
        \l_stex_module_ns_str / \l_@@_path_str
      }
    }
  }{
    \stex_require_repository:n \l_@@_archive_str
    \prop_get:cnN { c_stex_mathhub_\l_@@_archive_str _manifest_prop } { ns }
      \l_stex_module_ns_str
    \str_if_empty:NF \l_@@_path_str {
      \str_set:Nx \l_stex_module_ns_str {
        \l_stex_module_ns_str / \l_@@_path_str
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{
%   \l_@@_name_str,\l_@@_archive_str,\l_@@_path_str,\l_@@_file_str
% }
%   Store the return values of \cs{stex_import_module_uri:nn}.
%    \begin{macrocode}
\str_new:N \l_@@_name_str
\str_new:N \l_@@_archive_str
\str_new:N \l_@@_path_str
\str_new:N \g_@@_file_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_import_require_module:nnnn}
%    \begin{syntax} \Arg{ns} \Arg{archive-ID} \Arg{path} \Arg{name} \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_import_require_module:nnnn {
  \exp_args:Nx \stex_if_module_exists:nF { #1 ? #4 } { 
    % \stex_debug:n{Arguments: #1, #2, #3, #4}

    % archive
    \str_set:Nx \l_tmpa_str { #2 }
    \str_if_empty:NTF \l_tmpa_str {
      \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    } {
      \stex_path_from_string:Nn \l_tmpb_seq { \l_tmpa_str }
      \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpb_seq
      \seq_put_right:Nn \l_tmpa_seq { source }
    }

    % path
    \str_set:Nx \l_tmpb_str { #3 }
    \str_if_empty:NTF \l_tmpb_str {
      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq / #4 }
      
      \ltx@ifpackageloaded{babel} { 
        \exp_args:NNx \prop_get:NnNF \c_stex_language_abbrevs_prop 
            { \languagename } \l_tmpb_str {
              \msg_set:nnn{stex}{error/unknownlanguage}{
                Unknown~language~\languagename
              }
              \msg_error:nn{stex}{error/unknownlanguage}
            }
      } {
        \str_clear:N \l_tmpb_str
      }

      \stex_debug:n{Checking~\l_tmpa_str.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
        \str_gset:Nx \g_@@_file_str { \l_tmpa_str.\l_tmpb_str.tex }
      }{
        \stex_debug:n{Checking~\l_tmpa_str.tex}
        \IfFileExists{ \l_tmpa_str.tex }{
          \str_gset:Nx \g_@@_file_str { \l_tmpa_str.tex }
        }{
          % try english as default
          \stex_debug:n{Checking~\l_tmpa_str.en.tex}
          \IfFileExists{ \l_tmpa_str.en.tex }{
            \str_gset:Nx \g_@@_file_str { \l_tmpa_str.en.tex }
          }{
            \msg_set:nnn{stex}{error/modulemissing}{
              No~file~for~module~#1?#4~found
            }
            \msg_error:nn{stex}{error/modulemissing}
          }
        }
      }

    } {
      \seq_set_split:NnV \l_tmpb_seq / \l_tmpb_str
      \seq_concat:NNN \l_tmpa_seq \l_tmpa_seq \l_tmpb_seq
      
      \ltx@ifpackageloaded{babel} { 
        \exp_args:NNx \prop_get:NnNF \c_stex_language_abbrevs_prop 
            { \languagename } \l_tmpb_str {
              \msg_set:nnn{stex}{error/unknownlanguage}{
                Unknown~language~\languagename
              }
              \msg_error:nn{stex}{error/unknownlanguage}
            }
      } {
        \str_clear:N \l_tmpb_str
      }

      \stex_path_to_string:NN \l_tmpa_seq \l_tmpa_str

      \stex_debug:n{Checking~\l_tmpa_str/#4.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str/#4.\l_tmpb_str.tex }{
        \str_gset:Nx \g_@@_file_str { \l_tmpa_str/#4.\l_tmpb_str.tex }
      }{
        \stex_debug:n{Checking~\l_tmpa_str/#4.tex}
        \IfFileExists{ \l_tmpa_str/#4.tex }{
          \str_gset:Nx \g_@@_file_str { \l_tmpa_str/#4.tex }
        }{
          % try english as default
          \stex_debug:n{Checking~\l_tmpa_str/#4.en.tex}
          \IfFileExists{ \l_tmpa_str/#4.en.tex }{
            \str_gset:Nx \g_@@_file_str { \l_tmpa_str/#4.en.tex }
          }{
            \stex_debug:n{Checking~\l_tmpa_str.\l_tmpb_str.tex}
            \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
              \str_gset:Nx \g_@@_file_str { \l_tmpa_str.\l_tmpb_str.tex }
            }{
              \stex_debug:n{Checking~\l_tmpa_str.tex}
              \IfFileExists{ \l_tmpa_str.tex }{
                \str_gset:Nx \g_@@_file_str { \l_tmpa_str.tex }
              }{
                % try english as default
                \stex_debug:n{Checking~\l_tmpa_str.en.tex}
                \IfFileExists{ \l_tmpa_str.en.tex }{
                  \str_gset:Nx \g_@@_file_str { \l_tmpa_str.en.tex }
                }{
                  \msg_set:nnn{stex}{error/modulemissing}{
                    No~file~for~module~#1?#4~found
                  }
                  \msg_error:nn{stex}{error/modulemissing}
                }
              }
            }
          }
        }
      }
    }

    \seq_set_eq:NN \l_tmpa_seq \g_stex_modules_in_file_seq
    \seq_clear:N \g_stex_modules_in_file_seq
%    \exp_args:Nnx \use:nn {
      \exp_args:No \stex_in_smsmode:nn { \g_@@_file_str } {
        \seq_clear:N \l_stex_all_modules_seq
        \prop_clear:N \l_stex_current_module_prop
        \str_set:Nx \l_tmpb_str { #2 }
        \str_if_empty:NF \l_tmpb_str {
          \stex_set_current_repository:n { #2 }
        }
        \stex_debug:n{Loading~\g_@@_file_str}
        \input { \g_@@_file_str }
      }
%    }{

%    }
    \prop_gput:Noo \g_stex_module_files_prop
    \g_@@_file_str \g_stex_modules_in_file_seq
    \seq_set_eq:NN \g_stex_modules_in_file_seq \l_tmpa_seq

    \stex_if_module_exists:nF { #1 ? #4 } {
      \msg_set:nnn{stex}{error/modulemissing}{
        Module~#1?#4~not~found~in~file~\g_@@_file_str
      }
      \msg_error:nn{stex}{error/modulemissing}
    }
  }
  \stex_activate_module:n { #1 ? #4 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_activate_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_activate_module:n {
  \stex_debug:n{Activating~module~#1}
  \exp_args:NNx \seq_if_in:NnF \l_stex_all_modules_seq { #1 } {
    \seq_put_right:Nx \l_stex_all_modules_seq { #1 }
    \prop_item:cn { c_stex_module_#1_prop } { content }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\importmodule}
%    \begin{macrocode}
\NewDocumentCommand \importmodule { O{} m } {
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_debug:n{Importing~module:~
    \l_stex_module_ns_str ? \l_@@_name_str
  }
  \stex_if_smsmode:F {
    \stex_import_require_module:nnnn 
    { \l_stex_module_ns_str } { \l_@@_archive_str } 
    { \l_@@_path_str } { \l_@@_name_str }
    \stex_annotate_invisible:nnn 
      {import} {\l_stex_module_ns_str ? \l_@@_name_str} {}
  }
  \exp_args:Nx \stex_add_to_current_module:n {
    \stex_import_require_module:nnnn 
    { \l_stex_module_ns_str } { \l_@@_archive_str } 
    { \l_@@_path_str } { \l_@@_name_str }
  }
  \exp_args:Nx \stex_add_import_to_current_module:n {
    \l_stex_module_ns_str ? \l_@@_name_str
  }
  \stex_smsmode_set_codes:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\usemodule}
%    \begin{macrocode}
\NewDocumentCommand \usemodule { O{} m } {
  \stex_if_smsmode:F {
    \stex_import_module_uri:nn { #1 } { #2 }
    \stex_import_require_module:nnnn 
    { \l_stex_module_ns_str } { \l_@@_archive_str }
    { \l_@@_path_str } { \l_@@_name_str }
    \stex_annotate_invisible:nnn 
      {usemodule} {\l_stex_module_ns_str ? \l_@@_name_str} {}
  }
  \stex_smsmode_set_codes:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_stex_modules_in_file_seq,\g_stex_module_files_prop}
%    \begin{macrocode}
\seq_new:N \g_stex_modules_in_file_seq
\prop_new:N \g_stex_module_files_prop
%    \end{macrocode}
% \end{variable}
%
%
% \subsection{Symbol Declarations}
%    \begin{macrocode}
%<@@=stex_symdecl>
%    \end{macrocode}
%
%
% \begin{variable}{\l_stex_all_symbols_seq}
%   Stores all available symbols
%    \begin{macrocode}
\seq_new:N \l_stex_all_symbols_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\STEXsymbol}
%    \begin{macrocode}
\NewDocumentCommand \STEXsymbol { m } {
  \stex_get_symbol:n { #1 }
  \exp_args:No
  \stex_invoke_symbol:n { \l_stex_get_symbol_uri_str }
}
%    \end{macrocode}
% \end{macro}
%
% |symdecl| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / symdecl } {
  name        .tl_set_x:N  = \l_stex_symdecl_name_str ,
  local       .bool_set:N  = \l_stex_symdecl_local_bool ,
  args        .tl_set_x:N  = \l_stex_symdecl_args_str ,
  type        .tl_set:N    = \l_stex_symdecl_type_tl ,
  align       .tl_set:N    = \l_stex_symdecl_align_str , % TODO(?)
  gfc         .tl_set:N    = \l_stex_symdecl_gfc_str , % TODO(?)
  specializes .tl_set:N    = \l_stex_symdecl_specializes_str , % TODO(?)
  def         .tl_set:N    = \l_stex_symdecl_definiens_tl
}

\bool_new:N \l_stex_symdecl_make_macro_bool

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl
  \tl_clear:N \l_stex_symdecl_definiens_tl
  
  \keys_set:nn { stex /symdecl } { #1 }

  \exp_args:NNo \str_set:Nn \l_stex_symdecl_name_str
    \l_stex_symdecl_name_str
  \exp_args:NNo \str_set:Nn \l_stex_symdecl_args_str
    \l_stex_symdecl_args_str
}
%    \end{macrocode}
%
% \begin{macro}{\symdecl}
%
% Parses the optional arguments and passes them on to
% \cs{stex_symdecl_do:} (so that \cs{symdef}
% can do the same)
%
%    \begin{macrocode}

\NewDocumentCommand \symdecl { s O{} m } {
  \_@@_args:n { #2 }
  \IfBooleanTF #1 {
    \bool_set_false:N \l_stex_symdecl_make_macro_bool
  } {
    \bool_set_true:N \l_stex_symdecl_make_macro_bool
  }
  \stex_symdecl_do:n { #3 }
  \stex_smsmode_set_codes:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_symdecl_do:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_symdecl_do:n {
  \stex_if_in_module:F {
    % TODO throw error? some default namespace?
  }
  
  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }

  \prop_if_exist:cT { g_stex_symdecl_ 
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name} ?
      \l_stex_symdecl_name_str
    _prop
  }{
    % TODO throw error (beware of circular dependencies)
  }

  \prop_clear:N \l_tmpa_prop
  \prop_put:Nnx \l_tmpa_prop { module } {
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name}
  }
  \seq_clear:N \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { notations } \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { name } \l_stex_symdecl_name_str
  \prop_put:Nno \l_tmpa_prop { local } \l_stex_symdecl_local_bool
  \prop_put:Nno \l_tmpa_prop { type } \l_stex_symdecl_type_tl

  \exp_args:No \stex_add_constant_to_current_module:n {
    \l_stex_symdecl_name_str
  }

  % arity/args
  \int_zero:N \l_tmpb_int

  \bool_set_true:N \l_tmpa_bool
  \str_map_inline:Nn \l_stex_symdecl_args_str {
    \token_case_meaning:NnF ##1 {
      0 {} 1 {} 2 {} 3 {} 4 {} 5 {} 6 {} 7 {} 8 {} 9 {}
      {\tl_to_str:n i} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n b} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n a} { 
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
      {\tl_to_str:n B} { 
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
    }{
      \msg_set:nnn{stex}{error/wrongargs}{
        args~value~in~symbol~declaration~for~
        \prop_item:Nn \l_stex_current_module_prop {ns} ?
        \prop_item:Nn \l_stex_current_module_prop {name} ?
        \l_stex_symdecl_name_str ~
        needs~to~be~
        i,~a,~b~or~B,~but~##1~given
      }
      \msg_error:nn{stex}{error/wrongargs}
    }
  }
  \bool_if:NTF \l_tmpa_bool {
    % possibly numeric
    \str_if_empty:NTF \l_stex_symdecl_args_str {
      \prop_put:Nnn \l_tmpa_prop { args } {}
      \prop_put:Nnn \l_tmpa_prop { arity } { 0 }
    }{
      \int_set:Nn \l_tmpa_int { \l_stex_symdecl_args_str }
      \prop_put:Nnx \l_tmpa_prop { arity } { \int_use:N \l_tmpa_int }
      \str_clear:N \l_tmpa_str
      \int_step_inline:nn \l_tmpa_int {
        \str_put_right:Nn \l_tmpa_str i
      }
      \prop_put:Nnx \l_tmpa_prop { args } { \l_tmpa_str }
    }
  } {
    \prop_put:Nnx \l_tmpa_prop { args } { \l_stex_symdecl_args_str }
    \prop_put:Nnx \l_tmpa_prop { arity }
      { \str_count:N \l_stex_symdecl_args_str }
  }
  \prop_put:Nnx \l_tmpa_prop { assocs } { \int_use:N \l_tmpb_int }
  

  % semantic macro

  \bool_if:NT \l_stex_symdecl_make_macro_bool {
    \tl_set:cx { #1 } { \stex_invoke_symbol:n {
      \prop_item:Nn \l_tmpa_prop { module } ?
        \prop_item:Nn \l_tmpa_prop { name }
    } }

    \bool_if:NF \l_stex_symdecl_local_bool {
      \exp_args:Nx \stex_add_to_current_module:n {
        \tl_set:cx { #1 } { \stex_invoke_symbol:n {
          \prop_item:Nn \l_tmpa_prop { module } ?
            \prop_item:Nn \l_tmpa_prop { name }
        } }
      }
    }
  }

  % add to all symbols

  \bool_if:NF \l_stex_symdecl_local_bool {
    \exp_args:Nx \stex_add_to_current_module:n {
      \seq_put_right:Nn \exp_not:N \l_stex_all_symbols_seq {
        \prop_item:Nn \l_tmpa_prop { module } ?
        \prop_item:Nn \l_tmpa_prop { name }
      }
    }
  }

  \stex_debug:n{New~symbol:~
    \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }^^J
    Type:~\exp_not:o { \l_stex_symdecl_type_tl }^^J
    Args:~\prop_item:Nn \l_tmpa_prop { args }
  }

  % circular dependencies require this:

  \prop_if_exist:cF {
    g_stex_symdecl_ 
    \prop_item:Nn \l_tmpa_prop { module } ?
    \prop_item:Nn \l_tmpa_prop { name }
    _prop 
  } {
    \prop_gset_eq:cN {
      g_stex_symdecl_ 
      \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
      _prop 
    } \l_tmpa_prop
  }

  \stex_if_smsmode:TF {
    \bool_if:NF \l_stex_symdecl_local_bool {
      \exp_args:Nx \stex_addtosms:n {
        \prop_gset_from_keyval:cn {
          g_stex_symdecl_ 
          \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
          _prop 
        } {
          name      = \prop_item:Nn \l_tmpa_prop { name }       ,
          module    = \prop_item:Nn \l_tmpa_prop { module }     ,
          notations = \prop_item:Nn \l_tmpa_prop { notations }  ,
          local     = \prop_item:Nn \l_tmpa_prop { local }      ,
          type      = \prop_item:Nn \l_tmpa_prop { type }       ,
          args      = \prop_item:Nn \l_tmpa_prop { args }       ,
          arity     = \prop_item:Nn \l_tmpa_prop { arity }      ,
          assocs    = \prop_item:Nn \l_tmpa_prop { assocs }
        }
        \seq_put_right:Nn \exp_not:N \l_stex_all_symbols_seq {
          \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
        }
      }
    }
  }{
    \exp_args:NNx \seq_put_right:Nn \l_stex_all_symbols_seq {
      \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
    }
    \stex_annotate_invisible:nnn {symdecl} {
      \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
    } {
      \stex_annotate_invisible:nnn{type}{}{$\l_stex_symdecl_type_tl$}
      \stex_annotate_invisible:nnn{args}{}{
        \prop_item:Nn \l_tmpa_prop { args }
      }
      \stex_annotate_invisible:nnn{macroname}{}{#1}
      \tl_if_empty:NF \l_stex_symdecl_definiens_tl {
        \stex_annotate_invisible:nnn{definiens}{}
          {$\l_stex_symdecl_definiens_tl$}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_symbol:n}
%
%    \begin{macrocode}
\str_new:N \l_stex_get_symbol_uri_str

\cs_new_protected:Nn \stex_get_symbol:n {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \_@@_get_symbol_from_cs:n { #1 }
  }{
    % argument is a string
    % is it a command name?
    \cs_if_exist:cTF { #1 }{
      \cs_set_eq:Nc \l_tmpa_tl { #1 }
      \str_set:Nx \l_tmpa_str { \cs_argument_spec:N \l_tmpa_tl }
      \str_if_empty:NTF \l_tmpa_str {
        \exp_args:Nx \cs_if_eq:NNTF {
          \tl_head:N \l_tmpa_tl
        } \stex_invoke_symbol:n {
          \exp_args:No \_@@_get_symbol_from_cs:n { \use:c { #1 } }
        }{
          \_@@_get_symbol_from_string:n { #1 }
        }
      } {
        \_@@_get_symbol_from_string:n { #1 }
      }
    }{
      % argument is not a command name
      \_@@_get_symbol_from_string:n { #1 }
      % \l_stex_all_symbols_seq
    }
  }
}

\cs_new_protected:Nn \_@@_get_symbol_from_string:n {
  \bool_set_false:N \l_tmpa_bool
  \stex_if_in_module:T {
    \prop_get:NnN \l_stex_current_module_prop 
    { constants } \l_tmpa_seq
    \exp_args:NNo \seq_if_in:NnTF \l_tmpa_seq { \l_tmpa_str } {
      \bool_set_true:N \l_tmpa_bool
      \str_set:Nx \l_stex_get_symbol_uri_str {
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name } ? #1
      }
    }
  }
  \bool_if:NF \l_tmpa_bool {
    \tl_set:Nn \l_tmpa_tl {
      \msg_set:nnn{stex}{error/unknownsymbol}{
        No~symbol~#1~found!
      }
      \msg_error:nn{stex}{error/unknownsymbol}
    }
    \str_set:Nn \l_tmpa_str { #1 }
    \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
    \seq_map_inline:Nn \l_stex_all_symbols_seq {
      \str_set:Nn \l_tmpb_str { ##1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
      } {
        \seq_map_break:n {
          \tl_set:Nn \l_tmpa_tl {
            \str_set:Nn \l_stex_get_symbol_uri_str {
              ##1
            }
          }
        }
      }
    }
    \l_tmpa_tl
  }
}

\cs_new_protected:Nn \_@@_get_symbol_from_cs:n {
  \exp_args:NNx \tl_set:Nn \l_tmpa_tl 
    { \tl_tail:N \l_tmpa_tl }
  \tl_if_single:NTF \l_tmpa_tl {
    \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
      \exp_after:wN \str_set:Nn \exp_after:wN
        \l_stex_get_symbol_uri_str \l_tmpa_tl
    }{
      % TODO
      % tail is not a single group
    }
  }{
    % TODO
    % tail is not a single group
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Notations}
%    \begin{macrocode}
%<@@=stex_notation>
%    \end{macrocode}
%
% |notation| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / notation } {
  lang    .tl_set_x:N = \l_@@_lang_str ,
  variant .tl_set_x:N = \l_@@_variant_str ,
  prec    .tl_set_x:N = \l_@@_prec_str ,
  op      .tl_set:N   = \l_@@_op_tl ,
  unknown .code:n     = \str_set:Nx 
      \l_@@_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_@@_lang_str
  \str_clear:N \l_@@_variant_str
  \str_clear:N \l_@@_prec_str
  \tl_clear:N \l_@@_op_tl
  
  \keys_set:nn { stex / notation } { #1 }

  \str_set:Nx \l_@@_lang_str \l_@@_lang_str
  \str_set:Nx \l_@@_variant_str \l_@@_variant_str
  \str_set:Nx \l_@@_prec_str \l_@@_prec_str
}
%    \end{macrocode}
%
%
%
% \begin{macro}{\notation}
%    \begin{macrocode}
\NewDocumentCommand \notation { O{} m } {
  \_@@_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_get_symbol:n { #2 }
  \stex_notation_do:nn { \l_stex_get_symbol_uri_str }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_notation_do:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_notation_do:nn {
  \prop_set_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop 
  }
  
  \prop_clear:N \l_tmpb_prop
  \prop_put:Nno \l_tmpb_prop { symbol } { #1 }
  \prop_put:Nno \l_tmpb_prop { language } \l_@@_lang_str
  \prop_put:Nno \l_tmpb_prop { variant } \l_@@_variant_str

  % precedences
  \seq_clear:N \l_tmpb_seq
  \exp_args:NNno
  \str_if_empty:NTF \l_@@_prec_str {
    \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
    \int_compare:nNnTF \l_tmpa_str = 0 {
      \exp_args:NNnx
      \prop_put:Nno \l_tmpb_prop { opprec } 
        { \infprec }
    }{
      \prop_put:Nnn \l_tmpb_prop { opprec } { 0 }
    }
  } {
    \str_if_eq:onTF \l_@@_prec_str {nobrackets}{
      \exp_args:NNnx
      \prop_put:Nno \l_tmpb_prop { opprec } 
        { \infprec }
      \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
      \int_step_inline:nn { \l_tmpa_str } {
        \exp_args:NNx
        \seq_put_right:Nn \l_tmpb_seq { \neginfprec }
      }
    }{
      \seq_set_split:NnV \l_tmpa_seq ; \l_@@_prec_str
      \seq_pop_left:NNTF \l_tmpa_seq \l_tmpa_str {
        \prop_put:Nno \l_tmpb_prop { opprec } \l_tmpa_str
        \seq_pop_left:NNT \l_tmpa_seq \l_tmpa_str {
          \exp_args:NNNo \exp_args:NNno \seq_set_split:Nnn 
            \l_tmpa_seq {\tl_to_str:n{x} } { \l_tmpa_str }
          \seq_map_inline:Nn \l_tmpa_seq {
            \seq_put_right:Nn \l_tmpb_seq { ##1 }
          }
        }
        \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
      }{
        \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
        \int_compare:nNnTF \l_tmpa_str = 0 {
          \exp_args:NNnx
          \prop_put:Nno \l_tmpb_prop { opprec } 
            { \infprec }
        }{
          \prop_put:Nnn \l_tmpb_prop { opprec } { 0 }
        }
      }
    }
  }

  \seq_set_eq:NN \l_tmpa_seq \l_tmpb_seq
  \int_step_inline:nn { \l_tmpa_str } {
    \seq_pop_left:NNF \l_tmpa_seq \l_tmpb_str {
      \exp_args:NNx
      \seq_put_right:Nn \l_tmpb_seq { 
        \prop_item:Nn \l_tmpb_prop { opprec }
      }
    }
  }
  
  \prop_put:Nno \l_tmpb_prop { argprecs } \l_tmpb_seq
  \tl_clear:N \l_tmpa_tl

  \int_compare:nNnTF \l_tmpa_str = 0 {
    \exp_args:NNe
    \cs_set:Npn \l_@@_macrocode_cs {
      \_stex_term_math_oms:nnnn { #1 } 
        { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
        { \prop_item:Nn \l_tmpb_prop { opprec } } 
        { \exp_not:n { #2 } }
    }
    \_@@_final:
  }{
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpb_str
    \str_if_in:NnTF \l_tmpb_str b {
      \exp_args:Nne \use:nn
      {
      \cs_generate_from_arg_count:NNnn \l_@@_macrocode_cs
      \cs_set:Npn \l_tmpa_str } { {
        \_stex_term_math_omb:nnnn { #1 } 
          { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
          { \prop_item:Nn \l_tmpb_prop { opprec } } 
          { \exp_not:n { #2 } }
      }}
    }{
      \str_if_in:NnTF \l_tmpb_str B {
        \exp_args:Nne \use:nn
        {
        \cs_generate_from_arg_count:NNnn \l_@@_macrocode_cs
        \cs_set:Npn \l_tmpa_str } { {
          \_stex_term_math_omb:nnnn { #1 } 
            { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
            { \prop_item:Nn \l_tmpb_prop { opprec } } 
            { \exp_not:n { #2 } }
        } }
      }{
        \exp_args:Nne \use:nn
        {
        \cs_generate_from_arg_count:NNnn \l_@@_macrocode_cs
        \cs_set:Npn \l_tmpa_str } { {
          \_stex_term_math_oma:nnnn { #1 } 
            { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
            { \prop_item:Nn \l_tmpb_prop { opprec } } 
            { \exp_not:n { #2 } }
        } }
      }
    }

    \int_zero:N \l_tmpa_int
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
    \_@@_arguments:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_arguments:}
%
% Takes care of annotating the arguments in a
% notation macro
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_arguments: {
  \int_incr:N \l_tmpa_int
  \str_if_empty:NTF \l_tmpa_str {
    \_@@_final:
  }{
    \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
    \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
    \str_if_eq:VnTF \l_tmpb_str a {
      \_@@_argument_assoc:n
    }{
      \str_if_eq:VnTF \l_tmpb_str B {
        \_@@_argument_assoc:n
      }{
        \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
        \tl_put_right:Nx \l_tmpa_tl {
          { \_stex_term_math_arg:nnn
            { \int_use:N \l_tmpa_int }
            { \l_tmpb_str }
            { ####\int_use:N \l_tmpa_int }
          }
        }
        \_@@_arguments:
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_argument_assoc:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_argument_assoc:n {
  \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
  \cs_set:Npn \l_tmpa_cs ##1 ##2 { #1 }
  \tl_put_right:Nx \l_tmpa_tl {
    { \_stex_term_math_assoc_arg:nnnn
      { \int_use:N \l_tmpa_int }
      { \l_tmpb_str }
      \exp_args:No \exp_not:n
      {\exp_after:wN { \l_tmpa_cs {####1} {####2} } }
      { ####\int_use:N \l_tmpa_int }
    }
  }
  \_@@_arguments:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_final:}
%
% Called after processing all notation arguments
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_final: {
  \prop_get:NnN \l_tmpa_prop { arity } \l_tmpb_str
  \prop_get:NnN \l_tmpb_prop { symbol } \l_tmpa_str
  \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:cNnn {
      stex_notation_ \l_tmpa_str \c_hash_str 
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
      _cs
    }
    \cs_gset:Npn \l_tmpb_str } { {
      \exp_after:wN \exp_after:wN \exp_after:wN
      \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN 
      { \exp_after:wN \l_@@_macrocode_cs \l_tmpa_tl }
  } }

  \tl_if_empty:NF \l_@@_op_tl {
    \cs_gset:cpx {
      stex_op_notation_ \l_tmpa_str \c_hash_str
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
      _cs
    } {
      \_stex_term_oms:nnn {
        \l_tmpa_str \c_hash_str \l_@@_variant_str \c_hash_str
        \l_@@_lang_str
      }{
        \l_tmpa_str
      }{ \comp{ \exp_args:No \exp_not:n { \l_@@_op_tl } } }
    }
  }



  \stex_debug:n{
    Notation~\l_@@_variant_str \c_hash_str \l_@@_lang_str
    ~for~\prop_item:Nn \l_tmpb_prop { symbol }^^J
    Operator~precedence:~
      \prop_item:Nn \l_tmpb_prop { opprec }^^J
    Argument~precedences:~
      \seq_use:Nn \l_tmpa_seq {,~}^^J
    Notation: \cs_meaning:c {
      stex_notation_ \l_tmpa_str \c_hash_str 
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
      _cs
    }
  }

  \prop_gset_eq:cN {
    g_stex_notation_ \l_tmpa_str \c_hash_str \l_@@_variant_str
      \c_hash_str \l_@@_lang_str _prop
  } \l_tmpb_prop
  
  \exp_args:Nx
  \stex_add_to_current_module:n {
    \prop_get:cnN {
      g_stex_symdecl_ 
        \prop_item:Nn \l_tmpb_prop { symbol }
      _prop 
    } { notations } \exp_not:N \l_tmpa_seq
    \seq_put_right:Nn \exp_not:N \l_tmpa_seq {
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
    }
    \prop_put:cno {
      g_stex_symdecl_ 
        \prop_item:Nn \l_tmpb_prop { symbol }
      _prop
    } { notations } \exp_not:N \l_tmpa_seq
  }

  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        g_stex_notation_ \l_tmpa_str \c_hash_str \l_@@_variant_str
          \c_hash_str \l_@@_lang_str _prop
      } {
        symbol    = \prop_item:Nn \l_tmpb_prop { symbol }     ,
        language  = \prop_item:Nn \l_tmpb_prop { language }   ,
        variant   = \prop_item:Nn \l_tmpb_prop { variant }    ,
        opprec    = \prop_item:Nn \l_tmpb_prop { opprec }     ,
        argprecs  = \prop_item:Nn \l_tmpb_prop { argprecs }   ,
      }
    }
  }{
    \prop_get:NnN \l_tmpa_prop { notations } \l_tmpa_seq
    \seq_put_right:Nx \l_tmpa_seq {
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
    }
    \prop_put:Nno \l_tmpa_prop { notations } \l_tmpa_seq
    \prop_set_eq:cN {
      g_stex_symdecl_ \l_tmpa_str _prop 
    } \l_tmpa_prop

    % HTML annotations
    \stex_annotate_invisible:nnn { notation }
      { \prop_item:Nn \l_tmpb_prop { symbol } } {
        \stex_annotate_invisible:nnn { notationfragment }
          { \l_@@_variant_str \c_hash_str \l_@@_lang_str }{}
        \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
        \stex_annotate_invisible:nnn { precedence }
          { \prop_item:Nn \l_tmpb_prop { opprec };
            \seq_use:Nn \l_tmpa_seq { x }
          }{}

        \int_zero:N \l_tmpa_int
        \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
        \tl_clear:N \l_tmpa_tl
        \int_step_inline:nn { \prop_item:Nn \l_tmpa_prop { arity } }{
          \int_incr:N \l_tmpa_int
          \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
          \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
          \str_if_eq:VnTF \l_tmpb_str a {
            \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl { 
              \c_hash_str \c_hash_str \int_use:N \l_tmpa_int a ,
              \c_hash_str \c_hash_str \int_use:N \l_tmpa_int b
            } }
          }{
            \str_if_eq:VnTF \l_tmpb_str B {
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl { 
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int a ,
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int b
              } }
            }{
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl { 
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int
              } }
            }
          }
        }
        \stex_annotate_invisible:nnn { notationcomp }{}{
          $ \exp_args:Nno \use:nn { \use:c {
            stex_notation_ \prop_item:Nn \l_tmpb_prop { symbol }
            \c_hash_str \l_@@_variant_str
            \c_hash_str \l_@@_lang_str _cs
          } } { \l_tmpa_tl } $
        }
      }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symdef}
%    \begin{macrocode}
\keys_define:nn { stex / symdef } {
  name  .tl_set_x:N  = \l_stex_symdecl_name_str ,
  local .bool_set:N  = \l_stex_symdecl_local_bool ,
  args  .tl_set_x:N  = \l_stex_symdecl_args_str ,
  type  .tl_set:N    = \l_stex_symdecl_type_tl ,
  def    .tl_set:N    = \l_stex_symdecl_definiens_tl ,
  op      .tl_set:N   = \l_@@_op_tl ,
  lang    .tl_set_x:N = \l_@@_lang_str ,
  variant .tl_set_x:N = \l_@@_variant_str ,
  prec    .tl_set_x:N = \l_@@_prec_str ,
  unknown .code:n     = \str_set:Nx 
      \l_@@_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_@@_symdef_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \str_clear:N \l_@@_lang_str
  \str_clear:N \l_@@_variant_str
  \str_clear:N \l_@@_prec_str
  \tl_clear:N \l_@@_op_tl
  
  \keys_set:nn { stex /symdef } { #1 }

  \exp_args:NNo \str_set:Nn \l_stex_symdecl_name_str
    \l_stex_symdecl_name_str
  \exp_args:NNo \str_set:Nn \l_stex_symdecl_args_str
    \l_stex_symdecl_args_str
  \exp_args:NNo \str_set:Nn \l_@@_lang_str
    \l_@@_lang_str
  \exp_args:NNo \str_set:Nn \l_@@_variant_str
    \l_@@_variant_str
  \exp_args:NNo \str_set:Nn \l_@@_prec_str
    \l_@@_prec_str
}

\NewDocumentCommand \symdef { O{} m } {
  \_@@_symdef_args:n { #1 }
  \bool_set_true:N \l_stex_symdecl_make_macro_bool
  \stex_symdecl_do:n { #2 }
  \exp_args:Nx \stex_notation_do:nn { 
    \prop_item:Nn \l_tmpa_prop { module } ?
    \prop_item:Nn \l_tmpa_prop { name }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_invoke_symbol:n}
%
%  Invokes a semantic macro
%
%    \begin{macrocode}
%\cs_new_protected:Nn \stex_invoke_symbol:n {
%  \peek_charcode_remove:NTF ! {
%    \stex_term_custom:nn { #1 } { }
%  } {
%    \if_mode_math:
%      \exp_after:wN \_@@_invoke_math:n
%    \else:
%      \exp_after:wN \_@@_invoke_text:n
%    \fi: { #1 }
%  }
%}

\cs_new_protected:Nn \stex_invoke_symbol:n {
  \if_mode_math:
    \exp_after:wN \_@@_invoke_math:n
  \else:
    \exp_after:wN \_@@_invoke_text:n
  \fi: { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_math:n {
  \peek_charcode_remove:NTF ! {
    \peek_charcode:NTF [ {
      \_@@_invoke_op:nw { #1 }
    }{
      \_@@_invoke_op:nw { #1 } []
    }
  }{
    \peek_charcode_remove:NTF * {
      \_@@_invoke_text:n { #1 }
    }{
      \peek_charcode:NTF [ {
        \_@@_invoke_math:nw { #1 }
      }{
        \_@@_invoke_math:nw { #1 } []
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_@@_invoke_op:nw}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_invoke_op:nw  #1 [#2] {
  \_@@_args:n { #2 }
  \cs_if_exist:cTF {
    stex_op_notation_ #1 \c_hash_str
    \l_@@_variant_str \c_hash_str \l_@@_lang_str _cs
  }{
    \csname stex_op_notation_ #1 \c_hash_str
      \l_@@_variant_str \c_hash_str \l_@@_lang_str _cs
    \endcsname
  }{
    % TODO throw error
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:nw}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_invoke_math:nw  #1 [#2] {
  \_@@_args:n { #2 }
  \prop_set_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop 
  }
  \prop_get:NnN \l_tmpa_prop { notations } \l_tmpa_seq
  \seq_if_empty:NTF \l_tmpa_seq {
    \msg_set:nnn{stex}{error/nonotations}{
      Symbol~#1~used,~but~has~no~notations!
    }
    \msg_error:nn{stex}{error/nonotations}
  } {
    \seq_if_in:NxTF \l_tmpa_seq
      { \l_@@_variant_str \c_hash_str \l_@@_lang_str }{
      \use:c{
        stex_notation_ #1 \c_hash_str
        \l_@@_variant_str \c_hash_str \l_@@_lang_str
        _cs
      }
    }{
      \str_if_empty:NTF \l_@@_variant_str {
        \str_if_empty:NTF \l_@@_lang_str {
          \seq_get_left:NN \l_tmpa_seq \l_tmpa_str
          \use:c{
            stex_notation_ #1 \c_hash_str \l_tmpa_str
            _cs
          }
        }{
          \msg_set:nnn{stex}{error/wrongnotation}{
            Symbol~#1~has~no~notation~
            \l_@@_variant_str \c_hash_str \l_@@_lang_str
          }
          \msg_error:nn{stex}{error/wrongnotation}
        }
      }{
        \msg_set:nnn{stex}{error/wrongnotation}{
          Symbol~#1~has~no~notation~
          \l_@@_variant_str \c_hash_str \l_@@_lang_str
        }
        \msg_error:nn{stex}{error/wrongnotation}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_text:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_text:n {
  \peek_charcode_remove:NTF ! {
    \stex_term_custom:nn { #1 } { }
  }{
    \prop_set_eq:Nc \l_tmpa_prop {
      g_stex_symdecl_ #1 _prop 
    }
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \exp_args:Nnx \stex_term_custom:nn { #1 } { \l_tmpa_str }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Terms}
%    \begin{macrocode}
%<@@=stex_term>
%    \end{macrocode}
%
% Precedences:
% \begin{variable}{\infprec, \neginfprec, \l_@@_downprec}
%    \begin{macrocode}
\tl_const:Nx \infprec {\int_use:N \c_max_int}
\tl_const:Nx \neginfprec {-\int_use:N \c_max_int}
\int_new:N \l_@@_downprec
\int_set_eq:NN \l_@@_downprec \neginfprec
%    \end{macrocode}
% \end{variable}
%
% Bracketing:
%
% \begin{variable}{\l_@@_left_bracket_str, \l_@@_right_bracket_str}
%    \begin{macrocode}
\tl_set:Nn \l_@@_left_bracket_str (
\tl_set:Nn \l_@@_right_bracket_str )
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_maybe_brackets:nn}
%
% Compares precedences and insert brackets accordingly
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_maybe_brackets:nn {
  \int_compare:nNnTF { #1 } > \l_@@_downprec {
    \bool_if:NTF \l_stex_inparray_bool { #2 }{
      \dobrackets { #2 }
    }
  }{ #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\dobrackets}
%    \begin{macrocode}
%\RequirePackage{scalerel}
\cs_new_protected:Npn \dobrackets #1 {
  %\ThisStyle{\if D\m@switch
  %    \exp_args:Nnx \use:nn
  %    { \exp_after:wN \left\l_@@_left_bracket_str #1 } 
  %    { \exp_not:N\right\l_@@_right_bracket_str }
  %  \else
      \exp_args:Nnx \use:nn
      { \l_@@_left_bracket_str #1 } 
      { \l_@@_right_bracket_str }
  %\fi}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\withbrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \withbrackets #1 #2 #3 {
  \exp_args:Nnx \use:nn
  {  
    \tl_set:Nx \l_@@_left_bracket_str { #1 }
    \tl_set:Nx \l_@@_right_bracket_str { #2 }
    #3
  }
  {
    \tl_set:Nn \exp_not:N \l_@@_left_bracket_str 
      {\l_@@_left_bracket_str}
    \tl_set:Nn \exp_not:N \l_@@_right_bracket_str 
      {\l_@@_right_bracket_str}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXinvisible}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXinvisible #1 {
  \stex_annotate_invisible:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \omdoc terms:
%
% \begin{macro}{\_stex_term_math_oms:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_oms:nnn {
  \stex_annotate:nnn{ OMID }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 } 
  }
}

\cs_new_protected:Nn \_stex_term_math_oms:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_oms:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_oma:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_oma:nnn {
  \stex_annotate:nnn{ OMA }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 } 
  }
}

\cs_new_protected:Nn \_stex_term_math_oma:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_oma:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_omb:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_ombind:nnn {
  \stex_annotate:nnn{ OMBIND }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 }
  }
}

\cs_new_protected:Nn \_stex_term_math_omb:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_ombind:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_arg:nnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_arg:nn {
  \stex_unhighlight_term:n { 
    \stex_annotate:nnn{ arg }{ #1 }{ #2 }
  }
}
\cs_new_protected:Nn \_stex_term_math_arg:nnn {
  \exp_args:Nnx \use:nn
    { \int_set:Nn \l_@@_downprec { #2 } 
       \_stex_term_arg:nn { #1 }{ #3 }
    }
    { \int_set:Nn \exp_not:N \l_@@_downprec { \int_use:N \l_@@_downprec } }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_stex_term_math_assoc_arg:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_math_assoc_arg:nnnn {
  \seq_set_split:Nnn \l_tmpa_seq , { #4 }
  \int_compare:nNnTF { \seq_count:N \l_tmpa_seq } < 2 {
    \tl_set:Nn \l_tmpa_tl { #4 }
  }{
    \cs_set:Npn \l_tmpa_cs ##1 ##2 { #3 }
    \seq_reverse:N \l_tmpa_seq
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_tl
    \tl_set:No \l_tmpa_tl { \l_tmpb_tl }

    \seq_map_inline:Nn \l_tmpa_seq {
      \exp_args:NNo \tl_set:No \l_tmpa_tl {
        \exp_args:Nno 
        \l_tmpa_cs { ##1 } \l_tmpa_tl 
      }
    }

  }
  \exp_args:Nnno
  \_stex_term_math_arg:nnn{#1}{#2}\l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_term_custom:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_custom:nn {
  \str_set:Nn \l_@@_custom_uri { #1 }
  \str_set:Nn \l_tmpa_str { #2 }
  \tl_clear:N \l_tmpa_tl
  \int_zero:N \l_tmpa_int
  \int_set:Nn \l_tmpb_int { \str_count:N \l_tmpa_str }
  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_loop:}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_loop: {
  \bool_set_false:N \l_tmpa_bool
  \bool_while_do:nn {
    \str_if_eq_p:ee X {
      \str_item:Nn \l_tmpa_str { \l_tmpa_int + 1 }
    }
  }{
    \int_incr:N \l_tmpa_int
  }

  \peek_charcode:NTF [ {
    % notation/text component
    \_@@_custom_component:w
  } {
    \int_compare:nNnTF \l_tmpa_int = \l_tmpb_int {
      % all arguments read => finish
      \_@@_custom_final:
    } {
      % arguments missing
      \peek_charcode_remove:NTF * {
        % invisible, specific argument position or both
        \peek_charcode:NTF [ {
          % visible specific argument position
          \_@@_custom_arg:wn
        } {
          % invisible
          \peek_charcode_remove:NTF * {
            % invisible specific argument position
            \_@@_custom_arg_inv:wn
          } {
            % invisible next argument
            \_@@_custom_arg_inv:wn [ \l_tmpa_int + 1 ]
          }
        } 
      } {
        % next normal argument
        \_@@_custom_arg:wn [ \l_tmpa_int + 1 ]
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_arg_inv:wn}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_arg_inv:wn [ #1 ] #2 {
  \bool_set_true:N \l_tmpa_bool
  \_@@_custom_arg:wn [ #1 ] { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_arg:wn}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_arg:wn [ #1 ] #2 {
  \str_set:Nx \l_tmpb_str { 
    \str_item:Nn \l_tmpa_str { #1 }
  }
  \str_case:VnTF \l_tmpb_str {
    { X } { } % TODO throw error ?
    { i } { \_@@_custom_set_X:n { #1 } }
    { b } { \_@@_custom_set_X:n { #1 } }
    { a } { \_@@_custom_set_X:n { #1 } } % TODO ?
    { B } { \_@@_custom_set_X:n { #1 } } % TODO ?
  }{}{
    % TODO throw error
  }

  \bool_if:nTF \l_tmpa_bool {
    \tl_put_right:Nx \l_tmpa_tl {
      \stex_annotate_invisible:n {
        \_stex_term_arg:nn { \int_eval:n { #1 } } 
          \exp_not:n { { #2 } }
      }
    }
  } {
    \tl_put_right:Nx \l_tmpa_tl {
      \_stex_term_arg:nn { \int_eval:n { #1 } } 
        \exp_not:n { { #2 } }
    }
  }

  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_set_X:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_set_X:n {
  \str_set:Nx \l_tmpa_str {
    \str_range:Nnn \l_tmpa_str 1 { #1 - 1 }
    X
    \str_range:Nnn \l_tmpa_str { #1 + 1 } { -1 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_component:}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_component:w [ #1 ] {
  \tl_put_right:Nn \l_tmpa_tl { \comp{ #1 } }
  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_final:}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_final: {
  \int_compare:nNnTF \l_tmpb_int = 0 {
    \exp_args:Nnno \_stex_term_oms:nnn
  }{
    \str_if_in:NnTF \l_tmpa_str {b} {
      \exp_args:Nnno \_stex_term_ombind:nnn
    } {
      \exp_args:Nnno \_stex_term_oma:nnn
    }
  }
  { \l_@@_custom_uri } { \l_@@_custom_uri } { \l_tmpa_tl }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symref,\symname}
%    \begin{macrocode}
\NewDocumentCommand \symref { m m }{
  \STEXsymbol{#1}![#2]
}

\keys_define:nn { stex / symname } {
  post    .tl_set_x:N   = \l_stex_symname_post_str
}

\cs_new_protected:Nn \stex_symname_args:n {
  \str_clear:N \l_stex_symname_post_str
  \keys_set:nn { stex / symname } { #1 }
  \exp_args:NNo \str_set:Nn \l_stex_symname_post_str
    \l_stex_symname_post_str
}

\NewDocumentCommand \symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }![
    \l_tmpa_str \l_stex_symname_post_str
  ] }
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Notation Components}
%    \begin{macrocode}
%<@@=stex_notationcomps>
%    \end{macrocode}
%
%
% \begin{macro}{\stex_highlight_term:nn}
%    \begin{macrocode}
\latexml_if:F {
  \scalatex_if:F{
   % \RequirePackage{pdfcomment}
  }
}

\str_new:N \l_@@_highlight_uri_str
\cs_new_protected:Nn \stex_highlight_term:nn {
  \exp_args:Nnx
  \use:nn {
    \str_set:Nx \l_@@_highlight_uri_str { #1 }
    #2
  } {
    \str_set:Nx \exp_not:N \l_@@_highlight_uri_str 
      { \l_@@_highlight_uri_str }
  }
}

\cs_new_protected:Nn \stex_unhighlight_term:n {
%  \latexml_if:TF {
%    #1
%  } {
%    \scalatex_if:TF {
%      #1
%    } {
      #1 %\iffalse{{\fi}} #1 {{\iffalse}}\fi
%    }
%  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\comp,\@comp,\@defemph}
%    \begin{macrocode}
\cs_new_protected:Npn \comp #1 {
  \str_if_empty:NF \l_@@_highlight_uri_str {
    \scalatex_if:TF {
      \stex_annotate:nnn { comp }{ \l_@@_highlight_uri_str }{ #1 }
    }{
      \exp_args:Nnx \@comp { #1 } { \l_@@_highlight_uri_str }
    }
  }
}

\cs_new_protected:Npn \@comp #1 #2 {
 % \pdftooltip {
    \textcolor{blue}{#1}
 % } { #2 }
}

\cs_new_protected:Npn \@defemph #1 #2 {
 % \pdftooltip { 
    \textbf{\textcolor{magenta}{#1}}
 % } { #2 }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\ellipses}
%    \begin{macrocode}
\NewDocumentCommand \ellipses {} { \ldots }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\parray,\prmatrix,\parrayline,\parraycell}
%    \begin{macrocode}
\bool_new:N \l_stex_inparray_bool
\bool_set_false:N \l_stex_inparray_bool
\NewDocumentCommand \parray { m m } {
  \begingroup 
  \bool_set_true:N \l_stex_inparray_bool
  \begin{array}{#1}
    #2
  \end{array}
  \endgroup
}

\NewDocumentCommand \prmatrix { m } {
  \begingroup 
  \bool_set_true:N \l_stex_inparray_bool
  \begin{matrix}
    #1
  \end{matrix}
  \endgroup
}

\def \parrayline #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\}
}

\def \parraycell #1 {
  #1 \bool_if:NT \l_stex_inparray_bool {&}
}
%    \end{macrocode}
% \end{macro}
%
% \subsection{Structural Features}
%    \begin{macrocode}
%<@@=stex_features>
%    \end{macrocode}
%
% \begin{environment}{symboldoc}
%    \begin{macrocode}
\NewDocumentEnvironment{symboldoc}{ m }{
  \seq_set_split:Nnn \l_tmpa_seq , { #1 }
  \seq_clear:N \l_tmpb_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \stex_get_symbol:n { ##1 }
    \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
      \l_stex_get_symbol_uri_str
    }
  }
  \par
  \exp_args:Nnnx
  \begin{stex_annotate_env}{symboldoc}{\seq_use:Nn \l_tmpb_seq {,}}
}{
  \end{stex_annotate_env}
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{environment}{STEXdefinition}
%    \begin{macrocode}

\NewDocumentCommand \_@@_definiendum:w { O{} m m} {
  \stex_get_symbol:n { #2 }
  \scalatex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { #3 }
  } {
    \exp_args:Nnx \@defemph { #3 } { \l_stex_get_symbol_uri_str }
  }
}
\NewDocumentCommand \_@@_definame:w { O{} m } {
  % TODO: root
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \scalatex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { 
      \l_tmpa_str
     }
  } {
    \@defemph {
      \l_tmpa_str
    } { \l_stex_get_symbol_uri_str }
  }
}

\cs_new_protected:Nn \_@@_defi_begin:n {
  \let\definiendum\_@@_definiendum:w
  \let\definame\_@@_definame:w
  \seq_set_split:Nnn \l_tmpa_seq , { #1 }
  \seq_clear:N \l_tmpb_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \stex_get_symbol:n { ##1 }
    \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
      \l_stex_get_symbol_uri_str
    }
  }
  \exp_args:Nnnx
  \begin{stex_annotate_env}{definition}{\seq_use:Nn \l_tmpb_seq {,}}
}

\cs_new_protected:Nn \_@@_defi_end: {
  \end{stex_annotate_env}
}

\NewDocumentEnvironment{STEXdefinition}{ m }{
  \_@@_defi_begin:n { #1 }
}{
  \_@@_defi_end:
}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\setSTEXdefinition}
%    \begin{macrocode}
\cs_new_protected:Npn \setSTEXdefinition #1 {
  \AddToHook{env/#1/before}[stex]{\_@@_defi_begin:n{}}
  \AddToHook{env/#1/after}[stex]{\_@@_defi_end:}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{environment}{structural@feature}
%    \begin{macrocode}

\NewDocumentEnvironment{structural@feature}{ m m m }{
  \stex_if_in_module:F {
    \msg_set:nnn{stex}{error/nomodule}{
      Structural~Feature~has~to~occur~in~a~module:\\
      Feature~#2~of~type~#1\\
      In~File:~\stex_path_to_string:N \g_stex_currentfile_seq
    }
    \msg_error:nn{stex}{error/nomodule}
  }

  \str_set:Nx \l_stex_module_name_str {
    \prop_item:Nn \l_stex_current_module_prop
      { name } / #2 - feature
  }

  
  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
    origname  = #2,
    name      = \l_stex_module_name_str ,
    ns        = \l_stex_module_ns_str ,
    imports   = \exp_not:o { \l_tmpa_seq } ,
    constants = \exp_not:o { \l_tmpa_seq } ,
    content   = \exp_not:o { \l_tmpa_tl }  ,
    file      = \exp_not:o { \g_stex_currentfile_seq } ,
    lang      = \l_stex_module_lang_str ,
    sig       = \l_tmpa_str ,
    meta      = \l_tmpa_str ,
    feature   = #1 ,
  }

  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env}{ feature:#1 }{}
      \stex_annotate_invisible:nnn{header}{}{ #3 }
  }
}{  
  \str_set:Nx \l_tmpa_str {
    c_stex_feature_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \prop_gset_eq:NN \g_stex_last_feature_prop \l_stex_current_module_prop
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        c_stex_feature_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        origname  = #2,
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        imports   = \prop_item:cn { \l_tmpa_str } { imports } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta } ,
        feature   = \prop_item:cn { \l_tmpa_str } { feature }
      }
    }
  } {
      \end{stex_annotate_env}
  }
}

%    \end{macrocode}
% \end{environment}
%
%
%
% \begin{environment}{structure}
%    \begin{macrocode}

\prop_new:N \l_stex_all_structures_prop

\keys_define:nn { stex / features / structure } {
  name         .tl_set_x:N  = \l_@@_structure_name_str ,
}

\cs_new_protected:Nn \_@@_structure_args:n {
  \str_clear:N \l_@@_structure_name_str
  \keys_set:nn { stex / features / structure } { #1 }
  \exp_args:NNo \str_set:Nn \l_@@_structure_name_str
    \l_@@_structure_name_str
}

%\stex_new_feature:nnnn { structure } { O{} m } {
%  \_@@_structure_args:n { ##1 }
%  \str_if_empty:NT \l_@@_structure_name_str {
%    \str_set:Nx \l_@@_structure_name_str { ##2 }
%  }
%} {
%
%}

\NewDocumentEnvironment{structure}{ O{} m }{
  \_@@_structure_args:n { #1 }
  \str_if_empty:NT \l_@@_structure_name_str {
    \str_set:Nx \l_@@_structure_name_str { #2 }
  }
  \exp_args:Nnnx
  \begin{structural@feature}{ structure }
    { \l_@@_structure_name_str }{}
    \seq_clear:N \l_tmpa_seq
    \prop_put:Nno \l_stex_current_module_prop { fields } \l_tmpa_seq

}{
    \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
    \prop_get:NnN \l_stex_current_module_prop { fields } \l_tmpb_seq
    \str_set:Nx \l_tmpa_str {
      \prop_item:Nn \l_stex_current_module_prop { ns } ?
      \prop_item:Nn \l_stex_current_module_prop { name }
    }
    \seq_map_inline:Nn \l_tmpa_seq {
      \exp_args:NNx \seq_put_right:Nn \l_tmpb_seq { \l_tmpa_str ? ##1 }
    }
    \prop_put:Nno \l_stex_current_module_prop { fields } { \l_tmpb_seq }
    \exp_args:Nnx
    \AddToHookNext { env / structure / after }{
      \symdecl[type = \exp_not:N\collection,def={\STEXsymbol{module-type}{
        \_stex_term_math_oms:nnnn { \l_tmpa_str }{}{0}{}
      }}, name = \prop_item:Nn \l_stex_current_module_prop { origname }]{ #2 }
      \STEXexport {
        \prop_put:Nno \exp_not:N \l_stex_all_structures_prop 
          {\prop_item:Nn \l_stex_current_module_prop { origname }}
          {\l_tmpa_str}
          \prop_put:Nno \exp_not:N \l_stex_all_structures_prop 
            {#2}{\l_tmpa_str}
%        \seq_put_right:Nn \exp_not:N \l_stex_all_structures_seq {
%          \prop_item:Nn \l_stex_current_module_prop { origname },
%          \l_tmpa_str
%        }
%        \seq_put_right:Nn \exp_not:N \l_stex_all_structures_seq {
%          #2,\l_tmpa_str
%        }
%        \tl_set:cx { #2 } { 
%          \stex_invoke_structure:n { \l_tmpa_str }
      }
    }
    
  \end{structural@feature}
  % \g_stex_last_feature_prop
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}{\instantiate}
%    \begin{macrocode}
\seq_new:N \l_@@_structure_field_seq
\str_new:N \l_@@_structure_field_str
\str_new:N \l_@@_structure_def_tl
\prop_new:N \l_@@_structure_prop
\NewDocumentCommand \instantiate { m O{} m }{
  \stex_smsmode_set_codes:
  \prop_get:NnN \l_stex_all_structures_prop {#1} \l_tmpa_str
  \prop_set_eq:Nc \l_@@_structure_prop {
    c_stex_feature_\l_tmpa_str _prop
  }
  \seq_set_from_clist:Nn \l_@@_structure_field_seq { #2 }
  \seq_map_inline:Nn \l_@@_structure_field_seq {
    \seq_set_split:Nnn \l_tmpa_seq{=}{ ##1 }
    \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
      \seq_get_left:NN \l_tmpa_seq \l_tmpa_tl
      \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq
      {!} \l_tmpa_tl 
        \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
          \str_set:Nx \l_@@_structure_field_str {\seq_item:Nn \l_tmpb_seq 1}
          \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
          \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
        }{
          \str_set:Nx \l_@@_structure_field_str \l_tmpa_tl
          \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
          \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq{!}
            \l_tmpa_tl 
          \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
            \seq_get_left:NN \l_tmpb_seq \l_tmpa_tl
            \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
          }{
            \tl_clear:N \l_tmpb_tl
          }
        }
    }{
      \seq_set_split:Nnn \l_tmpa_seq{!}{ ##1 }
      \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
        \str_set:Nx \l_@@_structure_field_str {\seq_item:Nn \l_tmpa_seq 1}
        \seq_get_right:NN \l_tmpa_seq \l_tmpb_tl
        \tl_clear:N \l_tmpa_tl
      }{
        % TODO throw error
      }
    }
    % \l_tmpa_str: name
    % \l_tmpa_tl: definiens
    % \l_tmpb_tl: notation
    \tl_if_empty:NT \l_@@_structure_field_str { 
      % TODO throw error
    }
    \str_clear:N \l_tmpb_str
    
    \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ####1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpb_str
      \str_if_eq:NNT \l_@@_structure_field_str \l_tmpb_str {
        \seq_map_break:n {
          \str_set:Nn \l_tmpb_str { ####1 }
        }
      }
    }
    \prop_get:cnN { g_stex_symdecl_ \l_tmpb_str _prop } {args}
      \l_tmpb_str

    \tl_if_empty:NTF \l_tmpb_tl {
      \tl_if_empty:NF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdecl[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l_@@_structure_field_str}
        }
      }
    }{
      \tl_if_empty:NTF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str]{#3/\l_@@_structure_field_str}\exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }

      }{
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l_@@_structure_field_str}
          \exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }
      }
    }
%    \par \prop_item:Nn \l_stex_current_module_prop {ns} ?
%    \prop_item:Nn \l_stex_current_module_prop {name} ?
%    #3/\l_@@_structure_field_str
%    \par
%    \expandafter\present\csname
%      g_stex_symdecl_
%      \prop_item:Nn \l_stex_current_module_prop {ns} ?
%      \prop_item:Nn \l_stex_current_module_prop {name} ?
%      #3/\l_@@_structure_field_str
%      _prop
%    \endcsname
  }

  \tl_clear:N \l_@@_structure_def_tl

  \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
    \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
    \exp_args:Nx \use:n {
      \tl_put_right:Nn \exp_not:N \l_@@_structure_def_tl {

      }
    }

    \prop_if_exist:cF {
      g_stex_symdecl_
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ?
      #3/\l_tmpa_str
      _prop
    }{
      \prop_get:cnN { g_stex_symdecl_ ##1 _prop } {args}
        \l_tmpb_str
      \exp_args:Nx \use:n {
        \symdecl[args=\l_tmpb_str]{#3/\l_tmpa_str}
      }
    }
  }

  \symdecl*[type={\STEXsymbol{module-type}{
    \_stex_term_math_oms:nnnn {
      \prop_item:Nn \l_@@_structure_prop {ns} ?
      \prop_item:Nn \l_@@_structure_prop {name}
     }{}{0}{}
  }}]{#3}
  
  % TODO: -> sms file

  \tl_set:cx{ #3 }{
    \stex_invoke_structure:nnn {
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ? #3
    } {
      \prop_item:Nn \l_@@_structure_prop {ns} ?
      \prop_item:Nn \l_@@_structure_prop {name}
    }
  }

}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\stex_invoke_structure:nnn}
%    \begin{macrocode}
% #1: URI of the instance
% #2: URI of the instantiated module
\cs_new_protected:Nn \stex_invoke_structure:nnn {
  \tl_if_empty:nTF{ #3 }{  
    \prop_set_eq:Nc \l_@@_structure_prop {
      c_stex_feature_ #2 _prop
    }
    \tl_clear:N \l_tmpa_tl
    \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
      \cs_if_exist:cT {
        stex_notation_ #1/\l_tmpa_str \c_hash_str\c_hash_str _cs
      }{
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_put_right:Nn \l_tmpa_tl {,}
        }
        \tl_put_right:Nx \l_tmpa_tl {
          \stex_invoke_symbol:n {#1/\l_tmpa_str}!
        }
      }
    }
    \exp_args:No \mathstruct \l_tmpa_tl
  }{
    \stex_invoke_symbol:n{#1/#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
%
%
%
%
% \subsection{Put these somewhere}
%
% \begin{macro}{\MSC}
%    \begin{macrocode}
\NewDocumentCommand \MSC {m} {
  % TODO
}
%    \end{macrocode}
% \end{macro}
%
%
%
%    \begin{macrocode}
\@ifpackageloaded{tikzinput}{
  \RequirePackage{stex-tikzinput}
}{}

\AddToHook{begindocument}{
  \input{stex-metatheory}
}
%    \end{macrocode}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \subsection{Metatheory}
%
% The default meta theory for an \sTeX module. Contains
% symbols so ubiquitous, that it is virtually impossible
% to describe any flexiformal content without them, or
% that are required to annotate even the most primitive symbols
% with meaningful (foundation-independent) ``type''-annotations,
% or required for basic structuring principles (theorems, definitions).
%
% Foundations should ideally instantiate these symbols
% with their formal counterparts, e.g. |isa| corresponds
% to a typing operation in typed setting, or the $\in$-operator
% in set-theoretic contexts; |bind| corresponds to a universal
% quantifier in ($n$th-order) logic, or a $\Pi$ in dependent type
% theories.
%
%    \begin{macrocode}
%<*metatheory>
\ExplSyntaxOn
\str_const:Nn \c_stex_metatheory_ns_str {http://mathhub.info/sTeX}
\begin{@module}[ns=\c_stex_metatheory_ns_str,meta=NONE]{Metatheory}
  \ExplSyntaxOff

  % is-a (a:A, a \in A, a is an A, etc.)
  \symdecl[args=ai]{isa}
  \notation[typed]{isa}{#1 \comp: #2}{#1 \comp, #2}
  \notation[in]{isa}{#1 \comp\in #2}{#1 \comp, #2}
  \notation[pred]{isa}{#2\comp(#1 \comp)}{#1 \comp, #2}

  % bind (\forall, \Pi, \lambda etc.)
  \symdecl[args=Bi]{bind}
  \notation[forall]{bind}{\comp\forall #1.\;#2}{#1 \comp, #2}
  \notation[Pi]{bind}{\comp\prod_{#1}#2}{#1 \comp, #2}
  \notation[depfun]{bind}{\comp( #1 \comp{)\;\to\;} #2}{#1 \comp, #2}

  % dummy variable
  \symdecl{dummyvar}
  \notation[underscore]{dummyvar}{\comp\_}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dash]{dummyvar}{\comp{{\rm --}}}

  %fromto (function space, Hom-set, implication etc.)
  \symdecl[args=ai]{fromto}
  \notation[xarrow]{fromto}{#1 \comp\to #2}{#1 \comp\times #2}
  \notation[arrow]{fromto}{#1 \comp\to #2}{#1 \comp\to #2}

  % mapto (lambda etc.)
  %\symdecl[args=Bi]{mapto}
  %\notation[mapsto]{mapto}{#1 \comp\mapsto #2}{#1 \comp, #2}
  %\notation[lambda]{mapto}{\comp\lambda #1 \comp.\; #2}{#1 \comp, #2}
  %\notation[lambdau]{mapto}{\comp\lambda_{#1} \comp.\; #2}{#1 \comp, #2}
  
  % function/operator application
  \symdecl[args=ia]{apply}
  \notation[prec=0;0x\neginfprec,parens]{apply}{#1 \comp( #2 \comp)}{#1 \comp, #2}
  \notation[prec=0;0x\neginfprec,lambda]{apply}{#1 \; #2 }{#1 \; #2}

  % ``type'' of all collections (sets,classes,types,kinds)
  \symdecl{collection}
  \notation[U]{collection}{\comp{\mathcal{U}}}
  \notation[set]{collection}{\comp{\textsf{Set}}}

  % sequences
  \symdecl[args=1]{seqtype}
  \notation[kleene]{seqtype}{#1^{\comp\ast}}

  \symdef[args=2,li]{sequence-index}{#1_{#2}}
  \notation[ui]{sequence-index}{#1^{#2}}

  %\symdef[args=3,li]{sequence-from-to}{#1_{#2}\comp{,\ellipses,}#1_{#3}}
  %\notation[ui]{sequence-from-to}{#1^{#2}\comp{,\ellipses,}#1^{#3}}
  % ^ superceded by \aseqfromto and \livar/\uivar

  \symdef[args=a,prec=nobrackets]{aseqdots}{#1\comp{,\ellipses}}{#1\comp,#2}
  \symdef[args=ai,prec=nobrackets]{aseqfromto}{#1\comp{,\ellipses\comp,}#2 }{#1\comp,#2} 

  % letin (``let'', local definitions, variable substitution)
  \symdecl[args=bii]{letin}
  \notation[let]{letin}{\comp{{\rm let}}\;#1\comp{=}#2\;\comp{{\rm in}}\;#3}
  \notation[subst]{letin}{#3 \comp[ #1 \comp/ #2 \comp]}
  \notation[frac]{letin}{#3 \comp[ \frac{#2}{#1} \comp]}

  % structures
  \symdecl*[args=1]{module-type}
  \notation{module-type}{\mathtt{MOD} #1}
  \symdecl[name=mathematical-structure,args=a]{mathstruct} % TODO
  \notation[angle,prec=nobrackets]{mathstruct}{\comp\langle #1 \comp\rangle}{#1 \comp, #2}

  \STEXexport{
    \let\nappa\apply
    \def\nappli#1#2#3#4{\apply{#1}{\naseqli{#2}{#3}{#4}}}
    \def\livar{\csname sequence-index\endcsname[li]}
    \def\uivar{\csname sequence-index\endcsname[ui]}
    \def\naseqli#1#2#3{\aseqfromto{\livar{#1}{#2}}{\livar{#1}{#3}}}
    \def\nasequi#1#2#3{\aseqfromto{\uivar{#1}{#2}}{\uivar{#1}{#3}}}
  }

\end{@module}
\ExplSyntaxOff
%</metatheory>
%    \end{macrocode}
%
%
%
% \subsection{Auxiliary Packages}
%
% \subsubsection{tikzinput}
%    \begin{macrocode}
%<*tikzinput>
%<@@=tikzinput>
\ProvidesExplPackage{tikzinput}{2021/08/31}{1.9}{bla}
\RequirePackage{l3keys2e}

\keys_define:nn { tikzinput } {
  image   .bool_set:N   = \c_tikzinput_image_bool
}

\ProcessKeysOptions { tikzinput }

\bool_if:NTF \c_tikzinput_image_bool {
  \RequirePackage{graphicx}

  \providecommand\usetikzlibrary[]{}
  \newcommand\tikzinput[2][]{\includegraphics[#1]{#2}}
}{
  \RequirePackage{tikz}
  \RequirePackage{standalone}

  \newcommand \tikzinput [2] [] {
    \setkeys{Gin}{#1}
    \ifx \Gin@width \Gin@exclamation
      \ifx \Gin@height \Gin@exclamation
        \input { #2 }
      \else
        \resizebox{!}{ \Gin@height }{
          \input { #2 }
        }
      \fi
    \else
      \ifx \Gin@height \Gin@exclamation
        \resizebox{ \Gin@width }{!}{
          \input { #2 }
        }
      \else
        \resizebox{ \Gin@width }{ \Gin@height }{
          \input { #2 }
        }
      \fi
    \fi
  }
}

\newcommand \ctikzinput [2] [] {
  \begin{center}
    \tikzinput [#1] {#2}
  \end{center}
}

\@ifpackageloaded{stex}{
  \RequirePackage{stex-tikzinput}
}{}
%</tikzinput>
%    \end{macrocode}
%
%    \begin{macrocode}
%<*stex-tikzinput>
\ProvidesExplPackage{stex-tikzinput}{2021/08/31}{1.9}{bla}
\RequirePackage{stex}
\RequirePackage{tikzinput}

% TODO

%</stex-tikzinput>
%    \end{macrocode}
%
% \subsubsection{{\sTeX}1 Compatibility}
%
%    \begin{macrocode}
%<*smglom>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplClass{smglom}{2021/08/01}{1.9}{sTeX1 compatibility}
\LoadClass[border=1px,varwidth]{standalone}
\setlength\textwidth{15cm}
%\g@addto@macro{\@parboxrestore}{\setlength\parskip{\baselineskip}}
\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{stex}}
\ProcessOptions

\RequirePackage{stex-compatibility}
%</smglom>

%<*compat>
%<@@=stex_deprec>
\ProvidesExplPackage{stex-compatibility}{2021/08/01}{1.9}{bla}
\RequirePackage[lang={de,en,ro,tr,fr}]{stex}

\NewDocumentEnvironment { mhmodnl } { O{} m m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    Environment~mhmodnl~is~deprected! \\
    Please~update~module~#2~in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq!
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}

  \begin{module}[#1,lang=#3]{#2}
    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
    \seq_set_split:NnV \l_tmpb_seq . \l_tmpa_str
    \seq_pop_left:NN \l_tmpb_seq \l_tmpa_str
    \input { \stex_path_to_string:N \l_tmpa_seq / \l_tmpa_str.tex }
} {
  \end{module}
}

\NewDocumentEnvironment { modsig } { O{} m } {
  \stex_if_in_module:TF {
    \prop_get:NnN \l_stex_current_module_prop {name} \l_tmpa_str
    \str_set:Nn \l_tmpb_str { #2 }
    \str_if_eq:NNTF \l_tmpa_str \l_tmpb_str {
      \prop_set_eq:NN \l_modsig_old_module_prop \l_stex_current_module_prop
      \begin{@module}{modsig-#2}
       % \prop_set_eq:NN \l_stex_current_module_prop \l_modsig_old_module_prop 
    } {
      \begin{@module}{#2}
    }
  } {
    \begin{@module}{#2}
  }
}{
  \end{@module}
  \AddToHookNext { env / modsig / after }{
    \stex_if_in_module:T {
      \prop_get:NnN \l_stex_current_module_prop {name} \l_tmpa_str
      \str_set:Nn \l_tmpb_str { #2 }
      \str_if_eq:NNT \l_tmpa_str \l_tmpb_str {
  %      \xdef \g_stex_module_after_group_tl {
          \stex_if_smsmode:TF {          
            \exp_args:Nx
            \stex_add_to_current_module:n {
              \stex_debug:n{Activating~signature~of~#2}
              \exp_not:N \prop_item:cn { c_stex_module_ 
              \prop_item:Nn \l_stex_current_module_prop {ns} ?
              \prop_item:Nn \l_stex_current_module_prop {name}
              / modsig-#2_prop } { content }
            }
          } 
          {
            \gdef \g_stex_modsig_after_group_tl  {
              \stex_activate_module:n {
                \prop_item:Nn \l_stex_current_module_prop {ns} ?
                \prop_item:Nn \l_stex_current_module_prop {name}
                / modsig-#2
              }
              
              \exp_args:Nx
              \stex_add_to_current_module:n {
                \stex_activate_module:n {
                  \prop_item:Nn \l_stex_current_module_prop {ns} ?
                  \prop_item:Nn \l_stex_current_module_prop {name}
                  / modsig-#2
                }
              }
            }
            \aftergroup \g_stex_modsig_after_group_tl
          }
      }
    }
  }
}

\cs_new_protected:Npn \gimport {
  \peek_charcode_remove:NTF * {
    \gimport_do:
  } {
    \gimport_do:
  }
}

\NewDocumentCommand \gimport_do: { O{} m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str gimport~is~deprecated! \\
    Please~use~\c_backslash_str importmodule[#1]{#2}~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}
  \importmodule[#1]{#2}
}

\cs_new_protected:Npn \guse {
  \peek_charcode_remove:NTF * {
    \guse_do:
  } {
    \guse_do:
  }
}

\NewDocumentCommand \guse_do: { O{} m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str guse~is~deprecated! \\
    Please~use~\c_backslash_str usemodule[#1]{#2}~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}
  \usemodule[#1]{#2}
}

\cs_new:Nn \stex_capitalize:n { \uppercase{#1} }

\cs_new_protected:Npn \symi {
  \peek_charcode_remove:NTF * {
    \symi_do:
  } {
    \symi_do:
  }
}

\NewDocumentCommand \symi_do: { O{} m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str symi~is~deprecated! \\
    Please~use~\c_backslash_str symdecl[#1]{#2}~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}
  \symdecl*[#1]{#2}
}

\cs_new_protected:Npn \symii {
  \peek_charcode_remove:NTF * {
    \symii_do:
  } {
    \symii_do:
  }
}

\NewDocumentCommand \symii_do: { O{} m m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str symii~is~deprecated! \\
    Please~use~\c_backslash_str symdecl[#1]{#2-#3}~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}
  \symdecl*[#1]{#2-#3}
}

\cs_new_protected:Npn \symiii {
  \peek_charcode_remove:NTF * {
    \symiii_do:
  } {
    \symiii_do:
  }
}

\NewDocumentCommand \symiii_do: { O{} m m m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str symiii~is~deprecated! \\
    Please~use~\c_backslash_str symdecl[#1]{#2-#3-#4}~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}
  \symdecl*[#1]{#2-#3-#4}
}

\keys_define:nn { stex / deprec / defi } {
  name  .tl_set_x:N = \l_tmpa_str
}

\cs_new_protected:Npn \defi {
  \peek_charcode_remove:NTF * {
    \defi_do:
  } {
    \defi_do:
  }
}

\NewDocumentCommand \defi_do: { O{} m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![#2]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{#2} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2} ]
  }
}


\cs_new_protected:Npn \Defi {
  \peek_charcode_remove:NTF * {
    \Defi_do:
  } {
    \Defi_do:
  }
}

\NewDocumentCommand \Defi_do: { O{} m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Defi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![\exp_after:wN \stex_capitalize:n #2]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{\exp_after:wN \stex_capitalize:n #2} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Defi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ \exp_after:wN \stex_capitalize:n #2 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{\exp_after:wN \stex_capitalize:n #2} ]
  }
}

\cs_new_protected:Npn \adefi {
  \peek_charcode_remove:NTF * {
    \adefi_do:
  } {
    \adefi_do:
  }
}

\NewDocumentCommand \adefi_do: { O{} m m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str adefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#3}![#2]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #3 }![ \comp{#2} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str adefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2} ]
  }
}

\cs_new_protected:Npn \defis {
  \peek_charcode_remove:NTF * {
    \defis_do:
  } {
    \defis_do:
  }
}

\NewDocumentCommand \defis_do: { O{} m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![#2s]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{#2s} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2s ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2s} ]
  }
}

\cs_new_protected:Npn \defii {
  \peek_charcode_remove:NTF * {
    \defii_do:
  } {
    \defii_do:
  }
}

\NewDocumentCommand \defii_do: { O{} m m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3}![#2~#3]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3 }![ \comp{#2~#3} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2~#3 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2~#3} ]
  }
}


\cs_new_protected:Npn \defiis {
  \peek_charcode_remove:NTF * {
    \defiis_do:
  } {
    \defiis_do:
  }
}

\NewDocumentCommand \defiis_do: { O{} m m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defiis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3}![#2~#3s]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3 }![ \comp{#2~#3s} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defiis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2~#3s ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2~#3s} ]
  }
}


\cs_new_protected:Npn \defiii {
  \peek_charcode_remove:NTF * {
    \defiii_do:
  } {
    \defiii_do:
  }
}

\NewDocumentCommand \defiii_do: { O{} m m m } {
  \str_clear:N \l_tmpa_str
  \keys_set:nn { stex / deprec / defi } { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defiii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3-#4}![#2~#3~#4]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3-#4 }![ \comp{#2~#3~#4} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str defiii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { \l_tmpa_str }[ #2~#3~#4 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \exp_args:No \STEXsymbol { \l_tmpa_str }![ \comp{#2~#3~#4} ]
  }
}

%\RequirePackage[hyperref]{ntheorem}
%\theoremstyle{plain}
%\RequirePackage{amsthm}

\NewDocumentEnvironment {definition} { O{} } {
  \begin{STEXdefinition}{}
}{
  \end{STEXdefinition}
}
\keys_define:nn { stex / omtext} {
  id   .tl_set_x:N   = \l_stex_omtext_id_str , 
  title   .tl_set_x:N   = \l_stex_omtext_title_str , 
  type    .tl_set_x:N   = \l_stex_omtext_type_tl ,
  for     .tl_set_x:N   = \l_stex_omtext_for_tl ,
  from    .tl_set_x:N   = \l_stex_omtext_from_tl ,
  start   .tl_set_x:N   = \l_stex_omtext_start_str ,
}
\cs_new_protected:Nn \stex_omtext_args:n {
  \str_clear:N \l_stex_omtext_title_str
  \str_clear:N \l_stex_omtext_start_str
  \keys_set:nn { stex / omtext }{ #1 }
  \exp_args:NNo \str_set:Nn \l_stex_omtext_title_str
    \l_stex_omtext_title_str
  \exp_args:NNo \str_set:Nn \l_stex_omtext_start_str
    \l_stex_omtext_start_str
}
\NewDocumentEnvironment {omtext} { O{} } {
  \stex_omtext_args:n { #1 }
  \textbf{\str_if_empty:NTF \l_stex_omtext_start_str {
    \l_stex_omtext_title_str
  }{
    \l_stex_omtext_start_str :
  }}
}{
  
}
\NewDocumentEnvironment {assertion} { O{} } {
  
}{
  
}

\NewDocumentCommand \inlinedef { m } {
  \begingroup
  \let\definiendum\_@@_definiendum:w
  \let\definame\_@@_definame:w
  #1
  \endgroup
}

\NewDocumentCommand \inlineass { m } { #1 }

\NewDocumentCommand \trefi { O{} m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![#2]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{#2} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1?#2 }[ #2 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{#2} ]
  }
}


\NewDocumentCommand \Trefi { O{} m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![\exp_after:wN \stex_capitalize:n #2]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{\exp_after:wN \stex_capitalize:n #2} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ \exp_after:wN \stex_capitalize:n #2 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{\exp_after:wN \stex_capitalize:n #2} ]
  }
}

\NewDocumentCommand \trefis { O{} m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![#2s]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{#2s} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefi~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ #2s ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{#2s} ]
  }
}


\NewDocumentCommand \Trefis { O{} m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Trefis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2}![\exp_after:wN \stex_capitalize:n #2s]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2 }![ \comp{\exp_after:wN \stex_capitalize:n #2s} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str Trefis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ \exp_after:wN \stex_capitalize:n #2s ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{\exp_after:wN \stex_capitalize:n #2s} ]
  }
}

\NewDocumentCommand \trefii { O{} m m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3}![#2~#3]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3 }![ \comp{#2~#3} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ #2~#3 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{#2~#3} ]
  }
}

\NewDocumentCommand \trefiii { O{} m m m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefiii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3-#4}![#2~#3~#4]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3-#4 }![ \comp{#2~#3~#4} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefiii~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ #2~#3~#4 ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{#2~#3~#4} ]
  }
}


\NewDocumentCommand \trefiis { O{} m m } {
  \str_set:Nn \l_tmpa_str { #1 }
  \str_if_empty:NTF \l_tmpa_str {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefiis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol{#2-#3}![#2~#3s]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #2-#3 }![ \comp{#2~#3s} ]
  } {
    \msg_set:nnn{stex}{warning/deprecated}{
      \\
      \c_backslash_str trefiis~is~deprecated! \\
      Please~use~\c_backslash_str STEXsymbol { #1 }[ #2~#3s ]~instead!~(in~file~
      \stex_path_to_string:N \g_stex_currentfile_seq)
      \\ \\
    }
    \msg_warning:nn{stex}{warning/deprecated}
    \STEXsymbol { #1 }![ \comp{#2~#3s} ]
  }
}

\NewDocumentCommand \symvariant { O{} m O{0} m m} {
  \msg_set:nnn{stex}{warning/deprecated}{
    \\
    \c_backslash_str symvariant~is~deprecated! \\
    Please~use~\c_backslash_str notation[#4]{ #2 }~instead!~(in~file~
    \stex_path_to_string:N \g_stex_currentfile_seq)
    \\ \\
  }
  \msg_warning:nn{stex}{warning/deprecated}

  \notation[variant=#4]{#2}{#5}
}

\NewDocumentCommand \mixfixi { O{} m m m} {
  \msg_set:nnn{stex}{warning/deprecated}{
    \c_backslash_str mixfixi~is~fatally~deprecated!\\
    Symbol:~\l__stex_term_highlight_uri_str\\
    Current~file:~\stex_path_to_string:N \g_stex_currentfile_seq
  }
  \msg_error:nn{stex}{warning/deprecated}
}


\NewDocumentCommand \infix {} {
  \msg_set:nnn{stex}{warning/deprecated}{
    \c_backslash_str infix~is~fatally~deprecated!\\
    Symbol:~\l__stex_term_highlight_uri_str\\
    Current~file:~\stex_path_to_string:N \g_stex_currentfile_seq
  }
  \msg_error:nn{stex}{warning/deprecated}
}

\let\iprec\infprec

\NewDocumentCommand \inlineex { m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \c_backslash_str inlineex~is~deprecated!\\
    No~replacement~exists~yet.\\
    Current~file:~\stex_path_to_string:N \g_stex_currentfile_seq
  }
  \msg_warning:nn{stex}{warning/deprecated}
  #1
}


\NewDocumentCommand \term { m } {
  \msg_set:nnn{stex}{warning/deprecated}{
    \c_backslash_str term~is~deprecated!\\
    No~replacement~exists~yet.\\
    Current~file:~\stex_path_to_string:N \g_stex_currentfile_seq
  }
  \msg_warning:nn{stex}{warning/deprecated}
  #1
}


\NewDocumentCommand \Definame { O{} m } {
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \scalatex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { 
      \l_tmpa_str
     }
  } {
    \@defemph {
      \exp_after:wN \stex_capitalize:n \l_tmpa_str
    } { \l_stex_get_symbol_uri_str }
  }
}

\NewDocumentCommand \Definiendum { O{} m m } {
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \scalatex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { 
      \l_tmpa_str
     }
  } {
    \@defemph {
      \exp_after:wN \stex_capitalize:n \l_tmpa_str
    } { \l_stex_get_symbol_uri_str }
  }
}

\NewDocumentCommand \Symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }![
    \exp_after:wN \stex_capitalize:n \l_tmpa_str
      \l_stex_symname_post_str
  ] }
}


\seq_gput_right:Nx \g_stex_smsmode_allowedenvs_seq { \tl_to_str:n { mhmodnl } }
\seq_gput_right:Nx \g_stex_smsmode_allowedenvs_seq { \tl_to_str:n { modsig } }
\tl_gput_right:Nn \g_stex_smsmode_allowedmacros_escape_tl {\gimport\symi\symii\symiii\symiv\symvariant}

% omtext:
\cs_new_protected:Npn \lec #1 {
  \strut\hfil\strut\null\hfill(#1)
}
\cs_new_protected:Npn \nlex #1 {
  \textcolor{green}{{\sl #1}}  
}


%</compat>
%    \end{macrocode}
%
% \end{implementation}
% \immediate\closeout\alltestsoutfile
% \endinput
