%^^A An Infrastructure for Semantic Macros and Module Scoping
%^^A Copyright (c) 2019 Michael Kohlhase, all rights reserved
%^^A               this file is released under the
%^^A               LaTeX Project Public License (LPPL)
%^^A
%^^A The original of this file is in the public repository at 
%^^A http://github.com/sLaTeX/sTeX/
%
%^^A TODO update copyright
%  
% \iffalse
%
%<*driver>
\documentclass[full,kernel]{l3doc}
\usepackage[dvipsnames]{xcolor}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[showmods,debug,lang={de,en}, mathhub=./tests]{stex}
\usepackage{url,array,float,textcomp}
\usepackage[show]{ed}
\usepackage[hyperref=auto,style=alphabetic]{biblatex}
\addbibresource{kwarcpubs.bib}
\addbibresource{extpubs.bib}
\addbibresource{kwarccrossrefs.bib}
\addbibresource{extcrossrefs.bib}
\usepackage{amssymb}
\usepackage{amsfonts}
\usepackage{ctangit}
\usepackage{xspace}
\usepackage{hyperref}

\usepackage{morewrites}

\makeindex
\floatstyle{boxed}
\newfloat{exfig}{thp}{lop}
\floatname{exfig}{Example}
\def\githubissue#1{\cite{sTeX:github:on}, \hyperlink{https://github.com/sLaTeX/sTeX/issues/#1}{issue #1}}

\ExplSyntaxOn
\prg_new_conditional:Nnn \stex_indtx: { T } {
  \prg_return_true:
}
\ExplSyntaxOff

\input{stextests.sty}

\begin{document}
\RecordChanges
\DocInput{stex.dtx}
\end{document}
%</driver>
% \fi
% 
% \iffalse\CheckSum{802}\fi
% 
% \GetFileInfo{stex.sty}
% 
% \MakeShortVerb{\|}
%\def\scsys#1{{{\sc #1}}\index{#1@{\sc #1}}\xspace}
% \def\mmt{\textsc{Mmt}\xspace}
% \def\xml{\scsys{Xml}}
% \def\mathml{\scsys{MathML}}
% \def\omdoc{\scsys{OMDoc}}
% \def\openmath{\scsys{OpenMath}}
% \def\latexml{\scsys{LaTeXML}}
% \def\perl{\scsys{Perl}}
% \def\cmathml{Content-{\sc MathML}\index{Content {\sc MathML}}\index{MathML@{\sc MathML}!content}}
% \def\activemath{\scsys{ActiveMath}}
% \def\twin#1#2{\index{#1!#2}\index{#2!#1}}
% \def\twintoo#1#2{{#1 #2}\twin{#1}{#2}}
% \def\atwin#1#2#3{\index{#1!#2!#3}\index{#3!#2 (#1)}}
% \def\atwintoo#1#2#3{{#1 #2 #3}\atwin{#1}{#2}{#3}}
% \def\cT{\mathcal{T}}\def\cD{\mathcal{D}}
% \title{{\texttt{stex.sty}}: {\stex2.0}\thanks{Version {\fileversion} (last revised
% {\filedate})}}
% \author{Michael Kohlhase, Dennis M\"uller\\
%    FAU Erlangen-N\"urnberg\\
%    \url{http://kwarc.info/}}
% \maketitle
%
%
% \begin{abstract}
%    TODO
% \end{abstract}
%
% \section{Introduction}\label{sec:intro}
%     TODO
%
%   \newpage\setcounter{tocdepth}{2}\tableofcontents\newpage
%
%   \section{Manual}
%
% \subsection{Notations and Precedences}
%
% Every notation has an (upwards) \emph{operator precedence} and
% for each argument a (downwards) \emph{argument precedence}
% used for automated bracketing. For example, a notation
% for a binary operator \cs{foo} could be declared like this:
% \begin{center} |\notation[prec=200;500x600]{foo}{#1 + #2}| \end{center}
% assigning an operator precedence of 200, an argument precedence
% of 500 for the first argument, and an argument precedence of 600
% for the second argument.
%
% \sTeX insert brackets thusly: Upon encountering a semantic
% macro (such as \cs{foo}), its operator precedence (e.g. 200)
% is compared to the current downwards precedence (initially 
% \cs{neginfprec}). If the operator precedence is \emph{smaller}
% than the current downwards precedence, parentheses are inserted
% around the semantic macro.
%
% Notations for symbols of arity 0 have a default precedence of \cs{infprec},
% i.e. by default, parentheses are never inserted around constants.
% Notations for symbols with arity $>0$ have a default operator
% precedence of $0$.
% If no argument precedences are explicitly provided, then by
% default they are equal to the operator precedence.
%
% Consequently, if some operator $A$ should bind stronger than
% some operator $B$, then $A$s operator precedence should be
% larger than $B$s argument precedences.
%
% For example, we could set
% \begin{center} |\notation[prec=50]{plus}{#1 + #2}| \end{center}
% and
% \begin{center} |\notation[prec=100]{times}{#1 \cdot #2}| \end{center}
% then |$\plus{a}{\times{b}{c}}$| would yield $a+b\cdot c$, and
% |$\times{a}{\plus{b}{c}}$| would yield $a\cdot(b+c)$.
%
%
% \subsection{Archives and Imports}
%
% \subsubsection{Namespaces}
%   Ideally, \sTeX would use arbitrary URIs for modules, with no
%   forced relationships between the \emph{logical} namespace
%   of a module and the \emph{physical} location of the file
%   declaring the module -- like \mmt does things.
%
%   Unfortunately, \TeX\ only provides very restricted access to
%   the file system, so we are forced to generate namespaces
%   systematically in such a way that they reflect the physical
%   location of the associated files, so that \sTeX can resolve
%   them accordingly. Largely, users need not concern themselves
%   with namespaces at all, but for completenesses sake, we describe
%   how they are constructed:
%
%   \begin{itemize}
%     \item If \cs{begin}|{module}{Foo}| occurs in a file
%       |/path/to/file/Foo[.|\meta{lang}|].tex| which does not belong
%       to an archive, the namespace is |file://path/to/file|.
%     \item If the same statement occurs in a file
%       |/path/to/file/bar[.|\meta{lang}|].tex|, the namespace is 
%       |file://path/to/file/bar|.
%   \end{itemize}
%
%   In other words: outside of archives, the namespace corresponds to
%   the file URI with the filename dropped iff it is equal to the
%   module name, and ignoring the (optional) language suffix^^A
%   \footnote{which is internally attached to the module name instead,
%   but a user need not worry about that.}.
%
%   If the current file is in an archive, the procedure is the same
%   except that the initial segment of the file path up to the archive's
%   |source|-folder is replaced by the archive's namespace URI.
%
% \subsubsection{Paths in Import-Statements}
%
% Conversely, here is how namespaces/URIs and file paths are computed
% in import statements, examplary \cs{importmodule}:
%
% \begin{itemize}
%   \item \cs{importmodule}|{Foo}| outside of an archive refers 
%     to module |Foo| in the current namespace. Consequently, |Foo|
%     must have been declared earlier in the same document or, if not,
%     in a file |Foo[.|\meta{lang}|].tex| in the same directory.
%   \item The same statement \emph{within} an archive refers to either
%     the module |Foo| declared earlier in the same document, or
%     otherwise to the module |Foo| in the archive's top-level namespace.
%     In the latter case, is has to be declared in a file |Foo[.|\meta{lang}|].tex|
%     directly in the archive's |source|-folder.
%   \item Similarly, in \cs{importmodule}|{some/path?Foo}| the path
%     |some/path| refers to either the sub-directory and relative 
%     namespace path of the current directory and namespace outside of an archive,
%     or relative to the current archive's top-level namespace and |source|-folder,
%     respectively.
%
%     The module |Foo| must either be declared in the file
%     \meta{top-directory}|/some/path/Foo[.|\meta{lang}|].tex|, or in
%     \meta{top-directory}|/some/path[.|\meta{lang}|].tex| (which are
%     checked in that order).
%   \item Similarly, \cs{importmodule}|[Some/Archive]{some/path?Foo}|
%     is resolved like the previous cases, but relative to the archive
%     |Some/Archive| in the mathhub-directory.
%   \item Finally, \cs{importmodule}|{full://uri?Foo}| naturally refers to the
%     module |Foo| in the namespace |full://uri|. Since the file this module
%     is declared in can not be determined directly from the URI, the module
%     must be in memory already, e.g. by being referenced earlier in the
%     same document.
%
%     Since this is less compatible with a modular development, using full
%     URIs directly is discouraged.
%
% \end{itemize} 
%   
%
% \begin{documentation}
%
%   \section{Documentation}
%
%   \subsection{Utils}
%
% \begin{function}{\sTeX , \stex}
%   both print this \stex logo.
% \end{function}
%
% \begin{function}{\stex_debug:n}
%   \begin{syntax}
%     \cs{stex_debug:n} \Arg{message} ^^A \meta{comma list}
%   \end{syntax}
% Logs \meta{message}, if the package option |debug| is used.
% \end{function}
%
% \begin{function}{\stex_kpsewhich:n}
% |\stex_kpsewhich:n| executes kpsewhich and stores the return
% in\\ |\l_stex_kpsewhich_return_str|. This does not require
% shell escaping.
% \end{function}
%
% \begin{function}{\stex_addtosms:n}
% Adds the provided code to the |.sms|-file of the document.
% \end{function}
%
%   \subsubsection{\scalatex, \latexml and HTML Annotations}
%
% \begin{function}{\if@latexml,\latexml_if_p:,\latexml_if:T,\latexml_if:F,\latexml_if:TF}
%   \LaTeX2e and \LaTeX3 conditionals for \latexml.
% \end{function}
%
% We have four macros for annotating generated HTML (via \latexml
% or \scalatex) with attributes:
%
% \begin{function}{\stex_annotate:nnn, \stex_annotate_invisible:nnn,
%   \stex_annotate_invisible:n}
%   \begin{syntax} \cs{stex_annotate:nnn} \Arg{property} \Arg{resource} \Arg{content} \end{syntax}
% Annotates the HTML generated by \meta{content} with\\
% \begin{center}
%  |property="stex:|\meta{property}|", resource="|\meta{resource}|"|.
% \end{center}
%
% \cs{stex_annotate_invisible:n} adds the attributes\\
% \begin{center}
% |stex:visible="false", style="display:none"|.
% \end{center}
%
% \cs{stex_annotate_invisible:nnn} combines the functionality of both.
% \end{function}
%
% \begin{environment}{stex_annotate_env}
%   \begin{syntax} \cs{begin}|{stex_annotate_env}|\Arg{property}\Arg{resource}
%       \meta{content}
%     \cs{end}|{stex_annotate_env}|
%\end{syntax}
% behaves like \cs{stex_annotate:nnn} \Arg{property} \Arg{resource}
%     \Arg{content}.
% \end{environment}
%
%  \subsubsection{Languages}
%
% \begin{variable}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
%   Map language abbreviations to their full babel names and vice versa.
%   e.g. \cs{c_stex_languages_prop}|{en}| yields |english|, and
%   \cs{c_stex_language_abbrevs_prop}|{english}| yields |en|.
% \end{variable}
%
%   \subsection{Files, Paths, URIs}
%
% \begin{function}{\stex_path_from_string:Nn, 
%    \stex_path_from_string:NV,
%    \stex_path_from_string:cn,
%    \stex_path_from_string:cV
%    }
%
%   \begin{syntax} \cs{stex_path_from_string:Nn} \meta{path-variable} \Arg{string} \end{syntax}
%   turns the \meta{string} into a path by splitting it at |/|-characters
%   and stores the result in \meta{path-variable}. Also applies
%   \cs{stex_path_canonicalize:N}.
% \end{function}
%
% \begin{function}{\stex_path_to_string:NN, \stex_path_to_string:N}
%   The inverse; turns a path into a string and stores it in the second
% argument variable, or leaves it in the input stream.
% \end{function}
%
% \begin{function}{\stex_path_canonicalize:N}
%   Canonicalizes the path provided; in particular, resolves |.| and |..|
%   path segments.
% \end{function}
%
% \begin{function}[pTF]{\stex_path_if_absolute:N}
%   Checks whether the path provided is \emph{absolute}, i.e. starts
%   with an empty segment
% \end{function}
%
% \begin{variable}{\c_stex_pwd_seq, \c_stex_pwd_str, \c_stex_mainfile_seq}
%   Store the current working directory as path-sequence and string,
%   respectively, and the (heuristically guessed) full path to the
%   main file, based on the PWD and |\jobname|.
% \end{variable}
%
% \begin{variable}{\g_stex_currentfile_seq}
%   The file being currently processed (respecting |\input| etc.)
% \end{variable}
%
%  \subsection{MathHub Archives}
%
% \begin{variable}{\mathhub, \c_stex_mathhub_seq, \c_stex_mathhub_str}
% We determine the path to the local MathHub folder via one of
% three means, in order of precedence:
% \begin{enumerate}
%   \item The |mathhub| package option, or
%   \item the |\mathhub|-macro, if it has been defined before
%     the |\usepackage{stex}|-statement, or
%   \item the |MATHHUB| system variable.
% \end{enumerate}
% In all three cases, \cs{c_stex_mathhub_seq} and
% \cs{c_stex_mathhub_str} are set accordingly.
% \end{variable}
%
% \begin{variable}{\l_stex_current_repository_prop}
%   Always points to the \emph{current} MathHub repository (if
%   we currently are in one). Has the fields |id|, |ns| (namespace),
%   |narr| (narrative namespace; currently not in use) and
%   |deps| (dependencies; currently not in use).
% \end{variable}
%
% \begin{function}{\stex_set_current_repository:n}
%   Sets the current repository to the one with the provided ID.
%   calls \cs{__stex_mathhub_do_manifest:n}, so works whether this
%   repository's |MANIFEST.MF|-file has already been read or not.
% \end{function}
%
% \begin{function}{\stex_require_repository:n}
%   Calls \cs{__stex_mathhub_do_manifest:n} iff the corresponding
%   archive property list does not already exist, and
%   adds a corresponding definition to the |.sms|-file.
% \end{function}
%
% \subsection{The Module System}
%
% \begin{variable}{\l_stex_current_module_prop}
% All information of a module is stored as a property list. 
% \cs{l_stex_current_module_prop}
% always points to the current module (if existent).
%
% Most importantly, the |content|-field stores all the code
% to execute on activation; i.e. when this module is being included.
%
% Additionally, it stores:
% \begin{itemize}
%   \item The \emph{name} in field |name|,
%   \item the \emph{namespace} in field |ns|,
%   \item this module's \emph{language} in field |lang|,
%   \item if a language module that translates some other
%     modules, the \emph{original} module in field |sig| (for signature),
%   \item the \emph{metatheory} in field |meta|,
%   \item the URIs of all \emph{imported modules} in field |imports|,
%   \item the names of all \emph{declarations} in field |constants|,
%   \item the \emph{file} this module was declared in in field |file|,
% \end{itemize}
% \end{variable}
%
% \begin{function}[pTF]{\stex_if_in_module:}
%   Conditional for whether we are currently in a module
% \end{function}
%
% \begin{function}[pTF]{\stex_if_module_exists:n}
%   Conditional for whether a module with the provided URI
%   is already known.
% \end{function}
%
% \begin{function}{\stex_add_to_current_module:n}
%   Adds the provided tokens to the |content| field of the current
%   module.
% \end{function}
%
% \begin{function}{\stex_add_constant_to_current_module:n}
%   Adds the declaration with the provided name to the |constants|
%   field of the current module.
% \end{function}
%
% \begin{function}{\stex_add_import_to_current_module:n}
%   Adds the module with the provided full URI to the |imports|
%   field of the current module.
% \end{function}
%
% \begin{function}{\stex_modules_compute_namespace:nN}
%   \begin{syntax} \cs{stex_modules_compute_namespace:nN} 
%     \Arg{namespace} \Arg{path}
%   \end{syntax}
%   Computes the namespace for file \meta{path} in repository
%   with namespace \meta{namespace} as follows:
%
%   If the file is |.../source/sub/file.tex|
%   and the namespace |http://some.namespace/foo|, then the namespace of
%   is |http://some.namespace/foo/sub/file|.
% \end{function}
%
% \begin{function}{\stex_modules_current_namespace:}
%   Computes the current namespace
% \end{function}
%
% \subsubsection{The \texttt{module}-environment}
%
% \begin{environment}{module}
%   \begin{syntax} \cs{begin}|{module}[|\meta{options}|]|\Arg{name}\end{syntax}
% 
%   Opens a new module with name \meta{name}.
%
%   TODO document options.
% \end{environment}
%
% \begin{function}{\stex_modules_heading:}
%   Takes care of the module header, if the |showmods| package option
%   is true. This macro can be overridden for customization.
% \end{function}
%
% \begin{environment}{@module}
%   \begin{syntax} \cs{begin}|{@module}[|\meta{options}|]|\Arg{name}\end{syntax}
%
%   Core functionality of the |module|-environment without a header.
%
% \end{environment}
%
%
%    \subsubsection{SMS Mode}
% ``SMS Mode'' is used when loading modules from external tex files.
% It deactivates any output and ignores all \TeX\ commands
% not explicitly allowed via the following lists:
%
% \begin{variable}{\g_stex_smsmode_allowedmacros_tl}
%   Macros that are executed as is; i.e. with the category code scheme
%   used in SMS mode.
% \end{variable}
%
% \begin{variable}{\g_stex_smsmode_allowedmacros_escape_tl}
%   Macros that are executed with the category codes restored.
%
%   Importantly, these macros need to call \cs{stex_smsmode_set_codes:}
%   after reading all arguments. Note, that 
%   \cs{stex_smsmode_set_codes:} takes
%   care of checking whether we are in SMS mode in the first place, 
%   so calling this function eagerly is unproblematic.
% \end{variable}
%
% \begin{variable}{\g_stex_smsmode_allowedenvs_seq}
%   The names of environments that should be allowed in SMS mode.
%   The corresponding \cs{begin}-statements are treated like
%   the macros in \cs{g_stex_smsmode_allowedmacros_escape_tl}, so
%   \cs{stex_smsmode_set_codes:} should be called at the end of the
%   \cs{begin}-code. Since \cs{end}-statements take no arguments anyway,
%   those are called with the SMS mode category code scheme active.
% \end{variable}
%
% \begin{function}[pTF]{\stex_if_smsmode:}
%   Tests whether SMS mode is currently active.
% \end{function}
%
% \begin{function}{\stex_smsmode_set_codes:}
%   Sets the current category code scheme to that of the SMS mode, if
%   SMS mode is currently active and if necessary.
%
%   This method should be called at the end of every macro or 
%   \cs{begin} environment code that are allowed in SMS mode.
%
% \end{function}
%
% \begin{function}{\stex_in_smsmode:nn}
%   \begin{syntax} \cs{stex_in_smsmode:nn} \Arg{name} \Arg{code} \end{syntax}
%   Executes \meta{code} in SMS mode. \meta{name} can be arbitrary,
%   but should be distinct, since it allows for nesting 
%   \cs{stex_in_smsmode:nn} without spuriously terminating SMS mode.
% \end{function}
%
%    \subsubsection{Imports and Inheritance}
%
% \begin{function}{\importmodule}
%   \begin{syntax} \cs{importmodule}|[|\meta{archive-ID}|]|\Arg{module-path} \end{syntax}
%   Imports a module by reading it from a file and ``activating'' it.
%   \sTeX determines the module and its containing file by passing its
%   arguments on to \cs{stex_import_module_path:nn}.
%   
% \end{function}
%
% \begin{function}{\usemodule}
%   \begin{syntax} \cs{importmodule}|[|\meta{archive-ID}|]|\Arg{module-path} \end{syntax}
%   Like \cs{importmodule}, but does not export its contents;
%   i.e. including the current module will not activate the used module
%   
% \end{function}
%
% \begin{function}{\stex_import_module_uri:nn}
%   \begin{syntax} \cs{stex_import_module_uri:nn} \Arg{archive-ID} \Arg{module-path} \end{syntax}
%   Determines the URI of a module by splitting
%   \meta{module-path} into \meta{path}|?|\meta{name}. If \meta{module-path}
%   does \emph{not} contain a |?|-character, we consider it to be the \meta{name},
%   and \meta{path} to be empty.
%
%   If \meta{archive-ID} is empty, it is automatically set to the
%   ID of the current archive (if one exists).
%
%   \begin{enumerate}
%   \item If \meta{archive-ID} is empty:
%     \begin{enumerate}
  %     \item If \meta{path} is empty, then
  %         \meta{name} must have been declared earlier in the same file
  %         and retrievable from \cs{g_stex_modules_in_file_seq}, or
  %         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
  %         in the same folder, containing a module \meta{name}.
  %
  %         That module should have the same namespace as the current one.
  %     \item If \meta{path} is not empty, it must point to the relative
  %         path of the containing file as well as the namespace.
%     \end{enumerate}
%   \item Otherwise:
%      \begin{enumerate}
%         \item If \meta{path} is empty, then
  %         \meta{name} must have been declared earlier in the same file
  %         and retrievable from \cs{g_stex_modules_in_file_seq}, or
  %         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
  %         in the top |source| folder of the archive, 
  %         containing a module \meta{name}.
  %
  %         That module should lie directly in the namespace 
  %         of the archive.
  %     \item If \meta{path} is not empty, it must point to the
  %         path of the containing file as well as the namespace,
  %         relative to the namespace of the archive.
  %
  %         If a module by that namespace exists, it is returned.
  %         Otherwise, we call \cs{stex_require_module:nn} 
  %         on the |source| directory of the archive to find the
  %         file.
%       \end{enumerate}
%   \end{enumerate}
% \end{function}
%
% \begin{function}{\stex_import_require_module:nnnn}
%    \begin{syntax} \Arg{ns} \Arg{archive-ID} \Arg{path} \Arg{name} \end{syntax}
%     Checks whether a module with URI \meta{ns}|?|\meta{name} already
%     exists. If not, it looks for a plausible file that declares
%     a module with that URI.
%
%     Finally, activates that module by executing its |content|-field.
% \end{function}
%
% \begin{variable}{\g_stex_module_files_prop,\g_stex_modules_in_file_seq}
%   A property list mapping file paths to the lists of all modules
%   declared therein. \cs{g_stex_modules_in_file_seq} always points to
%   the current file(-stream - \cs{input}s are considered the same file).
% \end{variable}
%
% \subsection{Symbols and Terms}
%
% \begin{function}{\symdecl}
%   \begin{syntax} \cs{symdecl}|[|\meta{args}|]|\Arg{macroname} \end{syntax}
%   Declares a new symbol with semantic macro \cs{macroname}. Optional
%   arguments are:
%   \begin{itemize}
%     \item |name|: An (\omdoc) name. By default equal to \meta{macroname}.
%     \item |type|: An (ideally semantic) term. Not used by \sTeX, but
%         passed on to \mmt for semantic services.
%     \item |local|: A boolean (by default false). If set, this declaration
%         will not be added to the module content, i.e. importing
%         the current module will not make this declaration available.
%     \item |args|: Specifies the ``signature'' of the semantic macro.
%       Can be either an integer $0 \leq n \leq 9$, or a (more precise)
%       sequence of the following characters:
%         \begin{itemize}
%           \item[|i|] a ``normal'' argument, e.g.
%             |\symdecl[args=ii]{plus}| allows for |\plus{2}{2}|.
%           \item[|a|] an \emph{associative} argument; i.e. a sequence of
%             arbitrarily many arguments provided as a comma-separated list,
%             e.g.
%             |\symdecl[args=a]{plus}| allows for |\plus{2,2,2}|.
%           \item[|b|] a \emph{variable} argument. Is treated by \sTeX
%             like an |i|-argument, but an application is turned into
%             an |OMBind| in \omdoc, binding the provided variable
%             in the subsequent arguments of the operator; e.g.
%             |\symdecl[args=bi]{forall}| allows for |\forall{x\in\Nat}{x\geq0}|.
%         \end{itemize}
%   \end{itemize}
% \end{function}
%
% \begin{function}{\stex_symdecl_do:n}
%   Implements the core functionality of \cs{symdecl}, and is
%   called by \cs{symdecl}, \cs{symdef} and \cs{abbrdef}.
%
%   Ultimately stores the symbol \meta{URI} in the property
%   list |\g_stex_symdecl_|\meta{URI}|_prop| with fields:
%   \begin{itemize}
%     \item |name| (string),
%     \item |module| (string),
%     \item |notations| (sequence of strings; initially empty),
%     \item |local| (boolean),
%     \item |type| (token list),
%     \item |args| (string of |i|s, |a|s and |b|s),
%     \item |arity| (integer string),
%     \item |assocs| (integer string; number of associative arguments),
%   \end{itemize}
% \end{function}
%
% \begin{function}{\stex_get_symbol:n}
%   Computes the full URI of a symbol from a macro argument, e.g.
%   the macro name, the macro itself, the full URI...
% \end{function}
%
% \begin{function}{\stex_invoke_symbol:n}
%   TODO
% \end{function}
%
% \begin{function}{\notation}
%   \begin{syntax} \cs{notation}|[|\meta{args}|]|\Arg{symbol}\Arg{notations$^+$} \end{syntax}
%
% \end{function}
%
% \begin{function}{\stex_notation_do:nn}
%   \begin{syntax} \cs{stex_notation_do:nn}\Arg{URI}\Arg{notations$^+$}\end{syntax}
%
%   Implements the core functionality of \cs{notation}, and is
%   called by \cs{notation} and \cs{symdef}.
%
%   Ultimately stores the notation in the property
%   list\\ |\g_stex_notation_|\meta{URI}|#|\meta{variant}|#|^^A
%   \meta{lang}|_prop| with fields:
%   \begin{itemize}
%     \item |symbol| (URI string),
%     \item |language| (string),
%     \item |variant| (string),
%     \item |opprec| (integer string),
%     \item |argprecs| (sequence of integer strings)
%   \end{itemize}
%
% \end{function}
%
% \begin{function}{\stex_term_oms:nnnn,\stex_term_oma:nnnn,\stex_term_omb:nnnn}
%   \begin{syntax} \meta{URI}\meta{fragment}\meta{precedence}\meta{body} \end{syntax}
%
% Annotates \meta{body} as an \omdoc-term (|OMID|, |OMA| or |OMBIND|, respectively) 
% with head symbol \meta{URI}, generated
% by the specific notation \meta{fragment} with (upwards) operator precedence
% \meta{precedence}. Inserts parentheses according to
% the current downwards precedence and operator precedence.
% \end{function}
%
% \begin{function}{\stex_term_arg:nnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th argument of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec}.
% \end{function}
%
% \begin{function}{\stex_term_assoc_arg:nnnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{notation}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th (associative) \emph{sequence} argument
% (as comma-separated list of terms) of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec} and associative
% notation \meta{notation}.
% 
% \end{function}
%
% \begin{variable}{\infprec, \neginfprec}
%   Maximal and minimal notation precedences.
% \end{variable}
%
% \begin{function}{\STEXdobrackets}
%   \begin{syntax} \cs{STEXdobrackets} \Arg{body} \end{syntax}
%   Puts \meta{body} in parentheses; scaled if in display mode
%   unscaled otherwise. Uses the current \sTeX brackets (by default |(| and |)|),
%   which can be changed temporarily using \cs{STEXwithbrackets}.
% \end{function}
%
% \begin{function}{\STEXwithbrackets}
%   \begin{syntax} \cs{STEXwithbrackets} \meta{left} \meta{right} \Arg{body} \end{syntax}
%   Temporarily (i.e. within \meta{body}) sets the brackets used by \sTeX for automated
%   bracketing (by default |(| and |)|) to \meta{left} and \meta{right}.
%
%   Note that \meta{left} and \meta{right} need to be allowed
%   after \cs{left} and \cs{right} in displaymode.
% \end{function}
%
%
%
%
%
% \end{documentation}
%
% \begin{implementation}
%
% \section{Implementation}\label{sec:impl}
%
% \subsection{The \sTeX document class}
%    \begin{macrocode}
%<*cls>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplClass{stex}{2021/08/01}{1.9}{bla}
\LoadClass[border=1px,varwidth]{standalone}
\setlength\textwidth{15cm}
\g@addto@macro{\@parboxrestore}{\setlength\parskip{\baselineskip}}

\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{stex}}
\ProcessOptions

\RequirePackage{stex}
%</cls>
%    \end{macrocode}
%
% \subsection{Preliminaries}
%
%    \begin{macrocode}
%<*package>
\RequirePackage{expl3,l3keys2e}
\ProvidesExplPackage{stex}{2021/08/01}{1.9}{bla}
%    \end{macrocode}
%
% Package options:
%
%    \begin{macrocode}
\keys_define:nn { stex } {
  debug     .bool_set:N   = \c_stex_debug_bool ,
  showmods  .bool_set:N   = \c_stex_showmods_bool ,
  lang      .clist_set:N  = \c_stex_languages_clist ,
  mathhub   .tl_set_x:N   = \mathhub ,
  sms       .bool_set:N   = \c_stex_persist_mode_bool
}
\ProcessKeysOptions { stex }
%    \end{macrocode}
%
% \begin{macro}{\sTeX}
%   The \sTeX logo:
%
%    \begin{macrocode}
\protected\def\stex{%
  \@ifundefined{texorpdfstring}%
  {\let\texorpdfstring\@firstoftwo}%
  {}%
  \texorpdfstring{\raisebox{-.5ex}S\kern-.5ex\TeX}{sTeX}\xspace%
}
\def\sTeX{\stex}
%    \end{macrocode}
% \end{macro}
%
% Messages
%
%    \begin{macrocode}
\msg_new:nnn{stex}{debug}{}
\msg_new:nnn{stex}{warning/nomathhub}{
  MATHHUB~system~variable~not~found~and~no~
  \detokenize{\mathhub}-value~set!
}
\msg_new:nnn{stex}{error/norepository}{}
\msg_new:nnn{stex}{error/modulemissing}{}
%    \end{macrocode}
% 
% \begin{macro}{\stex_debug:n}
%
%   Debug mode
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_debug:n {
  \bool_if:nT{\c_stex_debug_bool}{
    \exp_args:Nnnx\msg_set:nnn{stex}{debug}{\\Debug:~#1\\}
    \msg_term:nn{stex}{debug} % should be \msg_note:nn
  }
}

\stex_debug:n{Debug~mode~on}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{variable}{\c__stex_sms_iow}
%
%   File variable used for the sms-File
%
%    \begin{macrocode}
\iow_new:N \c__stex_sms_iow
\AddToHook{begindocument}{
  \bool_if:NTF \c_stex_persist_mode_bool {
    \ExplSyntaxOn \input{\jobname.sms} \ExplSyntaxOff
  } {
    \iow_open:Nn \c__stex_sms_iow {\jobname.sms}
  }
}
\AddToHook{enddocument}{
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_close:N \c__stex_sms_iow
  }
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_addtosms:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_addtosms:n {
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_now:Nn \c__stex_sms_iow { #1 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{\latexml and \ScaLaTeX}
%
%    \begin{macrocode}
\RequirePackage{scalatex}
%    \end{macrocode}
%
% We add the namespace abbreviation |ns:stex="http://kwarc.info/ns/sTeX"| to \scalatex:
%
%    \begin{macrocode}
\scalatex_add_Namespace:nn{stex}{http://kwarc.info/ns/sTeX}
%    \end{macrocode}
%
% \begin{macro}{\if@latexml}
% \begin{macro}[EXP,pTF]{\latexml_if:}
%
% Conditionals for \latexml:
%
%    \begin{macrocode}
\ifcsname if@latexml\endcsname\else
    \expandafter\newif\csname if@latexml\endcsname\@latexmlfalse
\fi

\prg_new_conditional:Nnn \latexml_if: {p, T, F, TF} {
  \if@latexml
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
% \subsubsection{HTML Annotations}
%    \begin{macrocode}
%<@@=stex_annotate>
%    \end{macrocode}
%
% \begin{variable}{\l_@@_arg_tl, \c_@@_emptyarg_tl}
%
% Used by annotation macros to ensure that the HTML output to annotate
% is not empty.
%
%    \begin{macrocode}
\tl_new:N \l_@@_arg_tl
\tl_const:Nx \c_@@_emptyarg_tl {
  \scalatex_if:TF {
    \scalatex_direct_HTML:n { \c_ampersand_str lrm; }
  }{~}
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_checkempty:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkempty:n {
  \tl_set:Nn \l_@@_arg_tl { #1 }
  \tl_if_empty:NT \l_@@_arg_tl {
    \tl_set_eq:NN \l_@@_arg_tl \c_@@_emptyarg_tl
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{stex_annotate_env}
% \begin{macro}{\stex_annotate:nnn, \stex_annotate_invisible:n,
%    \stex_annotate_invisible:nnn}
%
% We define four macros for introducing attributes in the HTML
% output. The definitions depend on the ``backend'' used
% (\latexml, \scalatex, \texttt{pdflatex}). 
%
% The \texttt{pdflatex}-macros largely do nothing; the
% \scalatex-implementations are pretty clear in what they do,
%  the \latexml-implementations resort to perl bindings.
%
%    \begin{macrocode}
\scalatex_if:TF{
  \cs_new_protected:Nn \stex_annotate:nnn {
    \_@@_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:n {
    \_@@_checkempty:n { #1 }
    \scalatex_annotate_HTML:nn {
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:nnn {
    \_@@_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2" ~
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l_@@_arg_tl
    }
  }
  \NewDocumentEnvironment{stex_annotate_env} { m m } {
    \par
    \scalatex_annotate_HTML_begin:n {
      property="stex:#1" ~
      resource="#2"
    }
  }{
    \scalatex_annotate_HTML_end:
  }
}{
  \latexml_if:TF {
    \cs_new_protected:Nn \stex_annotate:nnn {
      \_@@_checkempty:n { #3 }
      \mode_if_math:TF {
        \cs:w latexml@annotate@math\cs_end:{#1}{#2}{
          \tl_use:N \l_@@_arg_tl
        }
      }{
        \cs:w latexml@annotate@text\cs_end:{#1}{#2}{
          \tl_use:N \l_@@_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:n {
      \_@@_checkempty:n { #1 }
      \mode_if_math:TF {
        \cs:w latexml@invisible@math\cs_end:{
          \tl_use:N \l_@@_arg_tl
        }
      } {
        \cs:w latexml@invisible@text\cs_end:{
          \tl_use:N \l_@@_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {
      \_@@_checkempty:n { #3 }
      \cs:w latexml@annotate@invisible\cs_end:{#1}{#2}{
        \tl_use:N \l_@@_arg_tl
      }
    }
    \NewDocumentEnvironment{stex_annotate_env} { m m } {
      \par\begin{latexml@annotateenv}{#1}{#2}
    }{
      \end{latexml@annotateenv}
    }
  }{
    \cs_new_protected:Nn \stex_annotate:nnn {#3}
    \cs_new_protected:Nn \stex_annotate_invisible:n {}
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {}
    \NewDocumentEnvironment{stex_annotate_env} { m m } {\par}{}
  }
}
%    \end{macrocode}
% \end{macro}
% \end{environment}
%
% \subsubsection{Languages}
%    \begin{macrocode}
%<@@=stex_language>
%    \end{macrocode}
%
% \begin{variable}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
%
% We store language abbreviations in two (mutually inverse) 
% property lists:
%    \begin{macrocode}
\prop_const_from_keyval:Nn \c_stex_languages_prop {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}

\prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}
% todo: chinese simplified (zhs)
%       chinese traditional (zht)
%    \end{macrocode}
% \end{variable}
%
% we use the |lang|-package option to load the corresponding
% babel languages:
%
%    \begin{macrocode}
\clist_if_empty:NF \c_stex_languages_clist {
  \clist_clear:N \l_tmpa_clist
  \clist_map_inline:Nn \c_stex_languages_clist {
    \prop_get:NnNTF \c_stex_languages_prop { #1 } \l_tmpa_str {
      \clist_put_right:No \l_tmpa_clist \l_tmpa_str
    } {
      \msg_set:nnn{stex}{error/unknownlanguage}{
        Unknown~language~\l_tmpa_str
      }
      \msg_error:nn{stex}{error/unknownlanguage}
    }
  }
  \stex_debug:n {Languages:~\clist_use:Nn \l_tmpa_clist {,~} }
  \RequirePackage[\clist_use:Nn \l_tmpa_clist ,]{babel}
}
%    \end{macrocode}
%
% \subsection{Files, Paths and URIs}
%    \begin{macrocode}
%<@@=stex_path>
%    \end{macrocode}
%
% \subsubsection{Generic Path Handling}
%
% We treat paths as \LaTeX3-sequences (of the individual
% path segments, i.e. separated by a /-character) unix-style;
% i.e. a path is absolute if the sequence starts with an empty 
% entry.
%
% \begin{macro}{\stex_path_from_string:Nn, 
%    \stex_path_from_string:NV,
%    \stex_path_from_string:cn,
%    \stex_path_from_string:cV
%    }
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_from_string:Nn {
  \str_set:Nx \l_tmpa_str { #2 }
  \str_if_empty:NTF \l_tmpa_str {
    \seq_clear:N #1
  }{
    \exp_args:NNNo \seq_set_split:Nnn #1 / { \l_tmpa_str }    
    \sys_if_platform_windows:T{
      \seq_clear:N \l_tmpa_tl
      \seq_map_inline:Nn #1 {
        \seq_set_split:Nnn \l_tmpb_tl \c_backslash_str { ##1 }
        \seq_concat:NNN \l_tmpa_tl \l_tmpa_tl \l_tmpb_tl
      }
      \seq_set_eq:NN #1 \l_tmpa_tl
    }
    \stex_path_canonicalize:N #1
  }
}
\cs_generate_variant:Nn \stex_path_from_string:Nn 
  { NV, cn, cV }
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_path_to_string:NN,\stex_path_to_string:N}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_to_string:NN {
  \exp_args:NNe \str_set:Nn #2 { \seq_use:Nn #1 / }
}

\cs_new:Nn \stex_path_to_string:N {
  \seq_use:Nn #1 /
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\c_@@_dot_str,\c_@@_up_str}
%
% |.| and |..|, respectively.
%
%    \begin{macrocode}
\str_const:Nn \c_@@_dot_str {.}
\str_const:Nn \c_@@_up_str {..}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_path_canonicalize:N}
%
%  Canonicalizes the path provided; in particular, resolves |.| and |..|
%  path segments.
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_clear:N \l_tmpa_seq
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NT \l_tmpa_tl {
      \seq_put_right:Nn \l_tmpa_seq {}
    }
    \seq_map_inline:Nn #1 {
      \str_set:Nn \l_tmpa_tl { ##1 }
      \str_if_eq:NNTF \l_tmpa_tl \c_@@_dot_str {} {
        \str_if_eq:NNTF \l_tmpa_tl \c_@@_up_str {
          \seq_if_empty:NTF \l_tmpa_seq {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
              \c_@@_up_str
            }
          }{
            \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
            \str_if_eq:NNTF \l_tmpa_tl \c_@@_up_str {
              \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
                \c_@@_up_str
              }
            }{
              \seq_pop_right:NN \l_tmpa_seq \l_tmpb_tl
            }
          }
        }{
          \str_if_empty:NF \l_tmpa_tl {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq { \l_tmpa_tl }
          }
        }
      }
    }
    \seq_gset_eq:NN #1 \l_tmpa_seq
  }
}
%    \end{macrocode}
% \end{macro}
%
% \stextest{
% \ExplSyntaxOn
% \def\cpath@print#1{
%    \stex_path_from_string:Nn\l_tmpb_seq{#1}
%    \stex_path_to_string:NN\l_tmpb_seq\l_tmpa_str
%    \str_use:N\l_tmpa_str
%  }
% \ExplSyntaxOff
% \begin{center}
% \begin{tabular}{|l|l|l|}\hline
%   path & canonicalized path & expected\\\hline
%   aaa & \cpath@print{aaa} & aaa \\
%   ../../aaa & \cpath@print{../../aaa} &  ../../aaa\\
%   aaa/bbb & \cpath@print{aaa/bbb} & aaa/bbb \\
%   aaa/.. & \cpath@print{aaa/..} &\\
%   ../../aaa/bbb & \cpath@print{../../aaa/bbb} & ../../aaa/bbb\\
%   ../aaa/../bbb & \cpath@print{../aaa/../bbb} & ../bbb \\
%   ../aaa/bbb & \cpath@print{../aaa/bbb} &  ../aaa/bbb\\
%   aaa/bbb/../ddd & \cpath@print{aaa/bbb/../ddd} & aaa/ddd\\
%   aaa/bbb/./ddd & \cpath@print{aaa/bbb/./ddd} & aaa/bbb/ddd\\
%   ./ & \cpath@print{./} & \\
%   aaa/bbb/../.. & \cpath@print{aaa/bbb/../..} & \\\hline
% \end{tabular}
% \end{center}
% }
%
% \begin{macro}[EXP,pTF]{\stex_path_if_absolute:N}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_path_if_absolute:N {p, T, F, TF} {
  \seq_if_empty:NTF #1 {
    \prg_return_false:
  }{
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NTF \l_tmpa_tl {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \subsubsection{PWD and kpsewhich}
%
% \begin{macro}{\stex_kpsewhich:n}
%    \begin{macrocode}
\str_new:N\l_stex_kpsewhich_return_str
\cs_new_protected:Nn \stex_kpsewhich:n {
  \sys_get_shell:nnN { kpsewhich ~ #1 } { } \l_tmpa_tl
  \exp_args:NNo\str_set:Nn\l_stex_kpsewhich_return_str{\l_tmpa_tl}
  \tl_trim_spaces:N \l_stex_kpsewhich_return_str
}
%    \end{macrocode}
% \end{macro}
%
% We determine the PWD
%
% \begin{variable}{\c_stex_pwd_seq,\c_stex_pwd_str}
%    \begin{macrocode}
\sys_if_platform_windows:TF{
  \stex_kpsewhich:n{-expand-var~\c_percent_str CD\c_percent_str}
}{
  \stex_kpsewhich:n{-var-value~PWD}
}

\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:n {PWD:~\str_use:N\c_stex_pwd_str}
%    \end{macrocode}
% \end{variable}
%
% \subsubsection{File Hooks and Tracking}
%    \begin{macrocode}
%<@@=stex_files>
%    \end{macrocode}
%
% We introduce hooks for file inputs that keep track of the
% absolute paths of files used. This will be useful to keep track
% of modules, their archives, namespaces etc.
%
% Note that the absolute paths are only accurate in |\input|-statements
% for paths relative to the PWD, so they shouldn't be relied upon
% in any other setting than for \sTeX-purposes.
%
% \begin{variable}{\g_@@_stack}
%
% keeps track of file changes
%
%    \begin{macrocode}
\seq_gclear_new:N\g_@@_stack
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\c_stex_mainfile_seq}
%    \begin{macrocode}
\stex_path_from_string:Nn \c_stex_mainfile_seq {
  \c_stex_pwd_str/\g_file_curr_name_str.tex
}
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\g_stex_currentfile_seq}
%
% Hooks for file inputs that push/pop \cs{g_@@_stack} to update
% \cs{c_stex_mainfile_seq}.
%
%    \begin{macrocode}
\seq_gclear_new:N\g_stex_currentfile_seq
\AddToHook{file/before}{
  \stex_path_from_string:Nn\g_stex_currentfile_seq{\CurrentFilePath}
  \stex_path_if_absolute:NTF\g_stex_currentfile_seq{
    \exp_args:NNe\seq_put_right:Nn\g_stex_currentfile_seq{\CurrentFile}
  }{
    \stex_path_from_string:Nn\g_stex_currentfile_seq{
      \c_stex_pwd_str/\CurrentFilePath/\CurrentFile
    }
  }
  \seq_gset_eq:NN\g_stex_currentfile_seq\g_stex_currentfile_seq
  \exp_args:NNo\seq_gpush:Nn\g_@@_stack\g_stex_currentfile_seq
}
\AddToHook{file/after}{
  \seq_if_empty:NF\g_@@_stack{
    \seq_gpop:NN\g_@@_stack\l_tmpa_seq
  }
  \seq_if_empty:NTF\g_@@_stack{
    \seq_gset_eq:NN\g_stex_currentfile_seq\c_stex_mainfile_seq
  }{
    \seq_get:NN\g_@@_stack\l_tmpa_seq
    \seq_gset_eq:NN\g_stex_currentfile_seq\l_tmpa_seq
  }
}
%    \end{macrocode}
% \end{variable}
%
% \subsection{MathHub Repositories}
%    \begin{macrocode}
%<@@=stex_mathhub>
%    \end{macrocode}
%
% \begin{variable}{\mathhub, \c_stex_mathhub_seq, \c_stex_mathhub_str}
%    \begin{macrocode}
\str_if_empty:NTF\mathhub{
  \stex_kpsewhich:n{-var-value~MATHHUB}
  \str_set_eq:NN\c_stex_mathhub_str\l_stex_kpsewhich_return_str
  
  \str_if_empty:NTF\c_stex_mathhub_str{
    \msg_warning:nn{stex}{warning/nomathhub}
  }{
    \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
    \stex_path_from_string:Nn\c_stex_mathhub_seq\c_stex_mathhub_str
  }
}{
  \stex_path_from_string:Nn\c_stex_mathhub_seq\mathhub
  \stex_path_to_string:NN\c_stex_mathhub_seq\c_stex_mathhub_str
  \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
}
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\_@@_do_manifest:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_do_manifest:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_if_exist:cF {c_stex_mathhub_#1_manifest_prop} {
    \prop_new:c { c_stex_mathhub_#1_manifest_prop }
    \seq_set_split:NnV \l_tmpa_seq / \l_tmpa_str
    \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpa_seq
    \_@@_find_manifest:N \l_tmpa_seq
    \seq_if_empty:NTF \l_@@_manifest_file_seq {
      \msg_set:nnn{stex}{error/norepository}{
        No~archive~#1~found~in~
          \stex_path_to_string:N \c_stex_mathhub_str
      }
      \msg_error:nn{stex}{error/norepository}
    } {
      \exp_args:No \_@@_parse_manifest:n { \l_tmpa_str }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_@@_manifest_file_seq}
%    \begin{macrocode}
\str_new:N\l_@@_manifest_file_seq
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_find_manifest:N}
%
% Attempts to find the |MANIFEST.MF| in some file path and
% stores its path in \cs{l_@@_manifest_file_seq}:
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_find_manifest:N {
  \seq_set_eq:NN\l_tmpa_seq #1
  \bool_set_true:N\l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_if_empty:NTF \l_tmpa_seq {
      \bool_set_false:N\l_tmpa_bool
    }{
      \file_if_exist:nTF{
        \stex_path_to_string:N\l_tmpa_seq/MANIFEST.MF
      }{
        \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
        \bool_set_false:N\l_tmpa_bool
      }{
        \file_if_exist:nTF{
          \stex_path_to_string:N\l_tmpa_seq/META-INF/MANIFEST.MF
        }{
          \seq_put_right:Nn\l_tmpa_seq{META-INF}
          \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
          \bool_set_false:N\l_tmpa_bool
        }{
          \file_if_exist:nTF{
            \stex_path_to_string:N\l_tmpa_seq/meta-inf/MANIFEST.MF
          }{
            \seq_put_right:Nn\l_tmpa_seq{meta-inf}
            \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
            \bool_set_false:N\l_tmpa_bool
          }{
            \seq_pop_right:NN\l_tmpa_seq\l_tmpa_tl
          }
        }
      }
    }
  }
  \seq_set_eq:NN\l_@@_manifest_file_seq\l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\c_@@_manifest_ior}
%
%   File variable used for |MANIFEST|-files
%
%    \begin{macrocode}
\ior_new:N \c_@@_manifest_ior
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_parse_manifest:n}
%
% Stores the entries in manifest file in the
% corresponding property list:
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_parse_manifest:n {
  \seq_set_eq:NN \l_tmpa_seq \l_@@_manifest_file_seq
  \ior_open:Nn \c_@@_manifest_ior {\stex_path_to_string:N \l_tmpa_seq}
  \ior_map_inline:Nn \c_@@_manifest_ior {
    \str_set:Nn \l_tmpa_str {##1}
    \exp_args:NNoo \seq_set_split:Nnn 
        \l_tmpb_seq \c_colon_str \l_tmpa_str
    \seq_pop_left:NNTF \l_tmpb_seq \l_tmpa_tl {
      \exp_args:NNe \str_set:Nn \l_tmpb_tl { 
        \exp_args:NNo \seq_use:Nn \l_tmpb_seq \c_colon_str 
      }
      \exp_args:No \str_case:nnTF \l_tmpa_tl {
        {id} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { id } \l_tmpb_tl
        }
        {narration-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { narr } \l_tmpb_tl
        }
        {source-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { ns } \l_tmpb_tl
        }
        {ns} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { ns } \l_tmpb_tl
        }
        {dependencies} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop } 
            { deps } \l_tmpb_tl
        }
      }{}{}
    }{}
  }
  \ior_close:N \c_@@_manifest_ior
}
%    \end{macrocode}
% \end{macro}
% 
%
% \begin{macro}{\stex_set_current_repository:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \prop_set_eq:Nc \l_stex_current_repository_prop { 
    c_stex_mathhub_#1_manifest_prop 
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_require_repository:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \stex_debug:n{Opening~archive:~#1}
    \_@@_do_manifest:n { #1 }
    \exp_args:Nx \stex_addtosms:n {
      \prop_const_from_keyval:cn { c_stex_mathhub_#1_manifest_prop } {
        id   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  id  } ,
        ns   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  ns  } ,
        narr = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { narr } ,
        deps = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { deps }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \stextest{
%  \ExplSyntaxOn
%  \stex_require_repository:n { Foo/Bar }
%  id:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {id}\ \\
%  narr:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {narr}\ \\
%  ns:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {ns}\ \\
%  deps:~\prop_item:cn {c_stex_mathhub_Foo/Bar_manifest_prop} {deps}\ \\
% \stex_require_repository:n { Bar/Foo }
%  \ExplSyntaxOff
% }
%
%\begin{variable}{\l_stex_current_repository_prop}
%
% Current MathHub repository and a
% hook for |\begin{document}| to set it initially.
%
%    \begin{macrocode}
\prop_new:N \l_stex_current_repository_prop
\AddToHook{begindocument}{
  \_@@_find_manifest:N \c_stex_pwd_seq
  \seq_if_empty:NTF \l_@@_manifest_file_seq {
    \stex_debug:n{Not~currently~in~a~MathHub~repository}
  } {
    \_@@_parse_manifest:n { main }
    \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id} 
      \l_tmpa_str
    \prop_set_eq:cN { c_stex_mathhub_\l_tmpa_str _manifest_prop }
    \stex_set_current_repository:n { main }
    \stex_debug:n{Current~repository:~
      \prop_item:Nn \l_stex_current_repository_map {id}
    }
  }
}
%    \end{macrocode}
% \end{variable}
%
% \subsection{Module System}
%    \begin{macrocode}
%<@@=stex_module>
%    \end{macrocode}
%
% \begin{variable}{\l_stex_current_module_prop}
%    \begin{macrocode}
\prop_new:N \l_stex_current_module_prop
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[pTF]{stex_if_in_module:}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \prop_if_empty:NTF \l_stex_current_module_prop
    \prg_return_false: \prg_return_true:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{stex_if_module_exists:n}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_to_current_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \prop_get:NnN \l_stex_current_module_prop { content } \l_tmpa_tl
  \tl_put_right:Nn \l_tmpa_tl { #1 }
  \prop_put:Nno \l_stex_current_module_prop { content } \l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_constant_to_current_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_constant_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { constants } \l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_import_to_current_module:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_import_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { imports } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { imports } \l_tmpa_seq
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_modules_compute_namespace:nN}
%
% stores its return values in:
% \begin{variable}{\l_stex_modules_ns_str}
%    \begin{macrocode}
\str_new:N \l_stex_modules_ns_str
%    \end{macrocode}
% \end{variable}
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_compute_namespace:nN {
  \str_set:Nx \l_tmpa_str { #1 }
  \seq_set_eq:NN \l_tmpa_seq #2
  % split off file extension
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \bool_set_true:N \l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:No \str_case:nnTF { \l_tmpb_str } {
      {source} { \bool_set_false:N \l_tmpa_bool }
    }{}{
      \seq_if_empty:NT \l_tmpa_seq {
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }

  \seq_if_empty:NTF \l_tmpa_seq {
    \str_set_eq:NN \l_stex_modules_ns_str \l_tmpa_str
  }{
    \str_set:Nx \l_stex_modules_ns_str { 
      \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_modules_current_namespace:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_modules_current_namespace: {
  \prop_get:NnNTF \l_stex_current_repository_prop { ns } \l_tmpa_str {
    \stex_modules_compute_namespace:nN \l_tmpa_str \g_stex_currentfile_seq
  }{
    % split off file extension
    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
    \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \str_set:Nx \l_stex_modules_ns_str { 
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%\stextest{
% \ExplSyntaxOn
% \stex_modules_current_namespace:
% Namespace~1:\\\l_stex_modules_ns_str\\
% Faking~a~repository:\\
% \stex_set_current_repository:n{Foo/Bar}
% \seq_pop_right:NN \g_stex_currentfile_seq \testtemp
% \edef\testtempb{\detokenize{source}}
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtempb }
% \edef\testtempb{\detokenize{test}}
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtempb }
% \exp_args:NNo \seq_put_right:Nn \g_stex_currentfile_seq { \testtemp }
% \stex_modules_current_namespace:
% Namespace~2:\\\l_stex_modules_ns_str
% \ExplSyntaxOff
%}
%
% \subsubsection{The module environment}
%
% \begin{environment}{module}
%
% |module| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / module } {
  title .tl_set_x:N  = \l_stex_module_title_str ,
  ns    .tl_set_x:N  = \l_stex_module_ns_str ,
  lang  .tl_set_x:N  = \l_stex_module_lang_str ,
  sig   .tl_set_x:N  = \l_stex_module_sig_str ,
  meta  .tl_set_x:N  = \l_stex_module_meta_str
}

% module parameters here? In the body?

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_stex_module_title_str
  \str_clear:N \l_stex_module_ns_str
  \str_clear:N \l_stex_module_lang_str
  \str_clear:N \l_stex_module_sig_str
  \str_clear:N \l_stex_module_meta_str
  \keys_set:nn { stex / module } { #1 }
  \exp_args:NNo \str_set:Nn \l_stex_module_title_str 
    \l_stex_module_title_str
  \exp_args:NNo \str_set:Nn \l_stex_module_ns_str 
    \l_stex_module_ns_str
  \exp_args:NNo \str_set:Nn \l_stex_module_lang_str 
    \l_stex_module_lang_str
  \exp_args:NNo \str_set:Nn \l_stex_module_sig_str 
    \l_stex_module_sig_str
  \exp_args:NNo \str_set:Nn \l_stex_module_meta_str 
    \l_stex_module_meta_str
}
%    \end{macrocode}
%
% \begin{macro}{\_@@_begin_module:}
%
%   implements |\begin{module}|
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_begin_module: {
  % Nested module?
  \stex_if_in_module:TF {
    % Nested module
    \prop_get:NnN \l_stex_current_module_prop
      { ns } \l_stex_module_ns_str
    \str_set:Nx \l_stex_module_name_str {
      \prop_item:Nn \l_stex_current_module_prop
        { name } / \l_stex_module_name_str
    }
  }{
    % not nested:
    \str_if_empty:NT \l_stex_module_ns_str {
      \stex_modules_current_namespace:
      \str_set_eq:NN \l_stex_module_ns_str \l_stex_modules_ns_str
      \exp_args:NNNo \seq_set_split:Nnn \l_tmpa_seq
         / {\l_stex_module_ns_str}
      \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
      \str_if_eq:NNT \l_tmpa_str \l_stex_module_name_str {
        \str_set:Nx \l_stex_module_ns_str {
          \stex_path_to_string:N \l_tmpa_seq
        }
      }
    }
  }

  % language
  \str_if_empty:NF \l_stex_module_lang_str {
    \prop_get:NVNTF \c_stex_languages_prop \l_stex_module_lang_str 
      \l_tmpa_str {
        \exp_args:Nx \selectlanguage { \l_tmpa_str }
      } {
        \msg_set:nnn{stex}{error/unknownlanguage}{
          Unknown~language~\l_tmpa_str
        }
        \msg_error:nn{stex}{error/unknownlanguage}
      }
  }

  % signature
  \str_if_empty:NF \l_stex_module_sig_str {
    \str_if_empty:NT \l_stex_module_lang_str {
      \msg_set:nnn{stex}{error/siglanguage}{
        Module~\l_stex_module_ns_str?\l_stex_module_name_str~
        declares~signature~\l_stex_module_sig_str,~but~does~not~
        declare~its~language
      }
      \msg_error:nn{stex}{error/siglanguage}
    }
  }

  % metatheory
%  \str_if_empty:NTF \l_stex_module_meta_str {
%
%  } {
%
%  }

  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
    name      = \l_stex_module_name_str ,
    ns        = \l_stex_module_ns_str ,
    imports    = \exp_not:o { \l_tmpa_seq } ,
    constants = \exp_not:o { \l_tmpa_seq } ,
    content   = \exp_not:o { \l_tmpa_tl }  ,
    file      = \exp_not:o { \g_stex_currentfile_seq } ,
    lang      = \l_stex_module_lang_str ,
    sig       = \l_stex_module_sig_str ,
    meta      = \l_stex_module_meta_str
  }

  \stex_debug:n{
    New~module:\\
    Namespace:~\l_stex_module_ns_str\\
    Name:~\l_stex_module_name_str\\
    Language:~\l_stex_module_lang_str\\
    Signature:~\l_stex_module_sig_str\\
    Metatheory:~\l_stex_module_meta_str\\
    File:~\stex_path_to_string:N \g_stex_currentfile_seq
  }

  \seq_gput_right:Nx  \g_stex_modules_in_file_seq
      { \l_stex_module_ns_str ? \l_stex_module_name_str }
  
  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env} {theory} {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }

    \stex_annotate_invisible:nnn{header}{} {
      \stex_annotate:nnn{language}{ \l_stex_module_lang_str }{}
      \stex_annotate:nnn{signature}{ \l_stex_module_sig_str }{}
      \str_if_empty:NT \l_stex_module_meta_str {
        % TODO metatheory
      }
    }
  }
}
\iffalse \end{stex_annotate_env} \fi % make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_end_module:}
%
%   implements |\end{module}|
%
%    \begin{macrocode}
\iffalse \begin{stex_annotate_env} \fi %^^A make syntax highlighting work again
\cs_new_protected:Nn \_@@_end_module: {
  \str_set:Nx \l_tmpa_str {
    c_stex_module_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  \prop_new:c { \l_tmpa_str }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        c_stex_module_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        imports    = \prop_item:cn { \l_tmpa_str } { imports } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta }
      }
    }
  }{
    \end{stex_annotate_env}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{@module}
%
%  The core environment, with no header
%    
%    \begin{macrocode}
\NewDocumentEnvironment { @module } { O{} m } {
  \str_set:Nx \l_stex_module_name_str { #2 }
  \par
  \_@@_args:n { #1 }
  \_@@_begin_module:
} { 
  \_@@_end_module:
}
%    \end{macrocode}
% \end{environment}
%
%\stextest{
% \ExplSyntaxOn
% \stex_set_current_repository:n {Foo/Bar}
% \seq_pop_right:NN \g_stex_currentfile_seq \l_tmpa_tl
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{tests} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Bar} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{source} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo.tex} }
% \begin{@module}{Foo}
%  Module~path:~ 
%  \prop_item:Nn \l_stex_current_module_prop { ns }?
%  \prop_item:Nn \l_stex_current_module_prop { name }\\
%  Language:~\prop_item:Nn \l_stex_current_module_prop { lang }\\
%  Signature:~\prop_item:Nn \l_stex_current_module_prop { sig }\\
%  Metatheory:~\prop_item:Nn \l_stex_current_module_prop { meta }\\
% \end{@module}
% \ExplSyntaxOff
%}
%
%
% \begin{macro}{\stex_modules_heading:}
%
%   Code for document headers
%
%    \begin{macrocode}
\cs_if_exist:NTF \thesection {
  \newcounter{module}[section]
}{
  \newcounter{module}
}

\bool_if:NT \c_stex_showmods_bool {
  \latexml_if:F { \RequirePackage{mdframed} }
}

\cs_new_protected:Nn \stex_modules_heading: {
  \stepcounter{module}
  \par
  \bool_if:NT \c_stex_showmods_bool {
    \noindent{\textbf{Module} ~
      \cs_if_exist:NT \thesection {\thesection.}
      \themodule ~ [\l_stex_module_name_str]
    }
    % TODO references
    % \sref@label@id{Module \thesection.\themodule [\module@name]}%
    \str_if_empty:NTF \l_stex_module_title_str {
    }{
      \quad(\l_stex_module_title_str)\hfill
    }\par
  }
}
%    \end{macrocode}
% \end{macro}
%
% Finally:
%    \begin{macrocode}
\NewDocumentEnvironment { module } { O{} m } {
  \bool_if:NT \c_stex_showmods_bool {
    \begin{mdframed}
  }
  \begin{@module}[#1]{#2}
  \stex_modules_heading:
}{
  \end{@module}
  \bool_if:NT \c_stex_showmods_bool {
    \end{mdframed}
  }
}
%    \end{macrocode}
%
% \end{environment}
%
%
%\stextest{
% \ExplSyntaxOn
% \stex_set_current_repository:n {Foo/Bar}
% \stex_debug:n{Test:~\stex_path_to_string:N \g_stex_currentfile_seq }
% \seq_pop_right:NN \g_stex_currentfile_seq \l_tmpa_tl
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{tests} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Bar} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{source} }
% \seq_put_right:Nx \g_stex_currentfile_seq { \tl_to_str:n{Foo.tex} }
% \stex_debug:n{Test:~\stex_path_to_string:N \g_stex_currentfile_seq }
% \begin{module}[title=Foo Bar]{Bar}
%  Module~path:~ 
%  \prop_item:Nn \l_stex_current_module_prop { ns }?
%  \prop_item:Nn \l_stex_current_module_prop { name }\\
%  Language:~\prop_item:Nn \l_stex_current_module_prop { lang }\\
%  Signature:~\prop_item:Nn \l_stex_current_module_prop { sig }\\
%  Metatheory:~\prop_item:Nn \l_stex_current_module_prop { meta }\\
% \end{module}
% \ExplSyntaxOff
%}
%
% \subsubsection{SMS Mode}
%    \begin{macrocode}
%<@@=stex_smsmode>
%    \end{macrocode}
%
% \begin{variable}{
%   \g_stex_smsmode_allowedmacros_tl,
%   \g_stex_smsmode_allowedmacros_escape_tl,
%   \g_stex_smsmode_allowedenvs_seq
% }
%    \begin{macrocode}
\tl_new:N \g_stex_smsmode_allowedmacros_tl
\tl_new:N \g_stex_smsmode_allowedmacros_escape_tl
\seq_new:N \g_stex_smsmode_allowedenvs_seq

\tl_set:Nn \g_stex_smsmode_allowedmacros_tl {
  \makeatletter
  \makeatother
  \ExplSyntaxOn
  \ExplSyntaxOff
}

\tl_set:Nn \g_stex_smsmode_allowedmacros_escape_tl {
  \symdef
%  \abbrdef
%  \module@export
  \importmodule
%  \mmt@symdecl
%  \instantiates
%  \setnotation
%  \importmhmodule
%  \gimport
%  \symvariant
%  \structural@feature
%  \symi
%  \symii
%  \symiii
%  \symiv
  \notation
  \symdecl
%  \defi
%  \defii
%  \defiii
%  \defiv
%  \adefi
%  \adefii
%  \adefiii
%  \adefiv
%  \defis
%  \defiis
%  \defiiis
%  \defivs
%  \Defi
%  \Defii
%  \Defiii
%  \Defiv
%  \Defis
%  \Defiis
%  \Defiiis
%  \Defivs
}

\exp_args:NNx \seq_set_from_clist:Nn \g_stex_smsmode_allowedenvs_seq {
  \tl_to_str:n {
    module,
    @module
%   modsig,
%   mhmodsig,
%   mhmodnl,
%   modnl,
%   @structural@feature
  }
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}[pTF]{\stex_if_smsmode:}
%    \begin{macrocode}
\bool_new:N \g_@@_bool
\bool_set_false:N \g_@@_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g_@@_bool \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}[pTF]{\_@@_if_catcodes:}
% Checks whether the SMS mode category code scheme is active.
%    \begin{macrocode}
\bool_new:N \g_@@_catcode_bool
\bool_set_false:N \g_@@_catcode_bool
\prg_new_conditional:Nnn \_@@_if_catcodes: { p, T, F, TF } {
  \bool_if:NTF \g_@@_catcode_bool 
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_smsmode_set_codes:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_smsmode_set_codes: {
  \stex_if_smsmode:T {
    \_@@_if_catcodes:F {
      \bool_gset_true:N \g_@@_catcode_bool
      \exp_after:wN \char_gset_active_eq:NN 
        \c_backslash_str \_@@_cs:
      \tex_global:D \char_set_catcode_active:N \\
      \tex_global:D \char_set_catcode_other:N $
      \tex_global:D \char_set_catcode_other:N ^
      \tex_global:D \char_set_catcode_other:N _
      \tex_global:D \char_set_catcode_other:N &
      \tex_global:D \char_set_catcode_other:N ##
    }
  }
} \iffalse $ \fi % to make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_unset_codes:}
%   Sets category code scheme back from the one used in SMS mode.
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_unset_codes: {
  \_@@_if_catcodes:T {
    \bool_gset_false:N \g_@@_catcode_bool
    \exp_after:wN \tex_global:D \exp_after:wN 
      \char_set_catcode_escape:N \c_backslash_str
    \tex_global:D \char_set_catcode_math_toggle:N $
    \tex_global:D \char_set_catcode_math_superscript:N ^
    \tex_global:D \char_set_catcode_math_subscript:N _
    \tex_global:D \char_set_catcode_alignment:N &
    \tex_global:D \char_set_catcode_parameter:N ##
  }
} \iffalse $ \fi % to make syntax highlighting work again
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_in_smsmode:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_in_smsmode:nn {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_eq:cN { l_@@_#1_bool } \g_@@_bool
    \bool_gset_true:N \g_@@_bool
    \stex_smsmode_set_codes:
    #2
    \bool_gset_eq:Nc \g_@@_bool { l_@@_#1_bool }
    \stex_if_smsmode:F {
      \_@@_unset_codes:
    }
  }
  \box_clear:N \l_tmpa_box
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_cs:}
% is executed on encountering |\| in smsmode.
% It checks whether the corresponding command is allowed and executes
% or ignores it accordingly:
%    \begin{macrocode}
\str_const:Nn \c_@@_begin_str { begin }
\str_const:Nn \c_@@_end_str { end }

\cs_new_protected:Nn \_@@_cs: {
  \str_clear:N \l_tmpa_str
  \peek_analysis_map_inline:n {
    % #1: token (one expansion)
    % #2: charcode
    % #3 catcode
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpa_str { ##1 }
    } {
      \str_if_empty:NTF \l_tmpa_str {
        % we don't allow (or need) single non-letter CSs
        % for now
        \peek_analysis_map_break: 
      }{
        \str_if_eq:nnTF \l_tmpa_str \c_stex_begin_str {
          \peek_analysis_map_break:n { 
            \exp_after:wN \_@@_checkbegin:n ##1
          }
        } {
          \str_if_eq:nnTF \l_tmpa_str \c_stex_end_str {
            \peek_analysis_map_break:n { 
              \exp_after:wN \_@@_checkend:n ##1
            }
          } {
          \tl_set:Nn \l_tmpa_tl { \use:c{\l_tmpa_str} }
          \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
            \g_stex_smsmode_allowedmacros_tl 
              { \use:c{\l_tmpa_str} } {
              \peek_analysis_map_break:n { 
                \exp_after:wN \l_tmpa_tl ##1
              }
            } {
              \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF 
              \g_stex_smsmode_allowedmacros_escape_tl 
                { \use:c{\l_tmpa_str} } {
                \exp_args:NNNo \exp_args:No 
                \token_if_eq_charcode_p:NNTF \c_backslash_str ##1 {
                  \peek_analysis_map_break:n {
                    \_@@_unset_codes:
                    \_@@_rescan_cs:
                  }
                } {
                  \peek_analysis_map_break:n {
                    \_@@_unset_codes:
                    \exp_after:wN \l_tmpa_tl ##1
                  }
                }
              } {
                \peek_analysis_map_break:n { ##1 }
              }
            }
          }
        }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_@@_rescan_cs:}
% If the last token gobbled by |\stex_smsmode_cs:| happened to be
% a |\|, we need to rescan the cs name and reinsert it into the input
% stream:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_rescan_cs: {
  \str_clear:N \l_tmpb_str
  \peek_analysis_map_inline:n {
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpb_str { ##1 }
    } {
      \peek_analysis_map_break:n {
        \exp_after:wN \use:c \exp_after:wN { 
          \exp_after:wN \l_tmpa_str\exp_after:wN 
        } \use:c { \l_tmpb_str \exp_after:wN } ##1
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_checkbegin:n}
% called on |\begin|; checks whether the environment being opened
% is allowed in SMS mode. 
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkbegin:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \_@@_unset_codes:
    \begin{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_checkend:n}
% called on |\end|; checks whether the environment being opened
% is allowed in SMS mode. 
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_checkend:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \end{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
%\stextest{
% \immediate\openout\testfile=./tests/sometest.tex
% \immediate\write\testfile{\detokenize{\this is \a test}^^J}
% \immediate\write\testfile{\detokenize{this \is a \test}}
% \immediate\closeout\testfile
% \ExplSyntaxOn
% \stex_in_smsmode:nn { foo } { 
%   \input{tests/sometest.tex} 
% }
% \ExplSyntaxOff
%}
%
% \subsubsection{Inheritance}
%    \begin{macrocode}
%<@@=stex_importmodule>
%    \end{macrocode}
%
% \begin{macro}{\stex_import_module_uri:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_import_module_uri:nn {
  \str_set:Nx \l_@@_archive_str { #1 }
  \str_set:Nx \l_@@_path_str { #2 }
  \str_if_empty:NT \l_@@_archive_str {
    \prop_if_empty:NF \l_stex_current_repository_prop {
      \prop_get:NnN \l_stex_current_repository_prop { id } \l_@@_archive_str
    }
  }

  \exp_args:NNNo \seq_set_split:Nnn \l_tmpb_seq ? { \l_@@_path_str }
  \seq_pop_right:NN \l_tmpb_seq \l_@@_name_str
  \str_set:Nx \l_@@_path_str { \seq_use:Nn \l_tmpa_seq ? }

  \str_if_empty:NTF \l_tmpa_str {
    \stex_modules_current_namespace:
    \str_if_empty:NF \l_@@_path_str {
      \str_set:Nx \l_stex_module_ns_str {
        \l_stex_module_ns_str / \l_@@_path_str
      }
    }
  }{
    \stex_require_repository:n \l_@@_archive_str
    \prop_get:cnN { c_stex_mathhub_\l_@@_archive_str _manifest_prop } { ns }
      \l_stex_module_ns_str
    \str_if_empty:NF \l_@@_path_str {
      \str_set:Nx \l_@@_module_ns_str {
        \l_stex_module_ns_str / \l_@@_path_str ? \l_@@_name_str
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{
%   \l_@@_name_str,\l_@@_archive_str,\l_@@_path_str
% }
%   Store the return values of \cs{stex_import_module_uri:nn}.
%    \begin{macrocode}
\str_new:N \l_@@_name_str
\str_new:N \l_@@_archive_str
\str_new:N \l_@@_path_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_import_require_module:nnnn}
%    \begin{syntax} \Arg{ns} \Arg{archive-ID} \Arg{path} \Arg{name} \end{syntax}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_import_require_module:nnnn {
  \exp_args:Nx \stex_if_module_exists:nF { #1 ? #4 } {
    % archive
    \str_set:Nx \l_tmpa_str { #2 }
    \str_if_empty:NTF \l_tmpa_str {
      \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    } {
      \stex_path_from_string:Nn \l_tmpb_seq { \l_tmpa_str }
      \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpb_seq
      \seq_put_right:Nn \l_tmpa_seq { source }
    }

    \stex_debug:n{Arguments: #1, #2, #3, #4}

    % path
    \str_set:Nx \l_tmpb_str { #3 }
    \str_if_empty:NT \l_tmpb_str {
      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq / #4 }
      
      \cs_if_exist:NTF \languagename { 
        \prop_get:NnN \c_stex_language_abbrevs_prop 
            { \languagename } \l_tmpb_str
      }

      \stex_debug:n{Checking~\l_tmpa_str.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
        \str_set:Nx \l_tmpa_str { \l_tmpa_str.\l_tmpb_str.tex }
      }{
        \stex_debug:n{Checking~\l_tmpa_str.tex}
        \IfFileExists{ \l_tmpa_str.tex }{
          \str_set:Nx \l_tmpa_str { \l_tmpa_str.tex }
        }{
          % try english as default
          \stex_debug:n{Checking~\l_tmpa_str.en.tex}
          \IfFileExists{ \l_tmpa_str.en.tex }{
            \str_set:Nx \l_tmpa_str { \l_tmpa_str.en.tex }
          }{
            \msg_new:nnn{stex}{error/modulemissing}{
              No~file~for~module~#1?#4~found
            }
            \msg_error:nn{stex}{error/modulemissing}
          }
        }
      }

    } { 
      \stex_path_from_string:NV \l_tmpb_seq \l_tmpb_str
      \seq_concat:NNN \l_tmpa_seq \l_tmpa_seq \l_tmpb_seq
      
      \cs_if_exist:NTF \languagename { 
        \prop_get:NnN \c_stex_language_abbrevs_prop 
            { \languagename } \l_tmpb_str
      }

      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq }

      \stex_debug:n{Checking~\l_tmpa_str/#4.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str/#4.\l_tmpb_str.tex }{
        \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.\l_tmpb_str.tex }
      }{
        \stex_debug:n{Checking~\l_tmpa_str/#4.tex}
        \IfFileExists{ \l_tmpa_str/#4.tex }{
          \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.tex }
        }{
          % try english as default
          \stex_debug:n{Checking~\l_tmpa_str/#4.en.tex}
          \IfFileExists{ \l_tmpa_str/#4.en.tex }{
            \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.en.tex }
          }{
            \stex_debug:n{Checking~\l_tmpa_str.\l_tmpb_str.tex}
            \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
              \str_set:Nx \l_tmpa_str { \l_tmpa_str.\l_tmpb_str.tex }
            }{
              \stex_debug:n{Checking~\l_tmpa_str.tex}
              \IfFileExists{ \l_tmpa_str.tex }{
                \str_set:Nx \l_tmpa_str { \l_tmpa_str.tex }
              }{
                % try english as default
                \stex_debug:n{Checking~\l_tmpa_str.en.tex}
                \IfFileExists{ \l_tmpa_str.en.tex }{
                  \str_set:Nx \l_tmpa_str { \l_tmpa_str.en.tex }
                }{
                  \msg_new:nnn{stex}{error/modulemissing}{
                    No~file~for~module~#1?#4~found
                  }
                  \msg_error:nn{stex}{error/modulemissing}
                }
              }
            }
          }
        }
      }
    }

    \seq_set_eq:NN \l_tmpa_seq \g_stex_modules_in_file_seq
    \seq_clear:N \g_stex_modules_in_file_seq
    \exp_args:No \stex_in_smsmode:nn { \l_tmpa_str } {
      \str_set:Nx \l_tmpb_str { #2 }
      \str_if_empty:NF \l_tmpb_str {
        \stex_set_current_repository:n { #2 }
      }
      \input { \l_tmpa_str }
    }
    \prop_gput:Noo \g_stex_module_files_prop
      \l_tmpa_str \g_stex_modules_in_file_seq
    \seq_set_eq:NN \g_stex_modules_in_file_seq \l_tmpa_seq

    \stex_if_module_exists:nF { #1 ? #4 } {
      \msg_new:nnn{stex}{error/modulemissing}{
        Module~#1?#4~not~found~in~file~\l_tmpa_str
      }
      \msg_error:nn{stex}{error/modulemissing}
    }
  }
  % activate
  \stex_debug:n{Activating~module~#1?#4}
  \prop_item:cn { c_stex_module_#1?#4_prop } { content }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\importmodule}
%    \begin{macrocode}
\NewDocumentCommand \importmodule { O{} m } {
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_debug:n{Importing~module:~
    \l_stex_module_ns_str ? \l_@@_name_str
  }
  \stex_if_smsmode:F {
    \stex_import_require_module:nnnn 
    { \l_stex_module_ns_str } { \l_@@_archive_str } 
    { \l_@@_path_str } { \l_@@_name_str }
    \stex_annotate_invisible:nnn 
      {import} {\l_stex_module_ns_str ? \l_@@_name_str} {}
  }
  \exp_args:Nx \stex_add_to_current_module:n {
    \stex_import_require_module:nnnn 
    { \l_stex_module_ns_str } { \l_@@_archive_str } 
    { \l_@@_path_str } { \l_@@_name_str }
  }
  \exp_args:Nx \stex_add_import_to_current_module:n {
    \l_stex_module_ns_str ? \l_@@_name_str
  }
  \stex_smsmode_set_codes:
}
%    \end{macrocode}
% \end{macro}
%
%
%\stextest{
%   \begin{module}{Foo1}
%     \symdecl[name=foo, args=3]{bar}
%     \symdecl[args=bai]{foobar}
%     Meaning:~\meaning\bar\\
%   \end{module}
%   \begin{module}{Foo2}
%     \importmodule{Foo1}
%     Meaning:~\meaning\bar\\
%   \end{module}
%}
%
% \begin{macro}{\usemodule}
%    \begin{macrocode}
\NewDocumentCommand \usemodule { O{} m } {
  \stex_if_smsmode:F {
    \stex_import_module_uri:nn { #1 } { #2 }
    \stex_import_require_module:nnnn 
    { \l_@@_module_ns_str } { \l_@@_archive_str }
    { \l_@@_path_str } { \l_@@_name_str }
    \stex_annotate_invisible:nnn 
      {usemodule} {\l_stex_module_ns_str ? \l_@@_name_str} {}
  }
  \stex_smsmode_set_codes:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\g_stex_modules_in_file_seq,\g_stex_module_files_prop}
%    \begin{macrocode}
\seq_new:N \g_stex_modules_in_file_seq
\prop_new:N \g_stex_module_files_prop
%    \end{macrocode}
% \end{variable}
%
%
% \subsection{Symbol Declarations}
%    \begin{macrocode}
%<@@=stex_symdecl>
%    \end{macrocode}
%
% |symdecl| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / symdecl } {
  name  .tl_set_x:N  = \l_stex_symdecl_name_str ,
  local .bool_set:N  = \l_stex_symdecl_local_bool ,
  args  .tl_set_x:N  = \l_stex_symdecl_args_str ,
  type  .tl_set:N    = \l_stex_symdecl_type_tl
}

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl
  
  \keys_set:nn { stex /symdecl } { #1 }

  \exp_args:NNo \str_set:Nn \l_stex_symdecl_name_str
    \l_stex_symdecl_name_str
  \exp_args:NNo \str_set:Nn \l_stex_symdecl_args_str
    \l_stex_symdecl_args_str
}
%    \end{macrocode}
%
% \begin{macro}{\symdecl}
%
% Parses the optional arguments and passes them on to
% \cs{stex_symdecl_do:} (so that \cs{symdef} and \cs{abbrdef} 
% can do the same)
%
%    \begin{macrocode}
\NewDocumentCommand \symdecl { O{} m } {
  \_@@_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_symdecl_do:n { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_symdecl_do:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_symdecl_do:n {
  \stex_if_in_module:F {
    % TODO throw error? some default namespace?
  }
  
  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }

  \prop_if_exist:cT { g_stex_symdecl_ 
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name} ?
      \l_stex_symdecl_name_str
    _prop
  }{
    % TODO throw error (beware of circular dependencies)
  }

  \prop_clear:N \l_tmpa_prop
  \prop_put:Nnx \l_tmpa_prop { module } {
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name}
  }
  \seq_clear:N \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { notations } \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { name } \l_stex_symdecl_name_str
  \prop_put:Nno \l_tmpa_prop { local } \l_stex_symdecl_local_bool
  \prop_put:Nno \l_tmpa_prop { type } \l_stex_symdecl_type_tl

  \exp_args:No \stex_add_constant_to_current_module:n {
    \l_stex_symdecl_name_str
  }

  % arity/args
  \int_zero:N \l_tmpb_int

  \bool_set_true:N \l_tmpa_bool
  \str_map_inline:Nn \l_stex_symdecl_args_str {
    \token_case_meaning:NnF ##1 {
      0 {} 1 {} 2 {} 3 {} 4 {} 5 {} 6 {} 7 {} 8 {} 9 {}
      {\tl_to_str:n i} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n b} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n a} { 
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
    }{
      \msg_set:nnn{stex}{error/wrongargs}{
        args~value~in~symbol~declaration~for~
        \prop_item:Nn \l_stex_current_module_prop {ns} ?
        \prop_item:Nn \l_stex_current_module_prop {name} ?
        \l_stex_symdecl_name_str ~
        needs~to~be~
        i,~a~or~b,~but~##1~given
      }
      \msg_error:nn{stex}{error/wrongargs}
    }
  }
  \bool_if:NTF \l_tmpa_bool {
    % possibly numeric
    \str_if_empty:NTF \l_stex_symdecl_args_str {
      \prop_put:Nnn \l_tmpa_prop { args } {}
      \prop_put:Nnn \l_tmpa_prop { arity } { 0 }
    }{
      \int_set:Nn \l_tmpa_int { \l_stex_symdecl_args_str }
      \prop_put:Nnx \l_tmpa_prop { arity } { \int_use:N \l_tmpa_int }
      \str_clear:N \l_tmpa_str
      \int_step_inline:nn \l_tmpa_int {
        \str_put_right:Nn \l_tmpa_str i
      }
      \prop_put:Nnx \l_tmpa_prop { args } { \l_tmpa_str }
    }
  } {
    \prop_put:Nnx \l_tmpa_prop { args } { \l_stex_symdecl_args_str }
    \prop_put:Nnx \l_tmpa_prop { arity }
      { \str_count:N \l_stex_symdecl_args_str }
  }
  \prop_put:Nnx \l_tmpa_prop { assocs } { \int_use:N \l_tmpb_int }
  

  % semantic macro

  \tl_set:cx { #1 } { \stex_invoke_symbol:n {
    \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
  } }

  \bool_if:NF \l_stex_symdecl_local_bool {
    \exp_args:Nx \stex_add_to_current_module:n {
      \tl_set:cx { #1 } { \stex_invoke_symbol:n {
        \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
      } }
    }
  }


  \stex_debug:n{New~symbol:~
    \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }^^J
    Type:~\exp_not:o { \l_stex_symdecl_type_tl }^^J
    Args:~\prop_item:Nn \l_tmpa_prop { args }
  }

  \prop_gset_eq:cN {
    g_stex_symdecl_ 
    \prop_item:Nn \l_tmpa_prop { module } ?
    \prop_item:Nn \l_tmpa_prop { name }
    _prop 
  } \l_tmpa_prop

  \stex_if_smsmode:TF {
    \bool_if:NF \l_stex_symdecl_local_bool {
      \exp_args:Nx \stex_addtosms:n {
        \prop_gset_from_keyval:cn {
          g_stex_symdecl_ 
          \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
          _prop 
        } {
          name      = \prop_item:Nn \l_tmpa_prop { name }
          module    = \prop_item:Nn \l_tmpa_prop { module }
          notations = \prop_item:Nn \l_tmpa_prop { notations }
          local     = \prop_item:Nn \l_tmpa_prop { local }
          type      = \prop_item:Nn \l_tmpa_prop { type }
          args      = \prop_item:Nn \l_tmpa_prop { args }
          arity     = \prop_item:Nn \l_tmpa_prop { arity }
          assocs    = \prop_item:Nn \l_tmpa_prop { assocs }
        }
      }
    }
    \stex_smsmode_set_codes:
  }{
    \stex_annotate_invisible:nnn {symdecl} {
      \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
    } {
      \stex_annotate_invisible:nnn{type}{}{$\l_stex_symdecl_type_tl$}
      \stex_annotate_invisible:nnn{args}{}{
        \prop_item:Nn \l_tmpa_prop { args }
      }
      \stex_annotate_invisible:nnn{macroname}{}{#1}
      \str_if_empty:NF \l_stex_symdecl_definiens_tl {
        \stex_annotate_invisible:nnn{definiens}{}
          {$\l_stex_symdecl_definiens_tl$}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_symbol:n}
%
%    \begin{macrocode}
\str_new:N \l_stex_get_symbol_uri_str

\cs_new_protected:Nn \stex_get_symbol:n {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \_@@_get_symbol_from_cs:n { #1 }
  }{
    % argument is a string
    % is it a command name?
    \cs_if_exist:cTF { #1 }{
      \exp_args:No \_@@_get_symbol_from_cs:n { \use:c { #1 } }
    }{
      % TODO
      % argument is not a command name
    }
  }
}

\cs_new_protected:Nn \_@@_get_symbol_from_cs:n {
  \tl_set:Nx \l_tmpa_tl { #1 }
  \exp_args:Nx \cs_if_eq:NNTF { \tl_head:N \l_tmpa_tl } 
    \stex_invoke_symbol:n {
    \exp_args:NNx \tl_set:Nn \l_tmpa_tl 
      { \tl_tail:N \l_tmpa_tl }
    \tl_if_single:NTF \l_tmpa_tl {
      \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
        \exp_after:wN \str_set:Nn \exp_after:wN
          \l_stex_get_symbol_uri_str \l_tmpa_tl
      }{
        % TODO
        % tail is not a single group
      }
    }{
      % TODO
      % tail is not a single group
    }
  }{
    % TODO
    % head is not \stex_invoke_symbol:n
  }
}
%    \end{macrocode}
% \end{macro}
%
%\stextest{
%   \begin{module}{Foo3}
%     \symdecl[name=foo, args=3]{bar}
%     \symdecl[name=foobar, args=iab]{bari}
%     \ExplSyntaxOn
%       Meaning:~\meaning\bar\\
%       \stex_get_symbol:n { bar }
%       Result:~\l_stex_get_symbol_uri_str
%     \ExplSyntaxOff
%   \end{module}
%}
%
%
%
% \subsection{Notations}
%    \begin{macrocode}
%<@@=stex_notation>
%    \end{macrocode}
%
% |notation| arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / notation } {
  lang    .tl_set_x:N = \l_@@_lang_str ,
  variant .tl_set_x:N = \l_@@_variant_str ,
  prec    .tl_set_x:N = \l_@@_prec_str ,
  unknown .code:n     = \str_set:Nx 
      \l_@@_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_@@_lang_str
  \str_clear:N \l_@@_variant_str
  \str_clear:N \l_@@_prec_str
  
  \keys_set:nn { stex / notation } { #1 }

  \exp_args:NNo \str_set:Nn \l_@@_lang_str
    \l_@@_lang_str
  \exp_args:NNo \str_set:Nn \l_@@_variant_str
    \l_@@_variant_str
  \exp_args:NNo \str_set:Nn \l_@@_prec_str
    \l_@@_prec_str
}
%    \end{macrocode}
%
%
%
% \begin{macro}{\notation}
%    \begin{macrocode}
\NewDocumentCommand \notation { O{} m } {
  \_@@_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_get_symbol:n { #2 }
  \stex_notation_do:nn { \l_stex_get_symbol_uri_str }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_notation_do:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_notation_do:nn {
  \prop_set_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop 
  }
  
  \prop_clear:N \l_tmpb_prop
  \prop_put:Nno \l_tmpb_prop { symbol } { #1 }
  \prop_put:Nno \l_tmpb_prop { language } \l_@@_lang_str
  \prop_put:Nno \l_tmpb_prop { variant } \l_@@_variant_str

  % precedences
  \seq_clear:N \l_tmpb_seq
  \exp_args:NNno
  \seq_set_split:Nnn \l_tmpa_seq ; { \l_@@_prec_str }
  \seq_pop_left:NNTF \l_tmpa_seq \l_tmpa_str {
    \prop_put:Nno \l_tmpb_prop { opprec } \l_tmpa_str
    \seq_pop_left:NNT \l_tmpa_seq \l_tmpa_str {
      \exp_args:NNNo \exp_args:NNno \seq_set_split:Nnn 
        \l_tmpa_seq {\tl_to_str:n{x} } { \l_tmpa_str }
      \seq_map_inline:Nn \l_tmpa_seq {
        \seq_put_right:Nn \l_tmpb_seq { ##1 }
      }
    }
    \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
  }{
    \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
    \int_compare:nNnTF \l_tmpa_str = 0 {
      \exp_args:NNnx
      \prop_put:Nnn \l_tmpb_prop { opprec } 
        { \int_use:n { \infprec } }
    }{
      \prop_put:Nnn \l_tmpb_prop { opprec } { 0 }
    }
  }

  \seq_set_eq:NN \l_tmpa_seq \l_tmpb_seq
  \int_step_inline:nn { \l_tmpa_str } {
    \seq_pop_left:NNF \l_tmpa_seq \l_tmpb_str {
      \exp_args:NNx
      \seq_put_right:Nn \l_tmpb_seq { 
        \prop_item:Nn \l_tmpb_prop { opprec }
      }
    }
  }
  
  \prop_put:Nno \l_tmpb_prop { argprecs } \l_tmpb_seq

  \int_compare:nNnTF \l_tmpa_str = 0 {
    \cs_set:Npx \l_@@_macrocode_cs {} {
      \stex_term_oms:nnnn { #1 } 
        { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
        { \prop_item:Nn \l_tmpb_prop { opprec } } 
        { #2 }
    }
    \_@@_final:
  }{
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpb_str
    \str_if_in:NnTF \l_tmpb_str b {
      \cs_generate_from_arg_count:NNnn \l_@@_macrocode_cs
      \cs_set:Npx \l_tmpa_str {
        \stex_term_omb:nnnn { #1 } 
          { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
          { \prop_item:Nn \l_tmpb_prop { opprec } } 
          { #2 }
      }
    }{
      \cs_generate_from_arg_count:NNnn \l_@@_macrocode_cs
      \cs_set:Npx \l_tmpa_str {
        \stex_term_oma:nnnn { #1 } 
          { \l_@@_variant_str \c_hash_str \l_@@_lang_str }
          { \prop_item:Nn \l_tmpb_prop { opprec } } 
          { #2 }
      }
    }

    \int_zero:N \l_tmpa_int
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
    \tl_clear:N \l_tmpa_tl
    \_@@_arguments:
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_arguments:}
%
% Takes care of annotating the arguments in a
% notation macro
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_arguments: {
  \int_incr:N \l_tmpa_int
  \str_if_empty:NTF \l_tmpa_str {
    \_@@_final:
  }{
    \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
    \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
    \str_if_eq:VnTF \l_tmpb_str a {
      \_@@_argument_assoc:n
    }{
      \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
      \tl_put_right:Nx \l_tmpa_tl {
        { \stex_term_arg:nnn
          { \int_use:N \l_tmpa_int }
          { \l_tmpb_str }
          { ####\int_use:N \l_tmpa_int }
        }
      }
      \_@@_arguments:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_argument_assoc:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_argument_assoc:n {
  \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
  \cs_set:Npn \l_tmpa_cs ##1 ##2 { #1 }
  \tl_put_right:Nx \l_tmpa_tl {
    { \stex_term_assoc_arg:nnnn
      { \int_use:N \l_tmpa_int }
      { \l_tmpb_str }
      { \l_tmpa_cs {########1} {########2} }
      { ####\int_use:N \l_tmpa_int }
    }
  }
  \_@@_arguments:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_final:}
%
% Called after processing all notation arguments
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_final: {
  \prop_get:NnN \l_tmpa_prop { arity } \l_tmpb_str
  \prop_get:NnN \l_tmpb_prop { symbol } \l_tmpa_str
  \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
  \cs_generate_from_arg_count:cNnn {
      stex_notation_ \l_tmpa_str \c_hash_str 
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
      _cs
    }
    \cs_set:Npx \l_tmpb_str {
      \exp_after:wN \l_@@_macrocode_cs \l_tmpa_tl
  }

  \stex_debug:n{
    Notation~\l_@@_variant_str \c_hash_str \l_@@_lang_str
    ~for~\prop_item:Nn \l_tmpb_prop { symbol }^^J
    Operator~precedence:~
      \prop_item:Nn \l_tmpb_prop { opprec }^^J
    Argument~precedences:~
      \seq_use:Nn \l_tmpa_seq {,~}^^J
    Notation: \cs_meaning:c {
      stex_notation_ \l_tmpa_str \c_hash_str 
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
      _cs
    }
  }

  \prop_gset_eq:cN {
    g_stex_notation_ \l_tmpa_str \c_hash_str \l_@@_variant_str
      \c_hash_str \l_@@_lang_str _prop
  } \l_tmpb_prop
  
  \exp_args:Nx
  \stex_add_to_current_module:n {
    \prop_get:cnN {
      g_stex_symdecl_ 
        \prop_item:Nn \l_tmpb_prop { symbol }
      _prop 
    } { notations } \exp_not:N \l_tmpa_seq
    \seq_put_right:Nn \exp_not:N \l_tmpa_seq {
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
    }
    \prop_put:cno {
      g_stex_symdecl_ 
        \prop_item:Nn \l_tmpb_prop { symbol }
      _prop
    } { notations } \exp_not:N \l_tmpa_seq
  }

  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        g_stex_notation_ \l_tmpa_str \c_hash_str \l_@@_variant_str
          \c_hash_str \l_@@_lang_str _prop
      } {
        symbol    = \prop_item:Nn \l_tmpb_prop { symbol }
        language  = \prop_item:Nn \l_tmpb_prop { language }
        variant   = \prop_item:Nn \l_tmpb_prop { variant }
        opprec    = \prop_item:Nn \l_tmpb_prop { opprec }
        argprecs  = \prop_item:Nn \l_tmpb_prop { argprecs }
      }
    }
  }{
    \prop_get:NnN \l_tmpa_prop { notations } \l_tmpa_seq
    \seq_put_right:Nx \l_tmpa_seq {
      \l_@@_variant_str \c_hash_str \l_@@_lang_str
    }
    \prop_put:Nno \l_tmpa_prop { notations } \l_tmpa_seq
    \prop_set_eq:cN {
      g_stex_symdecl_ \l_tmpa_str _prop 
    } \l_tmpa_prop

    % TODO HTML annotations
    \stex_annotate_invisible:nnn { notation }
      { \prop_item:Nn \l_tmpb_prop { symbol } } {
        \stex_annotate_invisible:nnn { notationfragment }
          { \l_@@_variant_str \c_hash_str \l_@@_lang_str }{}
        \stex_annotate_invisible:nnn { precedence }
          { \prop_item:Nn \l_tmpb_prop { opprec };
            \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
            \seq_use:Nn \l_tmpa_seq x
          }{}

        \int_zero:N \l_tmpa_int
        \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
        \tl_clear:N \l_tmpa_tl
        \int_step_inline:nn { \prop_item:Nn \l_tmpa_prop { arity } }{
          \int_incr:N \l_tmpa_int
          \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
          \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
          \str_if_eq:VnTF \l_tmpb_str a {
            \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl { 
              \c_hash_str \c_hash_str \int_use:n { \l_tmpa_int }a ,
              \c_hash_str \c_hash_str \int_use:n { \l_tmpa_int }b
            } }
          }{
            \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl { 
              \c_hash_str \c_hash_str \int_use:n { \l_tmpa_int }
            } }
          }
        }
        \stex_annotate_invisible:nnn { notationcomp }{
          \exp_args:Nno \use:c {
            stex_notation_ \prop_item:Nn \l_tmpb_prop { symbol }
            \c_hash_str \l_@@_variant_str
            \c_hash_str \l_@@_lang_str _cs
          } { \l_tmpa_tl }
        }{}
      }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%\stextest{
%   \begin{module}{Foo4}
%     \importmodule{Foo1}
%     \notation[foo, prec=500;20x20x20]{bar}{\langle {#1 ^ {#2}}_{#3} \rangle }
%     \notation[foo, prec=500;20x20x20]{foobar}{\langle #1 \mid [ #2 ]^{#3} \rangle }{ {#1}_{:#2} }
%   \end{module}
%}
%
% \begin{macro}{\stex_invoke_symbol:n}
%
%  Invokes a semantic macro
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_invoke_symbol:n {
  \if_mode_math:
    \exp_after:wN \_@@_invoke_math:n
  \else:
    % TODO
  \fi: { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_math:n {
  \peek_charcode:NTF [ {
    \_@@_invoke_math:nw { #1 }
  }{
    \_@@_invoke_math:nw { #1 } []
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:nw}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_invoke_math:nw  #1 [#2] {
  \_@@_args:n { #2 }
  \prop_set_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop 
  }
  \prop_get:NnN \l_tmpa_prop { notations } \l_tmpa_seq
  \seq_if_empty:NTF \l_tmpa_seq {
    \msg_set:nnn{stex}{error/nonotations}{
      Symbol~#1~used,~but~has~no~notations!
    }
    \msg_error:nn{stex}{error/nonotations}
  } {
    \seq_if_in:NxTF \l_tmpa_seq
      { \l_@@_variant_str \c_hash_str \l_@@_lang_str }{
      \use:c{
        stex_notation_ #1 \c_hash_str
        \l_@@_variant_str \c_hash_str \l_@@_lang_str
        _cs
      }
    }{
      \str_if_empty:NTF \l_@@_variant_str {
        \str_if_empty:NTF \l_@@_lang_str {
          \seq_get_left:NN \l_tmpa_seq \l_tmpa_str
          \use:c{
            stex_notation_ #1 \c_hash_str \l_tmpa_str
            _cs
          }
        }{
          \msg_set:nnn{stex}{error/wrongnotation}{
            Symbol~#1~has~no~notation~
            \l_@@_variant_str \c_hash_str \l_@@_lang_str
          }
          \msg_error:nn{stex}{error/wrongnotation}
        }
      }{
        \msg_set:nnn{stex}{error/wrongnotation}{
          Symbol~#1~has~no~notation~
          \l_@@_variant_str \c_hash_str \l_@@_lang_str
        }
        \msg_error:nn{stex}{error/wrongnotation}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%\stextest{
%  \begin{module}{Foo5}
%    \importmodule{Foo1}
%    \notation[foo, prec=500;20x20x20]{bar}{\langle {#1 ^ {#2}}_{#3} \rangle }
%    $\bar abc$ and $\bar[foo] abc$
%  \end{module}
%}
%
%
%
%
% \subsection{Terms}
%    \begin{macrocode}
%<@@=stex_term>
%    \end{macrocode}
%
% Precedences:
% \begin{variable}{\infprec, \neginfprec, \l_@@_downprec}
%    \begin{macrocode}
\int_const:Nn \infprec {\c_max_int}
\int_const:Nn \neginfprec {-\c_max_int}
\int_new:N \l_@@_downprec
\int_set_eq:NN \l_@@_downprec \neginfprec
%    \end{macrocode}
% \end{variable}
%
% Bracketing:
%
% \begin{variable}{\l_@@_left_bracket_str, \l_@@_right_bracket_str}
%    \begin{macrocode}
\tl_set:Nn \l_@@_left_bracket_str (
\tl_set:Nn \l_@@_right_bracket_str )
\RequirePackage{scalerel}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_maybe_brackets:nn}
%
% Compares precedences and insert brackets accordingly
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_maybe_brackets:nn {
  \int_compare:nNnTF { #1 } < \l_@@_downprec {
    \STEXdobrackets { #2 }
  }{ #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXdobrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXdobrackets #1 {
  \ThisStyle{\if D\m@switch
      \exp_args:Nnx \use:nn
      { \left\l_@@_left_bracket_str #1 } 
      { \right\l_@@_right_bracket_str }
    \else
      \exp_args:Nnx \use:nn
      { \l_@@_left_bracket_str #1 } 
      { \l_@@_right_bracket_str }
  \fi}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXwithbrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXwithbrackets #1 #2 #3 {
  \exp_args:Nnx \use:nn
  {  
    \tl_set:Nx \l_@@_left_bracket_str { #1 }
    \tl_set:Nx \l_@@_right_bracket_str { #2 }
    #3
  }
  {
    \tl_set:Nn \exp_not:N \l_@@_left_bracket_str 
      {\l_@@_left_bracket_str}
    \tl_set:Nn \exp_not:N \l_@@_right_bracket_str 
      {\l_@@_right_bracket_str}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \omdoc terms:
%
% \begin{macro}{\stex_term_oms:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_oms:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \stex_annotate:nnn{OMID}{#1\c_hash_str#2}{#4}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_term_oma:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_oma:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \stex_annotate:nnn{OMA}{#1\c_hash_str#2}{#4}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_term_omb:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_omb:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \stex_annotate:nnn{OMBIND}{#1\c_hash_str#2}{#4}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_term_arg:nnn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_arg:nnn {
  \exp_args:Nnx \use:nn
    { \int_set:Nn \l_@@_downprec { #2 } 
       \stex_annotate:nnn{arg}{#1}{#3} }
    { \int_set:Nn \l_@@_downprec { \int_use:N \l_@@_downprec } }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_term_assoc_arg:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_assoc_arg:nnnn {
  \seq_set_split:Nnn \l_tmpa_seq , { #4 }
  \int_compare:nNnTF { \seq_count:N \l_tmpa_seq } < 2 {
    \tl_set:Nn \l_tmpa_tl { #4 }
  }{
    \cs_set:Npn \l_tmpa_cs ##1 ##2 { #3 }
    \seq_reverse:N \l_tmpa_seq
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_tl
    \tl_set:No \l_tmpa_tl { \l_tmpb_tl }
    \seq_map_inline:Nn \l_tmpa_seq {
      \tl_set:Nx \l_tmpa_tl {
        \exp_args:Nno
        \l_tmpa_cs { ##1 } { \l_tmpa_tl }
      }
    }
  }
  \exp_args:Nnno
  \stex_term_arg:nnn{#1}{#2}{ \l_tmpa_tl }
}
%    \end{macrocode}
% \end{macro}
%
%\stextest{
%  \begin{module}{Foo6}
%    \importmodule{Foo1}
%     \notation[foo, prec=500;20x20x20]{foobar}{\langle #1 \mid [ #2 ]^{#3} \rangle }{ {#1}_{:#2} }
%     $\foobar a{b,c,d,e,f}g$ and $\foobar[foo] a{b,c}g$ and $\foobar abc$
%
%     \symdecl[args=a]{plus}
%     \symdecl[args=a]{mult}
%     \notation[prec=50]{plus}{#1}{#1 + #2}
%     \notation[prec=100]{mult}{#1}{#1 \cdot #2}
%     $\plus{a,\mult{b,c}}$ and $\mult{a,\plus{\frac ab,\frac ac}}$
%     \[\plus{a,\mult{b,c}}\text{ and }\mult{a,\plus{\frac ab,\frac ac}}\]
%     $\displaystyle \plus{a,\mult{b,c}}$ and $\displaystyle
%       \STEXwithbrackets[]{\mult{a,\plus{\frac ab,\frac ac}}}$
%  \end{module}
%}
%
%
%
%
%
%
%
%
% \end{implementation}
% \immediate\closeout\alltestsoutfile
% \endinput