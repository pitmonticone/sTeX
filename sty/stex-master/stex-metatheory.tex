%%
%% This is file `stex-metatheory.tex',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% stex.dtx  (with options: `metatheory')
%% 
\ExplSyntaxOn
\str_const:Nn \c_stex_metatheory_ns_str {http://mathhub.info/sTeX}
\begin{@module}[ns=\c_stex_metatheory_ns_str,meta=NONE]{Metatheory}
  \ExplSyntaxOff

  % is-a (a:A, a \in A, a is an A, etc.)
  \symdecl[args=ai]{isa}
  \notation[typed]{isa}{#1 \comp: #2}{#1 \comp, #2}
  \notation[in]{isa}{#1 \comp\in #2}{#1 \comp, #2}
  \notation[pred]{isa}{#2\comp(#1 \comp)}{#1 \comp, #2}

  % bind (\forall, \Pi, \lambda etc.)
  \symdecl[args=Bi]{bind}
  \notation[forall]{bind}{\comp\forall #1.\;#2}{#1 \comp, #2}
  \notation[Pi]{bind}{\comp\prod_{#1}#2}{#1 \comp, #2}
  \notation[depfun]{bind}{\comp( #1 \comp{)\;\to\;} #2}{#1 \comp, #2}

  % dummy variable
  \symdecl{dummyvar}
  \notation[underscore]{dummyvar}{\comp\_}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dash]{dummyvar}{\comp{{\rm --}}}

  %fromto (function space, Hom-set, implication etc.)
  \symdecl[args=ai]{fromto}
  \notation[xarrow]{fromto}{#1 \comp\to #2}{#1 \comp\times #2}
  \notation[arrow]{fromto}{#1 \comp\to #2}{#1 \comp\to #2}

  % mapto (lambda etc.)
  %\symdecl[args=Bi]{mapto}
  %\notation[mapsto]{mapto}{#1 \comp\mapsto #2}{#1 \comp, #2}
  %\notation[lambda]{mapto}{\comp\lambda #1 \comp.\; #2}{#1 \comp, #2}
  %\notation[lambdau]{mapto}{\comp\lambda_{#1} \comp.\; #2}{#1 \comp, #2}

  % function/operator application
  \symdecl[args=ia]{apply}
  \notation[prec=0;0x\neginfprec,parens]{apply}{#1 \comp( #2 \comp)}{#1 \comp, #2}
  \notation[prec=0;0x\neginfprec,lambda]{apply}{#1 \; #2 }{#1 \; #2}

  % ``type'' of all collections (sets,classes,types,kinds)
  \symdecl{collection}
  \notation[U]{collection}{\comp{\mathcal{U}}}
  \notation[set]{collection}{\comp{\textsf{Set}}}

  % sequences
  \symdecl[args=1]{seqtype}
  \notation[kleene]{seqtype}{#1^{\comp\ast}}

  \symdef[args=2,li]{sequence-index}{#1_{#2}}
  \notation[ui]{sequence-index}{#1^{#2}}

  %\symdef[args=3,li]{sequence-from-to}{#1_{#2}\comp{,\ellipses,}#1_{#3}}
  %\notation[ui]{sequence-from-to}{#1^{#2}\comp{,\ellipses,}#1^{#3}}
  % ^ superceded by \aseqfromto and \livar/\uivar

  \symdef[args=a,prec=nobrackets]{aseqdots}{#1\comp{,\ellipses}}{#1\comp,#2}
  \symdef[args=ai,prec=nobrackets]{aseqfromto}{#1\comp{,\ellipses\comp,}#2 }{#1\comp,#2}
  \symdef[args=aii,prec=nobrackets]{aseqfromtovia}{#1\comp{,\ellipses\comp,}#2\comp{,\ellipses\comp,}#3}{#1\comp,#2}

  % letin (``let'', local definitions, variable substitution)
  \symdecl[args=bii]{letin}
  \notation[let]{letin}{\comp{{\rm let}}\;#1\comp{=}#2\;\comp{{\rm in}}\;#3}
  \notation[subst]{letin}{#3 \comp[ #1 \comp/ #2 \comp]}
  \notation[frac]{letin}{#3 \comp[ \frac{#2}{#1} \comp]}

  % structures
  \symdecl*[args=1]{module-type}
  \notation{module-type}{\mathtt{MOD} #1}
  \symdecl[name=mathematical-structure,args=a]{mathstruct} % TODO
  \notation[angle,prec=nobrackets]{mathstruct}{\comp\langle #1 \comp\rangle}{#1 \comp, #2}

  \STEXexport{
    \let\nappa\apply
    \def\nappli#1#2#3#4{\apply{#1}{\naseqli{#2}{#3}{#4}}}
    \def\livar{\csname sequence-index\endcsname[li]}
    \def\uivar{\csname sequence-index\endcsname[ui]}
    \def\naseqli#1#2#3{\aseqfromto{\livar{#1}{#2}}{\livar{#1}{#3}}}
    \def\nasequi#1#2#3{\aseqfromto{\uivar{#1}{#2}}{\uivar{#1}{#3}}}
  }

\end{@module}
\ExplSyntaxOff


\endinput
%%
%% End of file `stex-metatheory.tex'.
