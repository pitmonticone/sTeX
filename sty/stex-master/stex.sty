%%
%% This is file `stex.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% stex.dtx  (with options: `package')
%% 
  %     \item If \meta{path} is empty, then
  %         \meta{name} must have been declared earlier in the same file
  %         and retrievable from \cs{g_stex_modules_in_file_seq}, or
  %         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
  %         in the same folder, containing a module \meta{name}.
  %
  %         That module should have the same namespace as the current one.
  %     \item If \meta{path} is not empty, it must point to the relative
  %         path of the containing file as well as the namespace.
  %         \meta{name} must have been declared earlier in the same file
  %         and retrievable from \cs{g_stex_modules_in_file_seq}, or
  %         a file with name \meta{name}|.|\meta{lang}|.tex| must exist
  %         in the top |source| folder of the archive,
  %         containing a module \meta{name}.
  %
  %         That module should lie directly in the namespace
  %         of the archive.
  %     \item If \meta{path} is not empty, it must point to the
  %         path of the containing file as well as the namespace,
  %         relative to the namespace of the archive.
  %
  %         If a module by that namespace exists, it is returned.
  %         Otherwise, we call \cs{stex_require_module:nn}
  %         on the |source| directory of the archive to find the
  %         file.
\RequirePackage{expl3,l3keys2e}
\ProvidesExplPackage{stex}{2021/08/01}{1.9}{bla}
\keys_define:nn { stex } {
  debug     .bool_set:N   = \c_stex_debug_bool ,
  showmods  .bool_set:N   = \c_stex_showmods_bool ,
  lang      .clist_set:N  = \c_stex_languages_clist ,
  mathhub   .tl_set_x:N   = \mathhub ,
  sms       .bool_set:N   = \c_stex_persist_mode_bool
}
\ProcessKeysOptions { stex }
\protected\def\stex{%
  \@ifundefined{texorpdfstring}%
  {\let\texorpdfstring\@firstoftwo}%
  {}%
  \texorpdfstring{\raisebox{-.5ex}S\kern-.5ex\TeX}{sTeX}\xspace%
}
\def\sTeX{\stex}
\msg_new:nnn{stex}{debug}{}
\msg_new:nnn{stex}{warning/nomathhub}{
  MATHHUB~system~variable~not~found~and~no~
  \detokenize{\mathhub}-value~set!
}
\msg_new:nnn{stex}{error/norepository}{}
\msg_new:nnn{stex}{error/modulemissing}{}
\cs_new_protected:Nn \stex_debug:n {
  \bool_if:nT{\c_stex_debug_bool}{
    \exp_args:Nnnx\msg_set:nnn{stex}{debug}{\\Debug:~#1\\}
    \msg_term:nn{stex}{debug} % should be \msg_note:nn
  }
}

\stex_debug:n{Debug~mode~on}
\iow_new:N \c__stex_sms_iow
\AddToHook{begindocument}{
  \bool_if:NTF \c_stex_persist_mode_bool {
    \ExplSyntaxOn \input{\jobname.sms} \ExplSyntaxOff
  } {
    \iow_open:Nn \c__stex_sms_iow {\jobname.sms}
  }
}
\AddToHook{enddocument}{
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_close:N \c__stex_sms_iow
  }
}
\cs_new_protected:Nn \stex_addtosms:n {
  \bool_if:NF \c_stex_persist_mode_bool {
    \iow_now:Nn \c__stex_sms_iow { #1 }
  }
}
\RequirePackage{scalatex}
\scalatex_add_Namespace:nn{stex}{http://kwarc.info/ns/sTeX}
\ifcsname if@latexml\endcsname\else
    \expandafter\newif\csname if@latexml\endcsname\@latexmlfalse
\fi

\prg_new_conditional:Nnn \latexml_if: {p, T, F, TF} {
  \if@latexml
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
\tl_new:N \l__stex_annotate_arg_tl
\tl_const:Nx \c__stex_annotate_emptyarg_tl {
  \scalatex_if:TF {
    \scalatex_direct_HTML:n { \c_ampersand_str lrm; }
  }{~}
}
\cs_new_protected:Nn \__stex_annotate_checkempty:n {
  \tl_set:Nn \l__stex_annotate_arg_tl { #1 }
  \tl_if_empty:NT \l__stex_annotate_arg_tl {
    \tl_set_eq:NN \l__stex_annotate_arg_tl \c__stex_annotate_emptyarg_tl
  }
}
\scalatex_if:TF{
  \cs_new_protected:Nn \stex_annotate:nnn {
    \__stex_annotate_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2"
    } {
      \tl_use:N \l__stex_annotate_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:n {
    \__stex_annotate_checkempty:n { #1 }
    \scalatex_annotate_HTML:nn {
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l__stex_annotate_arg_tl
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:nnn {
    \__stex_annotate_checkempty:n { #3 }
    \scalatex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2" ~
      stex:visible="false" ~
      style:display="none"
    } {
      \tl_use:N \l__stex_annotate_arg_tl
    }
  }
  \NewDocumentEnvironment{stex_annotate_env} { m m } {
    \par
    \scalatex_annotate_HTML_begin:n {
      property="stex:#1" ~
      resource="#2"
    }
  }{
    \scalatex_annotate_HTML_end:
  }
}{
  \latexml_if:TF {
    \cs_new_protected:Nn \stex_annotate:nnn {
      \__stex_annotate_checkempty:n { #3 }
      \mode_if_math:TF {
        \cs:w latexml@annotate@math\cs_end:{#1}{#2}{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }{
        \cs:w latexml@annotate@text\cs_end:{#1}{#2}{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:n {
      \__stex_annotate_checkempty:n { #1 }
      \mode_if_math:TF {
        \cs:w latexml@invisible@math\cs_end:{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      } {
        \cs:w latexml@invisible@text\cs_end:{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {
      \__stex_annotate_checkempty:n { #3 }
      \cs:w latexml@annotate@invisible\cs_end:{#1}{#2}{
        \tl_use:N \l__stex_annotate_arg_tl
      }
    }
    \NewDocumentEnvironment{stex_annotate_env} { m m } {
      \par\begin{latexml@annotateenv}{#1}{#2}
    }{
      \end{latexml@annotateenv}
    }
  }{
    \cs_new_protected:Nn \stex_annotate:nnn {#3}
    \cs_new_protected:Nn \stex_annotate_invisible:n {}
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {}
    \NewDocumentEnvironment{stex_annotate_env} { m m } {\par}{}
  }
}
\prop_const_from_keyval:Nn \c_stex_languages_prop {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}

\prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}
\clist_if_empty:NF \c_stex_languages_clist {
  \clist_clear:N \l_tmpa_clist
  \clist_map_inline:Nn \c_stex_languages_clist {
    \prop_get:NnNTF \c_stex_languages_prop { #1 } \l_tmpa_str {
      \clist_put_right:No \l_tmpa_clist \l_tmpa_str
    } {
      \msg_set:nnn{stex}{error/unknownlanguage}{
        Unknown~language~\l_tmpa_str
      }
      \msg_error:nn{stex}{error/unknownlanguage}
    }
  }
  \stex_debug:n {Languages:~\clist_use:Nn \l_tmpa_clist {,~} }
  \RequirePackage[\clist_use:Nn \l_tmpa_clist ,]{babel}
}
%% TODO Windows paths
\cs_new_protected:Nn \stex_path_from_string:Nn {
  \exp_args:NNe\str_set:Nn \l_tmpa_tl { #2 }
  \tl_trim_spaces:N \l_tmpa_tl
  \str_if_empty:NTF \l_tmpa_tl {
    \seq_set_eq:NN #1 \c_empty_seq
  }{
    \exp_args:NNNo \seq_set_split:Nnn #1 / { \l_tmpa_tl }
    \stex_path_canonicalize:N #1
  }
}
\cs_generate_variant:Nn \stex_path_from_string:Nn
  { NV, cn, cV }
\cs_new_protected:Nn \stex_path_to_string:NN {
  \exp_args:NNe \str_set:Nn #2 { \seq_use:Nn #1 / }
}

\cs_new:Nn \stex_path_to_string:N {
  \seq_use:Nn #1 /
}
\str_const:Nn \c__stex_path_dot_str {.}
\str_const:Nn \c__stex_path_up_str {..}
\cs_new_protected:Nn \stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_clear:N \l_tmpa_seq
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NT \l_tmpa_tl {
      \seq_put_right:Nn \l_tmpa_seq {}
    }
    \seq_map_inline:Nn #1 {
      \str_set:Nn \l_tmpa_tl { ##1 }
      \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_dot_str {} {
        \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_up_str {
          \seq_if_empty:NTF \l_tmpa_seq {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
              \c__stex_path_up_str
            }
          }{
            \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
            \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_up_str {
              \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
                \c__stex_path_up_str
              }
            }{
              \seq_pop_right:NN \l_tmpa_seq \l_tmpb_tl
            }
          }
        }{
          \str_if_empty:NF \l_tmpa_tl {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq { \l_tmpa_tl }
          }
        }
      }
    }
    \seq_gset_eq:NN #1 \l_tmpa_seq
  }
}
\prg_new_conditional:Nnn \stex_path_if_absolute:N {p, T, F, TF} {
  \seq_if_empty:NTF #1 {
    \prg_return_false:
  }{
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NTF \l_tmpa_tl {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
\str_new:N\l_stex_kpsewhich_return_str
\cs_new_protected:Nn \stex_kpsewhich:n {
  \sys_get_shell:nnN { kpsewhich ~ #1 } { } \l_tmpa_tl
  \exp_args:NNo\str_set:Nn\l_stex_kpsewhich_return_str{\l_tmpa_tl}
  \tl_trim_spaces:N \l_stex_kpsewhich_return_str
}
\sys_if_platform_windows:TF{
  \stex_kpsewhich:n{-expand-var~\c_percent_str CD\c_percent_str}
}{
  \stex_kpsewhich:n{-var-value~PWD}
}

\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:n {PWD:~\str_use:N\c_stex_pwd_str}
\seq_gclear_new:N\g__stex_files_stack
\stex_path_from_string:Nn \c_stex_mainfile_seq {
  \c_stex_pwd_str/\g_file_curr_name_str.tex
}
\seq_gclear_new:N\g_stex_currentfile_seq
\AddToHook{file/before}{
  \stex_path_from_string:Nn\g_stex_currentfile_seq{\CurrentFilePath}
  \stex_path_if_absolute:NTF\g_stex_currentfile_seq{
    \exp_args:NNe\seq_put_right:Nn\g_stex_currentfile_seq{\CurrentFile}
  }{
    \stex_path_from_string:Nn\g_stex_currentfile_seq{
      \c_stex_pwd_str/\CurrentFilePath/\CurrentFile
    }
  }
  \seq_gset_eq:NN\g_stex_currentfile_seq\g_stex_currentfile_seq
  \exp_args:NNo\seq_gpush:Nn\g__stex_files_stack\g_stex_currentfile_seq
}
\AddToHook{file/after}{
  \seq_if_empty:NF\g__stex_files_stack{
    \seq_gpop:NN\g__stex_files_stack\l_tmpa_seq
  }
  \seq_if_empty:NTF\g__stex_files_stack{
    \seq_gset_eq:NN\g_stex_currentfile_seq\c_stex_mainfile_seq
  }{
    \seq_get:NN\g__stex_files_stack\l_tmpa_seq
    \seq_gset_eq:NN\g_stex_currentfile_seq\l_tmpa_seq
  }
}
\str_if_empty:NTF\mathhub{
  \stex_kpsewhich:n{-var-value~MATHHUB}
  \str_set_eq:NN\c_stex_mathhub_str\l_stex_kpsewhich_return_str

  \str_if_empty:NTF\c_stex_mathhub_str{
    \msg_warning:nn{stex}{warning/nomathhub}
  }{
    \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
    \stex_path_from_string:Nn\c_stex_mathhub_seq\c_stex_mathhub_str
  }
}{
  \stex_path_from_string:Nn\c_stex_mathhub_seq\mathhub
  \stex_path_to_string:NN\c_stex_mathhub_seq\c_stex_mathhub_str
  \stex_debug:n {MathHub:~\str_use:N\c_stex_mathhub_str}
}
\cs_new_protected:Nn \__stex_mathhub_do_manifest:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_if_exist:cF {c_stex_mathhub_#1_manifest_prop} {
    \prop_new:c { c_stex_mathhub_#1_manifest_prop }
    \seq_set_split:NnV \l_tmpa_seq / \l_tmpa_str
    \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpa_seq
    \__stex_mathhub_find_manifest:N \l_tmpa_seq
    \seq_if_empty:NTF \l__stex_mathhub_manifest_file_seq {
      \msg_set:nnn{stex}{error/norepository}{
        No~archive~#1~found~in~
          \stex_path_to_string:N \c_stex_mathhub_str
      }
      \msg_error:nn{stex}{error/norepository}
    } {
      \exp_args:No \__stex_mathhub_parse_manifest:n { \l_tmpa_str }
    }
  }
}
\str_new:N\l__stex_mathhub_manifest_file_seq
\cs_new_protected:Nn \__stex_mathhub_find_manifest:N {
  \seq_set_eq:NN\l_tmpa_seq #1
  \bool_set_true:N\l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_if_empty:NTF \l_tmpa_seq {
      \bool_set_false:N\l_tmpa_bool
    }{
      \file_if_exist:nTF{
        \stex_path_to_string:N\l_tmpa_seq/MANIFEST.MF
      }{
        \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
        \bool_set_false:N\l_tmpa_bool
      }{
        \file_if_exist:nTF{
          \stex_path_to_string:N\l_tmpa_seq/META-INF/MANIFEST.MF
        }{
          \seq_put_right:Nn\l_tmpa_seq{META-INF}
          \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
          \bool_set_false:N\l_tmpa_bool
        }{
          \file_if_exist:nTF{
            \stex_path_to_string:N\l_tmpa_seq/meta-inf/MANIFEST.MF
          }{
            \seq_put_right:Nn\l_tmpa_seq{meta-inf}
            \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
            \bool_set_false:N\l_tmpa_bool
          }{
            \seq_pop_right:NN\l_tmpa_seq\l_tmpa_tl
          }
        }
      }
    }
  }
  \seq_set_eq:NN\l__stex_mathhub_manifest_file_seq\l_tmpa_seq
}
\ior_new:N \c__stex_mathhub_manifest_ior
\cs_new_protected:Nn \__stex_mathhub_parse_manifest:n {
  \seq_set_eq:NN \l_tmpa_seq \l__stex_mathhub_manifest_file_seq
  \ior_open:Nn \c__stex_mathhub_manifest_ior {\stex_path_to_string:N \l_tmpa_seq}
  \ior_map_inline:Nn \c__stex_mathhub_manifest_ior {
    \str_set:Nn \l_tmpa_str {##1}
    \exp_args:NNoo \seq_set_split:Nnn
        \l_tmpb_seq \c_colon_str \l_tmpa_str
    \seq_pop_left:NNTF \l_tmpb_seq \l_tmpa_tl {
      \exp_args:NNe \str_set:Nn \l_tmpb_tl {
        \exp_args:NNo \seq_use:Nn \l_tmpb_seq \c_colon_str
      }
      \exp_args:No \str_case:nnTF \l_tmpa_tl {
        {id} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { id } \l_tmpb_tl
        }
        {narration-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { narr } \l_tmpb_tl
        }
        {source-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { ns } \l_tmpb_tl
        }
        {ns} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { ns } \l_tmpb_tl
        }
        {dependencies} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { deps } \l_tmpb_tl
        }
      }{}{}
    }{}
  }
  \ior_close:N \c__stex_mathhub_manifest_ior
}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \prop_set_eq:Nc \l_stex_current_repository_prop {
    c_stex_mathhub_#1_manifest_prop
  }
}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \stex_debug:n{Opening~archive:~#1}
    \__stex_mathhub_do_manifest:n { #1 }
    \exp_args:Nx \stex_addtosms:n {
      \prop_const_from_keyval:cn { c_stex_mathhub_#1_manifest_prop } {
        id   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  id  } ,
        ns   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  ns  } ,
        narr = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { narr } ,
        deps = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { deps }
      }
    }
  }
}
\prop_new:N \l_stex_current_repository_prop
\AddToHook{begindocument}{
  \__stex_mathhub_find_manifest:N \c_stex_pwd_seq
  \seq_if_empty:NTF \l__stex_mathhub_manifest_file_seq {
    \stex_debug:n{Not~currently~in~a~MathHub~repository}
  } {
    \__stex_mathhub_parse_manifest:n { main }
    \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id}
      \l_tmpa_str
    \prop_set_eq:cN { c_stex_mathhub_\l_tmpa_str _manifest_prop }
    \stex_set_current_repository:n { main }
    \stex_debug:n{Current~repository:~
      \prop_item:Nn \l_stex_current_repository_map {id}
    }
  }
}
\prop_new:N \l_stex_current_module_prop
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \prop_if_empty:NTF \l_stex_current_module_prop
    \prg_return_false: \prg_return_true:
}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \prop_get:NnN \l_stex_current_module_prop { content } \l_tmpa_tl
  \tl_put_right:Nn \l_tmpa_tl { #1 }
  \prop_put:Nno \l_stex_current_module_prop { content } \l_tmpa_tl
}
\cs_new_protected:Nn \stex_add_constant_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { constants } \l_tmpa_seq
}
\cs_new_protected:Nn \stex_add_import_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_get:NnN \l_stex_current_module_prop { imports } \l_tmpa_seq
  \seq_put_right:No \l_tmpa_seq { \l_tmpa_str }
  \prop_put:Nno \l_stex_current_module_prop { imports } \l_tmpa_seq
}
\str_new:N \l_stex_modules_ns_str
\cs_new_protected:Nn \stex_modules_compute_namespace:nN {
  \str_set:Nx \l_tmpa_str { #1 }
  \seq_set_eq:NN \l_tmpa_seq #2
  % split off file extension
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \bool_set_true:N \l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:No \str_case:nnTF { \l_tmpb_str } {
      {source} { \bool_set_false:N \l_tmpa_bool }
    }{}{
      \seq_if_empty:NT \l_tmpa_seq {
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }

  \seq_if_empty:NTF \l_tmpa_seq {
    \str_set_eq:NN \l_stex_modules_ns_str \l_tmpa_str
  }{
    \str_set:Nx \l_stex_modules_ns_str {
      \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
\cs_new_protected:Nn \stex_modules_current_namespace: {
  \prop_get:NnNTF \l_stex_current_repository_prop { ns } \l_tmpa_str {
    \stex_modules_compute_namespace:nN \l_tmpa_str \g_stex_currentfile_seq
  }{
    % split off file extension
    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
    \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \str_set:Nx \l_stex_modules_ns_str {
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
\keys_define:nn { stex / module } {
  title .tl_set_x:N  = \l_stex_module_title_str ,
  ns    .tl_set_x:N  = \l_stex_module_ns_str ,
  lang  .tl_set_x:N  = \l_stex_module_lang_str ,
  sig   .tl_set_x:N  = \l_stex_module_sig_str ,
  meta  .tl_set_x:N  = \l_stex_module_meta_str
}


\cs_new_protected:Nn \__stex_module_args:n {
  \str_clear:N \l_stex_module_title_str
  \str_clear:N \l_stex_module_ns_str
  \str_clear:N \l_stex_module_lang_str
  \str_clear:N \l_stex_module_sig_str
  \str_clear:N \l_stex_module_meta_str
  \keys_set:nn { stex / module } { #1 }
  \exp_args:NNo \str_set:Nn \l_stex_module_title_str
    \l_stex_module_title_str
  \exp_args:NNo \str_set:Nn \l_stex_module_ns_str
    \l_stex_module_ns_str
  \exp_args:NNo \str_set:Nn \l_stex_module_lang_str
    \l_stex_module_lang_str
  \exp_args:NNo \str_set:Nn \l_stex_module_sig_str
    \l_stex_module_sig_str
  \exp_args:NNo \str_set:Nn \l_stex_module_meta_str
    \l_stex_module_meta_str
}
\cs_new_protected:Nn \__stex_module_begin_module: {
  % Nested module?
  \stex_if_in_module:TF {
    % Nested module
    \prop_get:NnN \l_stex_current_module_prop
      { ns } \l_stex_module_ns_str
    \str_set:Nx \l_stex_module_name_str {
      \prop_item:Nn \l_stex_current_module_prop
        { name } / \l_stex_module_name_str
    }
  }{
    % not nested:
    \str_if_empty:NT \l_stex_module_ns_str {
      \stex_modules_current_namespace:
      \str_set_eq:NN \l_stex_module_ns_str \l_stex_modules_ns_str
      \exp_args:NNNo \seq_set_split:Nnn \l_tmpa_seq
         / {\l_stex_module_ns_str}
      \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
      \str_if_eq:NNT \l_tmpa_str \l_stex_module_name_str {
        \str_set:Nx \l_stex_module_ns_str {
          \stex_path_to_string:N \l_tmpa_seq
        }
      }
    }
  }

  % language
  \str_if_empty:NF \l_stex_module_lang_str {
    \prop_get:NVNTF \c_stex_languages_prop \l_stex_module_lang_str
      \l_tmpa_str {
        \exp_args:Nx \selectlanguage { \l_tmpa_str }
      } {
        \msg_set:nnn{stex}{error/unknownlanguage}{
          Unknown~language~\l_tmpa_str
        }
        \msg_error:nn{stex}{error/unknownlanguage}
      }
  }

  % signature
  \str_if_empty:NF \l_stex_module_sig_str {
    \str_if_empty:NT \l_stex_module_lang_str {
      \msg_set:nnn{stex}{error/siglanguage}{
        Module~\l_stex_module_ns_str?\l_stex_module_name_str~
        declares~signature~\l_stex_module_sig_str,~but~does~not~
        declare~its~language
      }
      \msg_error:nn{stex}{error/siglanguage}
    }
  }

  % metatheory

  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
    name      = \l_stex_module_name_str ,
    ns        = \l_stex_module_ns_str ,
    import    = \exp_not:o { \l_tmpa_seq } ,
    constants = \exp_not:o { \l_tmpa_seq } ,
    content   = \exp_not:o { \l_tmpa_seq }  ,
    file      = \exp_not:o { \g_stex_currentfile_seq } ,
    lang      = \l_stex_module_lang_str ,
    sig       = \l_stex_module_sig_str ,
    meta      = \l_stex_module_meta_str
  }

  \stex_debug:n{
    New~module:\\
    Namespace:~\l_stex_module_ns_str\\
    Name:~\l_stex_module_name_str\\
    Language:~\l_stex_module_lang_str\\
    Signature:~\l_stex_module_sig_str\\
    Metatheory:~\l_stex_module_meta_str\\
    File:~\stex_path_to_string:N \g_stex_currentfile_seq
  }

  \seq_gput_right:Nx  \g_stex_modules_in_file_seq
      { \l_stex_module_ns_str ? \l_stex_module_name_str }

  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env} {theory} {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }

    \stex_annotate_invisible:nnn{header}{} {
      \stex_annotate:nnn{language}{ \l_stex_module_lang_str }{}
      \stex_annotate:nnn{signature}{ \l_stex_module_sig_str }{}
      \str_if_empty:NT \l_stex_module_meta_str {
        % TODO metatheory
      }
    }
  }
}
\iffalse \end{stex_annotate_env} \fi % make syntax highlighting work again
\iffalse \begin{stex_annotate_env} \fi %^^A make syntax highlighting work again
\cs_new_protected:Nn \__stex_module_end_module: {
  \str_set:Nx \l_tmpa_str {
    c_stex_module_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  \prop_new:c { \l_tmpa_str }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_addtosms:n {
      \prop_gset_from_keyval:cn {
        c_stex_module_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        import    = \prop_item:cn { \l_tmpa_str } { import } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta }
      }
    }
  }{
    \end{stex_annotate_env}
  }
}
\NewDocumentEnvironment { @module } { O{} m } {
  \str_set:Nx \l_stex_module_name_str { #2 }
  \par
  \__stex_module_args:n { #1 }
  \__stex_module_begin_module:
} {
  \__stex_module_end_module:
}
\cs_if_exist:NTF \thesection {
  \newcounter{module}[section]
}{
  \newcounter{module}
}

\bool_if:NT \c_stex_showmods_bool {
  \latexml_if:F { \RequirePackage{mdframed} }
}

\cs_new_protected:Nn \stex_modules_heading: {
  \stepcounter{module}
  \par
  \bool_if:NT \c_stex_showmods_bool {
    \noindent{\textbf{Module} ~
      \cs_if_exist:NT \thesection {\thesection.}
      \themodule ~ [\l_stex_module_name_str]
    }
    % TODO references
    % \sref@label@id{Module \thesection.\themodule [\module@name]}%
    \str_if_empty:NTF \l_stex_module_title_str {
    }{
      \quad(\l_stex_module_title_str)\hfill
    }
  }
}
\NewDocumentEnvironment { module } { O{} m } {
  \begin{@module}[#1]{#2}
    \stex_modules_heading:
    \bool_if:NT \c_stex_showmods_bool {
      \begin{mdframed}
    }
}{
  \bool_if:NT \c_stex_showmods_bool {
    \end{mdframed}
  }
  \end{@module}
}
\tl_new:N \g_stex_smsmode_allowedmacros_tl
\tl_new:N \g_stex_smsmode_allowedmacros_escape_tl
\seq_new:N \g_stex_smsmode_allowedenvs_seq

\tl_set:Nn \g_stex_smsmode_allowedmacros_tl {
  \makeatletter
  \makeatother
  \ExplSyntaxOn
  \ExplSyntaxOff
}

\tl_set:Nn \g_stex_smsmode_allowedmacros_escape_tl {
  \symdef
  \importmodule
  \notation
  \symdecl
}

\exp_args:NNx \seq_set_from_clist:Nn \g_stex_smsmode_allowedenvs_seq {
  \tl_to_str:n {
    module,
    @module
  }
}
\bool_new:N \g__stex_smsmode_bool
\bool_set_false:N \g__stex_smsmode_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g__stex_smsmode_bool \prg_return_true: \prg_return_false:
}
\bool_new:N \g__stex_smsmode_catcode_bool
\bool_set_false:N \g__stex_smsmode_catcode_bool
\prg_new_conditional:Nnn \__stex_smsmode_if_catcodes: { p, T, F, TF } {
  \bool_if:NTF \g__stex_smsmode_catcode_bool
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_smsmode_set_codes: {
  \stex_if_smsmode:T {
    \__stex_smsmode_if_catcodes:F {
      \bool_gset_true:N \g__stex_smsmode_catcode_bool
      \exp_after:wN \char_gset_active_eq:NN
        \c_backslash_str \__stex_smsmode_cs:
      \tex_global:D \char_set_catcode_active:N \\
      \tex_global:D \char_set_catcode_other:N $
      \tex_global:D \char_set_catcode_other:N ^
      \tex_global:D \char_set_catcode_other:N _
      \tex_global:D \char_set_catcode_other:N &
      \tex_global:D \char_set_catcode_other:N ##
    }
  }
} \iffalse $ \fi % to make syntax highlighting work again
\cs_new_protected:Nn \__stex_smsmode_unset_codes: {
  \__stex_smsmode_if_catcodes:T {
    \bool_gset_false:N \g__stex_smsmode_catcode_bool
    \exp_after:wN \tex_global:D \exp_after:wN
      \char_set_catcode_escape:N \c_backslash_str
    \tex_global:D \char_set_catcode_math_toggle:N $
    \tex_global:D \char_set_catcode_math_superscript:N ^
    \tex_global:D \char_set_catcode_math_subscript:N _
    \tex_global:D \char_set_catcode_alignment:N &
    \tex_global:D \char_set_catcode_parameter:N ##
  }
} \iffalse $ \fi % to make syntax highlighting work again
\cs_new_protected:Nn \stex_in_smsmode:nn {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_eq:cN { l__stex_smsmode_#1_bool } \g__stex_smsmode_bool
    \bool_gset_true:N \g__stex_smsmode_bool
    \stex_smsmode_set_codes:
    #2
    \bool_gset_eq:Nc \g__stex_smsmode_bool { l__stex_smsmode_#1_bool }
    \stex_if_smsmode:F {
      \__stex_smsmode_unset_codes:
    }
  }
  \box_clear:N \l_tmpa_box
}
\str_const:Nn \c__stex_smsmode_begin_str { begin }
\str_const:Nn \c__stex_smsmode_end_str { end }

\cs_new_protected:Nn \__stex_smsmode_cs: {
  \str_clear:N \l_tmpa_str
  \peek_analysis_map_inline:n {
    % #1: token (one expansion)
    % #2: charcode
    % #3 catcode
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpa_str { ##1 }
    } {
      \str_if_empty:NTF \l_tmpa_str {
        % we don't allow (or need) single non-letter CSs
        % for now
        \peek_analysis_map_break:
      }{
        \str_if_eq:nnTF \l_tmpa_str \c_stex_begin_str {
          \peek_analysis_map_break:n {
            \exp_after:wN \__stex_smsmode_checkbegin:n ##1
          }
        } {
          \str_if_eq:nnTF \l_tmpa_str \c_stex_end_str {
            \peek_analysis_map_break:n {
              \exp_after:wN \__stex_smsmode_checkend:n ##1
            }
          } {
          \tl_set:Nn \l_tmpa_tl { \use:c{\l_tmpa_str} }
          \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF
            \g_stex_smsmode_allowedmacros_tl
              { \use:c{\l_tmpa_str} } {
              \peek_analysis_map_break:n {
                \exp_after:wN \l_tmpa_tl ##1
              }
            } {
              \exp_args:NNNo \exp_args:NNo \tl_if_in:NnTF
              \g_stex_smsmode_allowedmacros_escape_tl
                { \use:c{\l_tmpa_str} } {
                \exp_args:NNNo \exp_args:No
                \token_if_eq_charcode_p:NNTF \c_backslash_str ##1 {
                  \peek_analysis_map_break:n {
                    \__stex_smsmode_unset_codes:
                    \__stex_smsmode_rescan_cs:
                  }
                } {
                  \peek_analysis_map_break:n {
                    \__stex_smsmode_unset_codes:
                    \exp_after:wN \l_tmpa_tl ##1
                  }
                }
              } {
                \peek_analysis_map_break:n { ##1 }
              }
            }
          }
        }
      }
    }
  }
}
\cs_new_protected:Nn \__stex_smsmode_rescan_cs: {
  \str_clear:N \l_tmpb_str
  \peek_analysis_map_inline:n {
    \token_if_eq_charcode:NNTF ##3 B {
      % token is a letter
      \exp_args:NNo \str_put_right:Nn \l_tmpb_str { ##1 }
    } {
      \peek_analysis_map_break:n {
        \exp_after:wN \use:c \exp_after:wN {
          \exp_after:wN \l_tmpa_str\exp_after:wN
        } \use:c { \l_tmpb_str \exp_after:wN } ##1
      }
    }
  }
}
\cs_new_protected:Nn \__stex_smsmode_checkbegin:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \__stex_smsmode_unset_codes:
    \begin{#1}
  }
}
\cs_new_protected:Nn \__stex_smsmode_checkend:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \seq_if_in:NoT \g_stex_smsmode_allowedenvs_seq \l_tmpa_str {
    \end{#1}
  }
}
\cs_new_protected:Nn \stex_import_module_uri:nn {
  \str_set:Nx \l__stex_importmodule_archive_str { #1 }
  \str_set:Nx \l__stex_importmodule_path_str { #2 }
  \str_if_empty:NT \l__stex_importmodule_archive_str {
    \prop_if_empty:NF \l_stex_current_repository_prop {
      \prop_get:NnN \l_stex_current_repository_prop { id } \l__stex_importmodule_archive_str
    }
  }

  \exp_args:NNNo \seq_set_split:Nnn \l_tmpb_seq ? { \l_tmpb_str }
  \seq_pop_right:NN \l_tmpb_seq \l__stex_importmodule_name_str
  \str_set:Nx \l__stex_importmodule_path_str { \seq_use:Nn \l_tmpa_seq ? }

  \str_if_empty:NTF \l_tmpa_str {
    \stex_modules_current_namespace:
    \str_if_empty:NTF \l__stex_importmodule_path_str {
      \str_set:Nx \l_stex_module_ns_str {
        \l_stex_module_ns_str ? \l__stex_importmodule_name_str
      }
    }{
      \str_set:Nx \l_stex_module_ns_str {
        \l_stex_module_ns_str / \l__stex_importmodule_path_str ? \l__stex_importmodule_name_str
      }
    }
  }{
    \stex_require_repository:n \l__stex_importmodule_archive_str
    \prop_get:cnN { c_stex_mathhub_\l__stex_importmodule_archive_str _manifest_prop } { ns }
      \l_stex_module_ns_str
    \str_if_empty:NTF \l__stex_importmodule_path_str {
      \str_set:Nx \l__stex_importmodule_module_ns_str {
        \l_stex_module_ns_str ? \l__stex_importmodule_name_str
      }
    }{
      \str_set:Nx \l__stex_importmodule_module_ns_str {
        \l_stex_module_ns_str / \l__stex_importmodule_path_str ? \l__stex_importmodule_name_str
      }
    }
  }
}
\str_new:N \l__stex_importmodule_name_str
\str_new:N \l__stex_importmodule_archive_str
\str_new:N \l__stex_importmodule_path_str
\cs_new_protected:Nn \stex_import_require_module:nnnn {
  \exp_args:Nx \stex_if_module_exists:nF { #1 ? #4 } {
    % archive
    \str_set:Nx \l_tmpa_str { #2 }
    \str_if_empty:NTF \l_tmpa_str {
      \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    } {
      \seq_set_eq:NN \l_tmpa_seq \c_stex_mathhub_seq
      \exp_args:NNo \stex_path_from_string:Nn \l_tmpb_seq { \l_tmpa_str }
      \seq_concat:NNN \l_tmpa_seq \l_tmpa_seq \l_tmpb_seq
      \seq_put_right:Nn \l_tmpa_seq { source }
    }

    % path
    \str_set:Nx \l_tmpb_str { #3 }
    \str_if_empty:NT \l_tmpb_str {
      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq / #4 }

      \cs_if_exist:NTF \languagename {
        \prop_get:NnN \c_stex_language_abbrevs_prop
            { \languagename } \l_tmpb_str
      }

      \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
        \str_set:Nx \l_tmpa_str { \l_tmpa_str.\l_tmpb_str.tex }
      }{
        \IfFileExists{ \l_tmpa_str.tex }{
          \str_set:Nx \l_tmpa_str { \l_tmpa_str.tex }
        }{
          % try english as default
          \IfFileExists{ \l_tmpa_str.en.tex }{
            \str_set:Nx \l_tmpa_str { \l_tmpa_str.en.tex }
          }{
            \msg_new:nnn{stex}{error/modulemissing}{
              No~file~for~module~#1?#4~found
            }
            \msg_error:nn{stex}{error/modulemissing}
          }
        }
      }

    } {
      \exp_args:NNo \stex_path_from_string:Nn \l_tmpb_seq { \l_tmpb_str }
      \seq_concat:NNN \l_tmpa_seq \l_tmpa_seq \l_tmpb_seq

      \cs_if_exist:NTF \languagename {
        \prop_get:NnN \c_stex_language_abbrevs_prop
            { \languagename } \l_tmpb_str
      }

      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq }

      \IfFileExists{ \l_tmpa_str/#4.\l_tmpb_str.tex }{
        \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.\l_tmpb_str.tex }
      }{
        \IfFileExists{ \l_tmpa_str/#4.tex }{
          \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.tex }
        }{
          % try english as default
          \IfFileExists{ \l_tmpa_str/#4.en.tex }{
            \str_set:Nx \l_tmpa_str { \l_tmpa_str/#4.en.tex }
          }{
            \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
              \str_set:Nx \l_tmpa_str { \l_tmpa_str.\l_tmpb_str.tex }
            }{
              \IfFileExists{ \l_tmpa_str.tex }{
                \str_set:Nx \l_tmpa_str { \l_tmpa_str.tex }
              }{
                % try english as default
                \IfFileExists{ \l_tmpa_str.en.tex }{
                  \str_set:Nx \l_tmpa_str { \l_tmpa_str.en.tex }
                }{
                  \msg_new:nnn{stex}{error/modulemissing}{
                    No~file~for~module~#1?#4~found
                  }
                  \msg_error:nn{stex}{error/modulemissing}
                }
              }
            }
          }
        }
      }
    }

    \seq_set_eq:NN \l_tmpa_seq \g_stex_modules_in_file_seq
    \seq_clear:N \g_stex_modules_in_file_seq
    \exp_args:No \stex_in_smsmode:nn { \l_tmpa_str } {
      \str_set:Nx \l_tmpb_str { #2 }
      \str_if_empty:NF \l_tmpb_str {
        \stex_set_current_repository:n { #2 }
      }
      \input { \l_tmpa_str }
    }
    \prop_gput:Noo \g_stex_module_files_prop
      \l_tmpa_str \g_stex_modules_in_file_seq
    \seq_set_eq:NN \g_stex_modules_in_file_seq \l_tmpa_seq

    \stex_if_module_exists:nF { #1 ? #4 } {
      \msg_new:nnn{stex}{error/modulemissing}{
        Module~#1?#4~not~found~in~file~\l_tmpa_str
      }
      \msg_error:nn{stex}{error/modulemissing}
    }
    % TODO write to sms file
  }
  % activate
  \prop_item:cn { c_stex_module_#1?#4_prop } { content }
}
\NewDocumentCommand \importmodule { O{} m } {
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_if_smsmode:F {
    \stex_import_require_module:nnnn
    { \l_stex_module_ns_str } { \l__stex_importmodule_archive_str }
    { \l__stex_importmodule_path_str } { \l__stex_importmodule_name_str }
    \stex_annotate_invisible:nnn
      {import} {\l_stex_module_ns_str ? \l__stex_importmodule_name_str} {}
  }
  \exp_args:Nx \stex_add_to_current_module:n {
    \stex_import_require_module:nnnn
    { \l_stex_module_ns_str } { \l__stex_importmodule_archive_str }
    { \l__stex_importmodule_path_str } { \l__stex_importmodule_name_str }
  }
  \exp_args:Nx \stex_add_import_to_current_module:n {
    \l_stex_module_ns_str ? \l__stex_importmodule_name_str
  }
  \stex_smsmode_set_codes:
}
\NewDocumentCommand \usemodule { O{} m } {
  \stex_if_smsmode:F {
    \stex_import_module_uri:nn { #1 } { #2 }
    \stex_import_require_module:nnnn
    { \l__stex_importmodule_module_ns_str } { \l__stex_importmodule_archive_str }
    { \l__stex_importmodule_path_str } { \l__stex_importmodule_name_str }
    \stex_annotate_invisible:nnn
      {usemodule} {\l_stex_module_ns_str ? \l__stex_importmodule_name_str} {}
  }
  \stex_smsmode_set_codes:
}
\seq_new:N \g_stex_modules_in_file_seq
\prop_new:N \g_stex_module_files_prop
\keys_define:nn { stex / symdecl } {
  name  .tl_set_x:N  = \l_stex_symdecl_name_str ,
  local .bool_set:N  = \l_stex_symdecl_local_bool ,
  args  .tl_set_x:N  = \l_stex_symdecl_args_str ,
  type  .tl_set:N    = \l_stex_symdecl_type_tl
}

\cs_new_protected:Nn \__stex_symdecl_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl

  \keys_set:nn { stex /symdecl } { #1 }

  \exp_args:NNo \str_set:Nn \l_stex_symdecl_name_str
    \l_stex_symdecl_name_str
  \exp_args:NNo \str_set:Nn \l_stex_symdecl_args_str
    \l_stex_symdecl_args_str
}
\NewDocumentCommand \symdecl { O{} m } {
  \__stex_symdecl_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_symdecl_do:n { #2 }
}
\cs_new_protected:Nn \stex_symdecl_do:n {
  \stex_if_in_module:F {
    % TODO throw error? some default namespace?
  }

  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }

  \prop_if_exist:cT { g_stex_symdecl_
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name} ?
      \l_stex_symdecl_name_str
    _prop
  }{
    % TODO throw error (beware of circular dependencies)
  }

  \prop_clear:N \l_tmpa_prop
  \prop_put:Nnx \l_tmpa_prop { module } {
    \prop_item:Nn \l_stex_current_module_prop {ns} ?
    \prop_item:Nn \l_stex_current_module_prop {name}
  }
  \seq_clear:N \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { notations } \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { name } \l_stex_symdecl_name_str
  \prop_put:Nno \l_tmpa_prop { local } \l_stex_symdecl_local_bool
  \prop_put:Nno \l_tmpa_prop { type } \l_stex_symdecl_type_tl

  \exp_args:No \stex_add_constant_to_current_module:n {
    \l_stex_symdecl_name_str
  }

  % arity/args
  \int_zero:N \l_tmpb_int

  \bool_set_true:N \l_tmpa_bool
  \str_map_inline:Nn \l_stex_symdecl_args_str {
    \token_case_meaning:NnF ##1 {
      0 {} 1 {} 2 {} 3 {} 4 {} 5 {} 6 {} 7 {} 8 {} 9 {}
      {\tl_to_str:n i} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n b} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n a} {
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
    }{
      \msg_set:nnn{stex}{error/wrongargs}{
        args~value~in~symbol~declaration~for~
        \prop_item:Nn \l_stex_current_module_prop {ns} ?
        \prop_item:Nn \l_stex_current_module_prop {name} ?
        \l_stex_symdecl_name_str ~
        needs~to~be~
        i,~a~or~b,~but~##1~given
      }
      \msg_error:nn{stex}{error/wrongargs}
    }
  }
  \bool_if:NTF \l_tmpa_bool {
    % possibly numeric
    \str_if_empty:NTF \l_stex_symdecl_args_str {
      \prop_put:Nnn \l_tmpa_prop { args } {}
      \prop_put:Nnn \l_tmpa_prop { arity } { 0 }
    }{
      \int_set:Nn \l_tmpa_int { \l_stex_symdecl_args_str }
      \prop_put:Nnx \l_tmpa_prop { arity } { \int_use:N \l_tmpa_int }
      \str_clear:N \l_tmpa_str
      \int_step_inline:nn \l_tmpa_int {
        \str_put_right:Nn \l_tmpa_str i
      }
      \prop_put:Nnx \l_tmpa_prop { args } { \l_tmpa_str }
    }
  } {
    \prop_put:Nnx \l_tmpa_prop { args } { \l_stex_symdecl_args_str }
    \prop_put:Nnx \l_tmpa_prop { arity }
      { \str_count:N \l_stex_symdecl_args_str }
  }
  \prop_put:Nnx \l_tmpa_prop { assocs } { \int_use:N \l_tmpb_int }

  % semantic macro

  \tl_set:cx { #1 } { \stex_invoke_symbol:n {
    \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
  } }

  \bool_if:NF \l_stex_symdecl_local_bool {
    \exp_args:Nx \stex_add_to_current_module:n {
      \tl_set:cx { #1 } { \stex_invoke_symbol:n {
        \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
      } }
    }
  }

  \stex_debug:n{New~symbol:~
    \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }^^J
    Type:~\exp_not:o { \l_stex_symdecl_type_tl }^^J
    Args:~\prop_item:Nn \l_tmpa_prop { args }
  }

  \prop_gset_eq:cN {
    g_stex_symdecl_
    \prop_item:Nn \l_tmpa_prop { module } ?
    \prop_item:Nn \l_tmpa_prop { name }
    _prop
  } \l_tmpa_prop

  \stex_if_smsmode:TF {
    \bool_if:NF \l_stex_symdecl_local_bool {
      \exp_args:Nx \stex_addtosms:n {
        \prop_gset_from_keyval:cn {
          g_stex_symdecl_
          \prop_item:Nn \l_tmpa_prop { module } ?
          \prop_item:Nn \l_tmpa_prop { name }
          _prop
        } {
          name      = \prop_item:Nn \l_tmpa_prop { name }
          module    = \prop_item:Nn \l_tmpa_prop { module }
          notations = \prop_item:Nn \l_tmpa_prop { notations }
          local     = \prop_item:Nn \l_tmpa_prop { local }
          type      = \prop_item:Nn \l_tmpa_prop { type }
          args      = \prop_item:Nn \l_tmpa_prop { args }
          arity     = \prop_item:Nn \l_tmpa_prop { arity }
          assocs    = \prop_item:Nn \l_tmpa_prop { assocs }
        }
      }
    }
    \stex_smsmode_set_codes:
  }{
    \stex_annotate_invisible:nnn {symdecl} {
      \prop_item:Nn \l_tmpa_prop { module } ?
      \prop_item:Nn \l_tmpa_prop { name }
    } {
      \stex_annotate_invisible{type}{}{$\l_stex_symdecl_type_tl$}
      \stex_annotate_invisible{args}{}{
        \prop_item:Nn \l_tmpa_prop { args }
      }
      \stex_annotate_invisible{macroname}{}{#1}
      \str_if_empty:NF \l_stex_symdecl_definiens_tl {
        \stex_annotate_invisible{definiens}{}
          {$\l_stex_symdecl_definiens_tl$}
      }
    }
  }
}
\str_new:N \l_stex_get_symbol_uri_str

\cs_new_protected:Nn \stex_get_symbol:n {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    % argument is a command
    % TODO
  }{
    % argument is a string
    % is it a command name?
    \tl_set:Nx \l_tmpa_tl { \use:c { #1 } }

    \exp_args:Nx \cs_if_eq:NNTF { \tl_head:N \l_tmpa_tl }
      \stex_invoke_symbol:n {
      \exp_args:NNx \tl_set:Nn \l_tmpa_tl
        { \tl_tail:N \l_tmpa_tl }
      \tl_if_single:NTF \l_tmpa_tl {
        \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
          \exp_after:wN \str_set:Nn \exp_after:wN
            \l_stex_get_symbol_uri_str \l_tmpa_tl
        }{
          % TODO
          % tail is not a single group
        }
      }{
        % TODO
        % tail is not a single group
      }
    }{
      % TODO
      % head is not \stex_invoke_symbol:n
    }
  }
}
\keys_define:nn { stex / notation } {
  lang    .tl_set_x:N = \l__stex_notation_lang_str ,
  variant .tl_set_x:N = \l__stex_notation_variant_str ,
  prec    .tl_set_x:N = \l__stex_notation_prec_str ,
  unknown .code:n     = \str_set:Nx
      \l__stex_notation_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \__stex_notation_args:n {
  \str_clear:N \l__stex_notation_lang_str
  \str_clear:N \l__stex_notation_variant_str
  \str_clear:N \l__stex_notation_prec_str

  \keys_set:nn { stex / notation } { #1 }

  \exp_args:NNo \str_set:Nn \l__stex_notation_lang_str
    \l__stex_notation_lang_str
  \exp_args:NNo \str_set:Nn \l__stex_notation_variant_str
    \l__stex_notation_variant_str
  \exp_args:NNo \str_set:Nn \l__stex_notation_prec_str
    \l__stex_notation_prec_str
}
\NewDocumentCommand \notation { O{} m } {
  \__stex_notation_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_get_symbol:n { #2 }
  \stex_notation_do:n { \l_stex_get_symbol_uri_str }
}
\cs_new_protected:Nn \stex_notation_do:n {
  \prop_gset_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop
  }

  % precedences
  % \notation[prec=500;50x49x51]{foo}{#1 bla #2 bla #3}{arg1}{arg3}

}
\cs_new_protected:Nn \stex_invoke_symbol:n {
  % TODO
}
\endinput
%%
%% End of file `stex.sty'.
