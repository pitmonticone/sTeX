% \iffalse meta-comment
% An Infrastructure for Semantic Macros and Module Scoping
% Copyright (c) 2019 Michael Kohlhase, all rights reserved
%                this file is released under the
%                LaTeX Project Public License (LPPL)
% 
% The original of this file is in the public repository at 
% http://github.com/sLaTeX/sTeX/
%
% TODO update copyright  
%
%<*driver>
\providecommand\bibfolder{../../lib/bib}
\input{../../doc/docheader}

\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{ \sTeX-Metatheory
% 	\thanks{Version {\fileversion} (last revised {\filedate})} 
% }
%
% \author{Michael Kohlhase, Dennis Müller\\
% 	FAU Erlangen-Nürnberg\\
% 	\url{http://kwarc.info/}
% }
%
% \maketitle
%
%\ifinfulldoc\else
% This is the documentation for the \pkg{stex-metatheory} package.
% For a more high-level introduction, 
%  see \href{\basedocurl/manual.pdf}{the \sTeX Manual} or the
% \href{\basedocurl/stex.pdf}{full \sTeX documentation}.
%
% \input{../../doc/packages/metatheory}
% \fi
%
% \begin{documentation}\label{pkg:metatheory:doc}
%
% The default meta theory for an \sTeX module. Contains
% symbols so ubiquitous, that it is virtually impossible
% to describe any flexiformal content without them, or
% that are required to annotate even the most primitive symbols
% with meaningful (foundation-independent) ``type''-annotations,
% or required for basic structuring principles (theorems, definitions).
%
% Foundations should ideally instantiate these symbols
% with their formal counterparts, e.g. |isa| corresponds
% to a typing operation in typed setting, or the $\in$-operator
% in set-theoretic contexts; |bind| corresponds to a universal
% quantifier in ($n$th-order) logic, or a $\Pi$ in dependent type
% theories.
%
% \section{Symbols}\label{pkg:metatheory:symbols}
%
% \end{documentation}
%
% \begin{implementation}\label{pkg:metatheory:impl}
%
% \section{\sTeX-Metatheory Implementation}
%
%    \begin{macrocode}
%<*package>
%<@@=stex_modules>

%%%%%%%%%%%%%   metatheory.dtx   %%%%%%%%%%%%%

\str_const:Nn \c_stex_metatheory_ns_str {http://mathhub.info/sTeX}
\begingroup
\stex_module_setup:nn{
  ns=\c_stex_metatheory_ns_str,
  meta=NONE
}{Metatheory}
\stex_reactivate_macro:N \symdecl
\stex_reactivate_macro:N \notation
\stex_reactivate_macro:N \symdef
\ExplSyntaxOff
\csname stex_suppress_html:n\endcsname{
  % is-a (a:A, a \in A, a is an A, etc.)
  \symdecl[args=ai]{isa}
  \notation[typed]{isa}{#1 \comp{:} #2}{##1 \comp, ##2}
  \notation[in]{isa}{#1 \comp\in #2}{##1 \comp, ##2}
  \notation[pred]{isa}{#2\comp(#1 \comp)}{##1 \comp, ##2}

  % bind (\forall, \Pi, \lambda etc.)
  \symdecl[args=Bi]{bind}
  \notation[forall]{bind}{\comp\forall #1.\;#2}{##1 \comp, ##2}
  \notation[Pi]{bind}{\comp\prod_{#1}#2}{##1 \comp, ##2}
  \notation[depfun]{bind}{\comp( #1 \comp{)\;\to\;} #2}{##1 \comp, ##2}

  % dummy variable
  \symdecl{dummyvar}
  \notation[underscore]{dummyvar}{\comp\_}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dash]{dummyvar}{\comp{{\rm --}}}

  %fromto (function space, Hom-set, implication etc.)
  \symdecl[args=ai]{fromto}
  \notation[xarrow]{fromto}{#1 \comp\to #2}{##1 \comp\times ##2}
  \notation[arrow]{fromto}{#1 \comp\to #2}{##1 \comp\to ##2}

  % mapto (lambda etc.)
  %\symdecl[args=Bi]{mapto}
  %\notation[mapsto]{mapto}{#1 \comp\mapsto #2}{#1 \comp, #2}
  %\notation[lambda]{mapto}{\comp\lambda #1 \comp.\; #2}{#1 \comp, #2}
  %\notation[lambdau]{mapto}{\comp\lambda_{#1} \comp.\; #2}{#1 \comp, #2}

  % function/operator application
  \symdecl[args=ia]{apply}
  \notation[prec=0;0x\infprec,parens]{apply}{#1 \comp( #2 \comp)}{##1 \comp, ##2}
  \notation[prec=0;0x\infprec,lambda]{apply}{#1 \; #2 }{##1 \; ##2}

  % ``type'' of all collections (sets,classes,types,kinds)
  \symdecl{collection}
  \notation[U]{collection}{\comp{\mathcal{U}}}
  \notation[set]{collection}{\comp{\textsf{Set}}}

  % sequences
  \symdecl[args=1]{seqtype}
  \notation[kleene]{seqtype}{#1^{\comp\ast}}

  \symdef[args=2,li,prec=nobrackets]{sequence-index}{{#1}_{#2}}
  \notation[ui,prec=nobrackets]{sequence-index}{{#1}^{#2}}

  \symdef[args=a,prec=nobrackets]{aseqdots}{#1\comp{,\ellipses}}{##1\comp,##2}
  \symdef[args=ai,prec=nobrackets]{aseqfromto}{#1\comp{,\ellipses,}#2}{##1\comp,##2}
  \symdef[args=aii,prec=nobrackets]{aseqfromtovia}{#1\comp{,\ellipses,}#2\comp{,\ellipses,}#3}{##1\comp,##2}

  % letin (``let'', local definitions, variable substitution)
  \symdecl[args=bii]{letin}
  \notation[let]{letin}{\comp{{\rm let}}\;#1\comp{=}#2\;\comp{{\rm in}}\;#3}
  \notation[subst]{letin}{#3 \comp[ #1 \comp/ #2 \comp]}
  \notation[frac]{letin}{#3 \comp[ \frac{#2}{#1} \comp]}

  % structures
  \symdecl*[args=1]{module-type}
  \notation{module-type}{\mathtt{MOD} #1}
  \symdecl[name=mathematical-structure,args=a]{mathstruct} % TODO
  \notation[angle,prec=nobrackets]{mathstruct}{\comp\langle #1 \comp\rangle}{##1 \comp, ##2}

}
  \ExplSyntaxOn
  \stex_add_to_current_module:n{
    \let\nappa\apply
    \def\nappli#1#2#3#4{\apply{#1}{\naseqli{#2}{#3}{#4}}}
    \def\nappui#1#2#3#4{\apply{#1}{\nasequi{#2}{#3}{#4}}}
    \def\livar{\csname sequence-index\endcsname[li]}
    \def\uivar{\csname sequence-index\endcsname[ui]}
    \def\naseqli#1#2#3{\aseqfromto{\livar{#1}{#2}}{\livar{#1}{#3}}}
    \def\nasequi#1#2#3{\aseqfromto{\uivar{#1}{#2}}{\uivar{#1}{#3}}}
    \def\nappe#1#2#3{\apply{#1}{\aseqfromto{#2}{#3}}}
  }
\_@@_end_module:
\endgroup
%    \end{macrocode}
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex

% \endinput
% Local Variables:
% mode: doctex
% TeX-master: t
% End:
