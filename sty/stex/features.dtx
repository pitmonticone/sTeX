% \iffalse meta-comment
% An Infrastructure for Semantic Macros and Module Scoping
% Copyright (c) 2019 Michael Kohlhase, all rights reserved
%                this file is released under the
%                LaTeX Project Public License (LPPL)
% 
% The original of this file is in the public repository at 
% http://github.com/sLaTeX/sTeX/
%
% TODO update copyright  
%
%<*driver>
\providecommand\bibfolder{../../lib/bib}
\input{../../doc/docheader}

\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{ \sTeX-Structural Features
% 	\thanks{Version {\fileversion} (last revised {\filedate})} 
% }
%
% \author{Michael Kohlhase, Dennis Müller\\
% 	FAU Erlangen-Nürnberg\\
% 	\url{http://kwarc.info/}
% }
%
% \maketitle
%
%\ifinfulldoc\else\input{../../doc/packages/features}\fi
%
% \begin{documentation}\label{pkg:features:doc}
%
% Code related to structural features
%
% \section{Macros and Environments}\label{pkg:features:doc:macros}
%
% \subsection{Structures}
%
% \begin{environment}{mathstructure}
%   TODO
% \end{environment}
%
%^^A\stextest{
%^^A \begin{module}{StructureTest1}
%^^A   \begin{mathstructure}[name=Magma]{magma}
%^^A     \symdef{universe}{\comp M}
%^^A     \symdef[args=2]{op}{#1 \comp\circ #2}
%^^A       $\isa{\op ab}\universe$
%^^A   \end{mathstructure}
%^^A
%^^A     \ExplSyntaxOn
%^^A     \prop_get:NnN \g_stex_last_feature_prop {fields} \l_tmpa_seq
%^^A     \seq_use:Nn \l_tmpa_seq {,}
%^^A     \ExplSyntaxOff
%^^A
%^^A     \present\magma
%^^A
%^^A     \instantiate{magma}[
%^^A       universe ! {{\comp U}},
%^^A       op ! {{#1 \comp+ #2 }}
%^^A     ]{mM}
%^^A     \notation[op = U]{mM/universe}{\comp U}
%^^A     \notation[op = +]{mM/op}{#1 \comp+ #2}
%^^A
%^^A     Test: $\mM{op}ab$
%^^A
%^^A     Test2: $\mM{}$
%^^A \end{module}
%^^A}
%
%
% \end{documentation}
%
% \begin{implementation}\label{pkg:features:impl}
%
% \section{\sTeX-Structural Features Implementation}
%
%    \begin{macrocode}
%<*package>

%%%%%%%%%%%%%   features.dtx   %%%%%%%%%%%%%

%<@@=stex_features>
%    \end{macrocode}
%
% Warnings and error messages
%
%    \begin{macrocode}

%    \end{macrocode}
%
% \subsection{Imports with modification}
%
%
%    \begin{macrocode}
\seq_new:N \l_stex_implicit_morphisms_seq
\NewDocumentCommand \implicitmorphism { O{} m m}{
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_debug:nn{implicits}{
    Implicit~morphism:~
    \l_stex_module_ns_str ? \l_@@_name_str
  }
  \exp_args:NNx \seq_if_in:NnT \l_stex_all_modules_seq {
    \l_stex_module_ns_str ? \l_@@_name_str
  }{
    \msg_error:nnn{stex}{error/conflictingmodules}{
      \l_stex_module_ns_str ? \l_@@_name_str
    }
  }

  % TODO
  


  \seq_put_right:Nx \l_stex_implicit_morphisms_seq {
    \l_stex_module_ns_str ? \l_@@_name_str
  }
}

%    \end{macrocode}
%
%
% \subsection{The feature environment}
%
% \begin{environment}{structural@feature}
%    \begin{macrocode}

\NewDocumentEnvironment{structural@feature}{ m m m }{
  \stex_if_in_module:F {
    \msg_set:nnn{stex}{error/nomodule}{
      Structural~Feature~has~to~occur~in~a~module:\\
      Feature~#2~of~type~#1\\
      In~File:~\stex_path_to_string:N \g_stex_currentfile_seq
    }
    \msg_error:nn{stex}{error/nomodule}
  }

  \str_set:Nx \l_stex_module_name_str {
    \prop_item:Nn \l_stex_current_module_prop
      { name } / #2 - feature
  }
  
  \str_set:Nx \l_stex_module_ns_str {
    \prop_item:Nn \l_stex_current_module_prop
      { ns }
  }

  
  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
    origname  = #2,
    name      = \l_stex_module_name_str ,
    ns        = \l_stex_module_ns_str ,
    imports   = \exp_not:o { \l_tmpa_seq } ,
    constants = \exp_not:o { \l_tmpa_seq } ,
    content   = \exp_not:o { \l_tmpa_tl }  ,
    file      = \exp_not:o { \g_stex_currentfile_seq } ,
    lang      = \l_stex_module_lang_str ,
    sig       = \l_tmpa_str ,
    meta      = \l_tmpa_str ,
    feature   = #1 ,
  }

  \stex_if_smsmode:TF {
    \stex_smsmode_set_codes:
  } {
    \begin{stex_annotate_env}{ feature:#1 }{}
      \stex_annotate_invisible:nnn{header}{}{ #3 }
  }
}{  
  \str_set:Nx \l_tmpa_str {
    c_stex_feature_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \prop_gset_eq:NN \g_stex_last_feature_prop \l_stex_current_module_prop
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_add_to_sms:n {
      \prop_gset_from_keyval:cn {
        c_stex_feature_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        origname  = #2,
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        imports   = \prop_item:cn { \l_tmpa_str } { imports } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta } ,
        feature   = \prop_item:cn { \l_tmpa_str } { feature }
      }
    }
  } {
      \end{stex_annotate_env}
  }
}

%    \end{macrocode}
% \end{environment}
%
%
% \subsection{Features}
%
% \begin{environment}{structure}
%    \begin{macrocode}

\prop_new:N \l_stex_all_structures_prop

\keys_define:nn { stex / features / structure } {
  name         .str_set_x:N  = \l_@@_structure_name_str ,
}

\cs_new_protected:Nn \_@@_structure_args:n {
  \str_clear:N \l_@@_structure_name_str
  \keys_set:nn { stex / features / structure } { #1 }
}

%\stex_new_feature:nnnn { structure } { O{} m } {
%  \_@@_structure_args:n { ##1 }
%  \str_if_empty:NT \l_@@_structure_name_str {
%    \str_set:Nx \l_@@_structure_name_str { ##2 }
%  }
%} {
%
%}

\NewDocumentEnvironment{mathstructure}{ O{} m }{
  \_@@_structure_args:n { #1 }
  \str_if_empty:NT \l_@@_structure_name_str {
    \str_set:Nx \l_@@_structure_name_str { #2 }
  }
  \exp_args:Nnnx
  \begin{structural@feature}{ structure }
    { \l_@@_structure_name_str }{}
    \seq_clear:N \l_tmpa_seq
    \prop_put:Nno \l_stex_current_module_prop { fields } \l_tmpa_seq

}{
    \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
    \prop_get:NnN \l_stex_current_module_prop { fields } \l_tmpb_seq
    \str_set:Nx \l_tmpa_str {
      \prop_item:Nn \l_stex_current_module_prop { ns } ?
      \prop_item:Nn \l_stex_current_module_prop { name }
    }
    \seq_map_inline:Nn \l_tmpa_seq {
      \exp_args:NNx \seq_put_right:Nn \l_tmpb_seq { \l_tmpa_str ? ##1 }
    }
    \prop_put:Nno \l_stex_current_module_prop { fields } { \l_tmpb_seq }
    \exp_args:Nnx
    \AddToHookNext { env / mathstructure / after }{
      \symdecl[type = \exp_not:N\collection,def={\STEXsymbol{module-type}{
        \_stex_term_math_oms:nnnn { \l_tmpa_str }{}{0}{}
      }}, name = \prop_item:Nn \l_stex_current_module_prop { origname }]{ #2 }
      \STEXexport {
        \prop_put:Nno \exp_not:N \l_stex_all_structures_prop 
          {\prop_item:Nn \l_stex_current_module_prop { origname }}
          {\l_tmpa_str}
          \prop_put:Nno \exp_not:N \l_stex_all_structures_prop 
            {#2}{\l_tmpa_str}
%        \seq_put_right:Nn \exp_not:N \l_stex_all_structures_seq {
%          \prop_item:Nn \l_stex_current_module_prop { origname },
%          \l_tmpa_str
%        }
%        \seq_put_right:Nn \exp_not:N \l_stex_all_structures_seq {
%          #2,\l_tmpa_str
%        }
%        \tl_set:cx { #2 } { 
%          \stex_invoke_structure:n { \l_tmpa_str }
      }
    }
    
  \end{structural@feature}
  % \g_stex_last_feature_prop
}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}{\instantiate}
%    \begin{macrocode}
\seq_new:N \l_@@_structure_field_seq
\str_new:N \l_@@_structure_field_str
\str_new:N \l_@@_structure_def_tl
\prop_new:N \l_@@_structure_prop
\NewDocumentCommand \instantiate { m O{} m }{
  \stex_smsmode_set_codes:
  \prop_get:NnN \l_stex_all_structures_prop {#1} \l_tmpa_str
  \prop_set_eq:Nc \l_@@_structure_prop {
    c_stex_feature_\l_tmpa_str _prop
  }
  \seq_set_from_clist:Nn \l_@@_structure_field_seq { #2 }
  \seq_map_inline:Nn \l_@@_structure_field_seq {
    \seq_set_split:Nnn \l_tmpa_seq{=}{ ##1 }
    \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
      \seq_get_left:NN \l_tmpa_seq \l_tmpa_tl
      \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq
        {!} \l_tmpa_tl 
      \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
        \str_set:Nx \l_@@_structure_field_str {\seq_item:Nn \l_tmpb_seq 1}
        \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
        \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
      }{
        \str_set:Nx \l_@@_structure_field_str \l_tmpa_tl
        \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
        \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq{!}
          \l_tmpa_tl 
        \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
          \seq_get_left:NN \l_tmpb_seq \l_tmpa_tl
          \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
        }{
          \tl_clear:N \l_tmpb_tl
        }
      }
    }{
      \seq_set_split:Nnn \l_tmpa_seq{!}{ ##1 }
      \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
        \str_set:Nx \l_@@_structure_field_str {\seq_item:Nn \l_tmpa_seq 1}
        \seq_get_right:NN \l_tmpa_seq \l_tmpb_tl
        \tl_clear:N \l_tmpa_tl
      }{
        % TODO throw error
      }
    }
    % \l_tmpa_str: name
    % \l_tmpa_tl: definiens
    % \l_tmpb_tl: notation
    \tl_if_empty:NT \l_@@_structure_field_str { 
      % TODO throw error
    }
    \str_clear:N \l_tmpb_str
    
    \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ####1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpb_str
      \str_if_eq:NNT \l_@@_structure_field_str \l_tmpb_str {
        \seq_map_break:n {
          \str_set:Nn \l_tmpb_str { ####1 }
        }
      }
    }
    \prop_get:cnN { l_stex_symdecl_ \l_tmpb_str _prop } {args}
      \l_tmpb_str

    \tl_if_empty:NTF \l_tmpb_tl {
      \tl_if_empty:NF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdecl[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l_@@_structure_field_str}
        }
      }
    }{
      \tl_if_empty:NTF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str]{#3/\l_@@_structure_field_str}\exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }

      }{
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l_@@_structure_field_str}
          \exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }
      }
    }
%    \par \prop_item:Nn \l_stex_current_module_prop {ns} ?
%    \prop_item:Nn \l_stex_current_module_prop {name} ?
%    #3/\l_@@_structure_field_str
%    \par
%    \expandafter\present\csname
%      l_stex_symdecl_
%      \prop_item:Nn \l_stex_current_module_prop {ns} ?
%      \prop_item:Nn \l_stex_current_module_prop {name} ?
%      #3/\l_@@_structure_field_str
%      _prop
%    \endcsname
  }

  \tl_clear:N \l_@@_structure_def_tl

  \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
    \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
    \exp_args:Nx \use:n {
      \tl_put_right:Nn \exp_not:N \l_@@_structure_def_tl {

      }
    }

    \prop_if_exist:cF {
      l_stex_symdecl_
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ?
      #3/\l_tmpa_str
      _prop
    }{
      \prop_get:cnN { l_stex_symdecl_ ##1 _prop } {args}
        \l_tmpb_str
      \exp_args:Nx \use:n {
        \symdecl[args=\l_tmpb_str]{#3/\l_tmpa_str}
      }
    }
  }

  \symdecl*[type={\STEXsymbol{module-type}{
    \_stex_term_math_oms:nnnn {
      \prop_item:Nn \l_@@_structure_prop {ns} ?
      \prop_item:Nn \l_@@_structure_prop {name}
      }{}{0}{}
  }}]{#3}
  
  % TODO: -> sms file

  \tl_set:cx{ #3 }{
    \stex_invoke_structure:nnn {
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ? #3
    } {
      \prop_item:Nn \l_@@_structure_prop {ns} ?
      \prop_item:Nn \l_@@_structure_prop {name}
    }
  }

}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\stex_invoke_structure:nnn}
%    \begin{macrocode}
% #1: URI of the instance
% #2: URI of the instantiated module
\cs_new_protected:Nn \stex_invoke_structure:nnn {
  \tl_if_empty:nTF{ #3 }{  
    \prop_set_eq:Nc \l_@@_structure_prop {
      c_stex_feature_ #2 _prop
    }
    \tl_clear:N \l_tmpa_tl
    \prop_get:NnN \l_@@_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
      \cs_if_exist:cT {
        stex_notation_ #1/\l_tmpa_str \c_hash_str\c_hash_str _cs
      }{
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_put_right:Nn \l_tmpa_tl {,}
        }
        \tl_put_right:Nx \l_tmpa_tl {
          \stex_invoke_symbol:n {#1/\l_tmpa_str}!
        }
      }
    }
    \exp_args:No \mathstruct \l_tmpa_tl
  }{
    \stex_invoke_symbol:n{#1/#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex
