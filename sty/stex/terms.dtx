% \iffalse meta-comment
% An Infrastructure for Semantic Macros and Module Scoping
% Copyright (c) 2019 Michael Kohlhase, all rights reserved
%                this file is released under the
%                LaTeX Project Public License (LPPL)
% 
% The original of this file is in the public repository at 
% http://github.com/sLaTeX/sTeX/
%
% TODO update copyright  
%
%<*driver>
\providecommand\bibfolder{../../lib/bib}
\input{../../doc/docheader}

\begin{document}
  \DocInput{\jobname.dtx}
\end{document}
%</driver>
% \fi
%
% \title{ \sTeX-Terms
% 	\thanks{Version {\fileversion} (last revised {\filedate})} 
% }
%
% \author{Michael Kohlhase, Dennis Müller\\
% 	FAU Erlangen-Nürnberg\\
% 	\url{http://kwarc.info/}
% }
%
% \maketitle
%
% \begin{documentation}\label{pkg:terms:doc}
%
% Code related to symbolic expressions, typesetting notations,
% notation components, etc.
%
% \section{Macros and Environments}\label{pkg:terms:doc:macros}
%
% \begin{function}{\STEXsymbol}
%   Uses \cs{stex_get_symbol:n} to find the symbol denoted by
%   the first argument and passes the result on to
%   \cs{stex_invoke_symbol:n}
% \end{function}
%
% \begin{function}{\symref}
%   \begin{syntax} \cs{symref}\Arg{symbol}\Arg{text} \end{syntax}
%   shortcut for \cs{STEXsymbol}\Arg{symbol}|![|\meta{text}|]|
% \end{function}
%
% \begin{function}{\stex_invoke_symbol:n}
%   Executes a semantic macro. Outside of math mode or if followed by |*|,
%   it continues to \cs{stex_term_custom:nn}. In math mode,
%   it uses the default or optionally provided notation of
%   the associated symbol.
%
%   If followed by |!|, it will invoke the symbol \emph{itself}
%   rather than its application (and continue to
%   \cs{stex_term_custom:nn}), i.e. it allows to refer to
%   |\plus![addition]| as an operation, rather than
%   |\plus[addition of]{some}{terms}|.
% \end{function}
%
% \begin{function}{\_stex_term_math_oms:nnnn,\_stex_term_math_oma:nnnn,\_stex_term_math_omb:nnnn}
%   \begin{syntax} \meta{URI}\meta{fragment}\meta{precedence}\meta{body} \end{syntax}
%
% Annotates \meta{body} as an \omdoc-term (|OMID|, |OMA| or |OMBIND|, respectively) 
% with head symbol \meta{URI}, generated
% by the specific notation \meta{fragment} with (upwards) operator precedence
% \meta{precedence}. Inserts parentheses according to
% the current downwards precedence and operator precedence.
% \end{function}
%
% \begin{function}{\_stex_term_math_arg:nnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th argument of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec}.
% \end{function}
%
% \begin{function}{\_stex_term_math_assoc_arg:nnnn}
%   \begin{syntax} \cs{stex_term_arg:nnn}\meta{int}\meta{prec}\meta{notation}\meta{body} \end{syntax}
% Annotates \meta{body} as the \meta{int}th (associative) \emph{sequence} argument
% (as comma-separated list of terms) of the current |OMA| or |OMBIND|,
% with (downwards) argument precedence \meta{prec} and associative
% notation \meta{notation}.
% 
% \end{function}
%
% \begin{variable}{\infprec, \neginfprec}
%   Maximal and minimal notation precedences.
% \end{variable}
%
% \begin{function}{\dobrackets}
%   \begin{syntax} \cs{dobrackets} \Arg{body} \end{syntax}
%   Puts \meta{body} in parentheses; scaled if in display mode
%   unscaled otherwise. Uses the current \sTeX brackets (by default |(| and |)|),
%   which can be changed temporarily using \cs{withbrackets}.
% \end{function}
%
% \begin{function}{\withbrackets}
%   \begin{syntax} \cs{withbrackets} \meta{left} \meta{right} \Arg{body} \end{syntax}
%   Temporarily (i.e. within \meta{body}) sets the brackets used by \sTeX for automated
%   bracketing (by default |(| and |)|) to \meta{left} and \meta{right}.
%
%   Note that \meta{left} and \meta{right} need to be allowed
%   after \cs{left} and \cs{right} in displaymode.
% \end{function}
%
%\stextest{
%  \begin{module}{MathTest1}
%    \importmodule{Foo}
%    \notation[foo, prec=500;20x20x20]{bar}{\comp\langle {#1 ^ {#2}}_{#3} \comp\rangle }
%    $\bar abc$ and $\bar[foo] abc$.
%
%  \end{module}
%}
%
%\stextest{
%  \begin{module}{MathTest2}
%    \importmodule{Foo}
%     \notation[foo, prec=500;20x20x20]{foobar}{\comp\langle #1 \comp\mid [ #2 ]^{#3} \comp\rangle }{ {#1}_{\comp :#2} }
%     $\foobar a{b,c,d,e,f}g$ and $\foobar[foo] a{b,c}g$ and $\foobar abc$
%
%     \symdecl[args=a]{plus}
%     \symdecl[args=a]{mult}
%     \notation[prec=50]{plus}{#1}{#1 \comp+ #2}
%     \notation[prec=100]{mult}{#1}{#1 \comp\cdot #2}
%     $\plus{a,\mult{b,c}}$ and $\mult{a,\plus{\frac ab,\frac ac}}$
%     \[\plus{a,\mult{b,c}}\text{ and }\mult{a,\plus{\frac ab,\frac ac}}\]
%     $\displaystyle \plus{a,\mult{b,c}}$ and 
%     \withbrackets[]{$\displaystyle
%       \mult{a,\plus{\frac ab,\frac ac}}$}
%  \end{module}
%}
%
% \begin{function}{\stex_term_custom:nn}
%   \begin{syntax} \cs{stex_term_custom:nn}\Arg{URI}\Arg{args}\end{syntax}
% Implements custom one-time notation.
% Invoked by \cs{stex_invoke_symbol:n} in text mode, or if
% followed by |*| in math mode, or whenever followed by |!|.
% \end{function}
%
%\stextest{
%  \begin{module}{TextTest}
%    \importmodule{Foo}
%
%    \bar[some ]a[ and some ]b[ and also some ]c[ here].
%
%   $\bar*[\text{some }]a[\text{ and some }]b[\text{ and also some }]c[\text{ here}]$.
%
%   $\bar![\mathtt{bar}]$
%
%   \bar*{a}*{b}[or just some ]c
%
%   \bar![bar]
%
%   \bar[or first ]*[2]{b}[, then ]*[3]{c}[, and finally ]a
%
%  \end{module}
%}
%
% \begin{function}{\stex_highlight_term:nn}
%   \begin{syntax} \cs{stex_highlight_term:nn}\Arg{URI}\Arg{args}\end{syntax}
% Establishes a context for \cs{comp}. Stores the URI in a variable
% so that \cs{comp} knows which symbol governs the current notation.
% \end{function}
%
% \begin{function}{\comp, \compemph,\compemph@uri, \defemph, \defemph@uri, \symrefemph,\symrefemph@uri}
%   \begin{syntax} \cs{comp}\Arg{args}\end{syntax}
% Marks \meta{args} as a notation component of the current symbol for
% highlighting, linking, etc.
%
% The precise behavior is governed by \cs{@comp}, which takes as
% additional argument the URI of the current symbol. By default,
% \cs{@comp} adds the URI as a PDF tooltip and colors the highlighted part
% in blue.
%
% \cs{@defemph} behaves like \cs{@comp}, and can be similarly redefined,
% but marks an expression as \emph{definiendum} (used by \cs{definiendum})
% \end{function}
%
% \begin{function}{\STEXinvisible}
% Exports its argument as \omdoc (invisible), but does
% not produce PDF output. Useful e.g. for semantic macros
% that take arguments that are not part of the symbolic
% notation.
% \end{function}
%
% \begin{function}{\ellipses}
%   TODO
% \end{function}
%
% \end{documentation}
%
% \begin{implementation}\label{pkg:terms:impl}
%
% \section{\sTeX-Terms Implementation}
%
%    \begin{macrocode}
%<*package>

%%%%%%%%%%%%%   terms.dtx   %%%%%%%%%%%%%

%<@@=stex_terms>
%    \end{macrocode}
%
% Warnings and error messages
%
%    \begin{macrocode}
\msg_new:nnn{stex}{error/nonotation}{
  Symbol~#1~invoked,~but~has~no~notation#2!
}
\msg_new:nnn{stex}{error/notationarg}{
  Error~in~parsing~notation~#1
}

%    \end{macrocode}
% \subsection{Symbol Invokations}
%
% Arguments:
%
%    \begin{macrocode}
\keys_define:nn { stex / terms } {
  lang    .tl_set_x:N = \l_@@_lang_str ,
  variant .tl_set_x:N = \l_@@_variant_str ,
  unknown .code:n     = \str_set:Nx 
      \l_@@_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_@@_args:n {
  \str_clear:N \l_@@_lang_str
  \str_clear:N \l_@@_variant_str
  \str_clear:N \l_@@_prec_str
  \tl_clear:N \l_@@_op_tl
  
  \keys_set:nn { stex / terms } { #1 }
}
%    \end{macrocode}
%
% \begin{macro}{\stex_invoke_symbol:n}
%
%  Invokes a semantic macro
%
%    \begin{macrocode}
\cs_new_protected:Nn \stex_invoke_symbol:n {
  \if_mode_math:
    \exp_after:wN \_@@_invoke_math:n
  \else:
    \exp_after:wN \_@@_invoke_text:n
  \fi: { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_math:n {
  \peek_charcode_remove:NTF ! {
    \peek_charcode:NTF [ {
      \_@@_invoke_op:nw { #1 }
    }{
      \_@@_invoke_op:nw { #1 } []
    }
  }{
    \peek_charcode_remove:NTF * {
      \_@@_invoke_text:n { #1 }
    }{
      \peek_charcode:NTF [ {
        \_@@_invoke_math:nw { #1 }
      }{
        \_@@_invoke_math:nw { #1 } []
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_@@_invoke_op:nw}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_invoke_op:nw  #1 [#2] {
  \_@@_args:n { #2 }
  \cs_if_exist:cTF {
    stex_op_notation_ #1 \c_hash_str
    \l_@@_variant_str \c_hash_str \l_@@_lang_str _cs
  }{
    \csname stex_op_notation_ #1 \c_hash_str
      \l_@@_variant_str \c_hash_str \l_@@_lang_str _cs
    \endcsname
  }{
    % TODO throw error
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_math:nw}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_invoke_math:nw  #1 [#2] {
  \_@@_args:n { #2 }
  \prop_set_eq:Nc \l_tmpa_prop {
    g_stex_symdecl_ #1 _prop 
  }
  \prop_get:NnN \l_tmpa_prop { notations } \l_tmpa_seq
  \seq_if_empty:NTF \l_tmpa_seq {
    \msg_error:nnnn{stex}{error/nonotation}{#1}{s}
  } {
    \seq_if_in:NxTF \l_tmpa_seq
      { \l_@@_variant_str \c_hash_str \l_@@_lang_str }{
      \use:c{
        stex_notation_ #1 \c_hash_str
        \l_@@_variant_str \c_hash_str \l_@@_lang_str
        _cs
      }
    }{
      \str_if_empty:NTF \l_@@_variant_str {
        \str_if_empty:NTF \l_@@_lang_str {
          \seq_get_left:NN \l_tmpa_seq \l_tmpa_str
          \use:c{
            stex_notation_ #1 \c_hash_str \l_tmpa_str
            _cs
          }
        }{
          \msg_error:nn{stex}{error/nonotation}{#1}{
            ~\l_@@_variant_str \c_hash_str \l_@@_lang_str
          }
        }
      }{
        \msg_error:nn{stex}{error/nonotation}{#1}{
          ~\l_@@_variant_str \c_hash_str \l_@@_lang_str
        }
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_invoke_text:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_text:n {
  \peek_charcode_remove:NTF ! {
    \stex_term_custom:nn { #1 } { }
  }{
    \prop_set_eq:Nc \l_tmpa_prop {
      g_stex_symdecl_ #1 _prop 
    }
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \exp_args:Nnx \stex_term_custom:nn { #1 } { \l_tmpa_str }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Terms}
%
% Precedences:
% \begin{variable}{\infprec, \neginfprec, \l_@@_downprec}
%    \begin{macrocode}
\tl_const:Nx \infprec {\int_use:N \c_max_int}
\tl_const:Nx \neginfprec {-\int_use:N \c_max_int}
\int_new:N \l_@@_downprec
\int_set_eq:NN \l_@@_downprec \infprec
%    \end{macrocode}
% \end{variable}
%
% Bracketing:
%
% \begin{variable}{\l_@@_left_bracket_str, \l_@@_right_bracket_str}
%    \begin{macrocode}
\tl_set:Nn \l_@@_left_bracket_str (
\tl_set:Nn \l_@@_right_bracket_str )
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\_@@_maybe_brackets:nn}
%
% Compares precedences and insert brackets accordingly
%
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_maybe_brackets:nn {
  \bool_if:NTF \l_@@_brackets_done_bool {
    \bool_set_false:N \l_@@_brackets_done_bool
    #2
  } {
    \int_compare:nNnTF { #1 } > \l_@@_downprec {
      \bool_if:NTF \l_stex_inparray_bool { #2 }{
        \stex_debug:nn{dobrackets}{\number#1 > \number\l_@@_downprec; \detokenize{#2}}
        \dobrackets { #2 }
      }
    }{ #2 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\dobrackets}
%    \begin{macrocode}
\bool_new:N \l_@@_brackets_done_bool
%\RequirePackage{scalerel}
\cs_new_protected:Npn \dobrackets #1 {
  %\ThisStyle{\if D\m@switch
  %    \exp_args:Nnx \use:nn
  %    { \exp_after:wN \left\l_@@_left_bracket_str #1 } 
  %    { \exp_not:N\right\l_@@_right_bracket_str }
  %  \else
      \exp_args:Nnx \use:nn
      { 
        \bool_set_true:N \l_@@_brackets_done_bool
        \int_set:Nn \l_@@_downprec \infprec
        \l_@@_left_bracket_str 
        #1
      } 
      {
        \bool_set_false:N \l_@@_brackets_done_bool
        \l_@@_right_bracket_str 
        \int_set:Nn \l_@@_downprec { \int_use:N \l_@@_downprec }
      }
  %\fi}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\withbrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \withbrackets #1 #2 #3 {
  \exp_args:Nnx \use:nn
  {  
    \tl_set:Nx \l_@@_left_bracket_str { #1 }
    \tl_set:Nx \l_@@_right_bracket_str { #2 }
    #3
  }
  {
    \tl_set:Nn \exp_not:N \l_@@_left_bracket_str 
      {\l_@@_left_bracket_str}
    \tl_set:Nn \exp_not:N \l_@@_right_bracket_str 
      {\l_@@_right_bracket_str}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXinvisible}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXinvisible #1 {
  \stex_annotate_invisible:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \omdoc terms:
%
% \begin{macro}{\_stex_term_math_oms:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_oms:nnn {
  \stex_annotate:nnn{ OMID }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 } 
  }
}

\cs_new_protected:Nn \_stex_term_math_oms:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_oms:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_oma:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_oma:nnn {
  \stex_annotate:nnn{ OMA }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 } 
  }
}

\cs_new_protected:Nn \_stex_term_math_oma:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_oma:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_omb:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_ombind:nnn {
  \stex_annotate:nnn{ OMBIND }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 }
  }
}

\cs_new_protected:Nn \_stex_term_math_omb:nnnn {
  \_@@_maybe_brackets:nn { #3 }{ 
    \_stex_term_ombind:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_term_math_arg:nnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_arg:nn {
  \stex_unhighlight_term:n { 
    \stex_annotate:nnn{ arg }{ #1 }{ #2 }
  }
}
\cs_new_protected:Nn \_stex_term_math_arg:nnn {
  \exp_args:Nnx \use:nn
    { \int_set:Nn \l_@@_downprec { #2 } 
        \_stex_term_arg:nn { #1 }{ #3 }
    }
    { \int_set:Nn \exp_not:N \l_@@_downprec { \int_use:N \l_@@_downprec } }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\_stex_term_math_assoc_arg:nnnn}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_term_math_assoc_arg:nnnn {
  \clist_set:Nn \l_tmpa_clist{ #4 }
  \int_compare:nNnTF { \clist_count:N \l_tmpa_clist } < 2 {
    \tl_set:Nn \l_tmpa_tl { #4 }
  }{
    \cs_set:Npn \l_tmpa_cs ##1 ##2 { #3 }
    \clist_reverse:N \l_tmpa_clist
    \clist_pop:NN \l_tmpa_clist \l_tmpa_tl

    \clist_map_inline:Nn \l_tmpa_clist {
      \exp_args:NNNo \exp_args:NNo \tl_set:No \l_tmpa_tl {
        \exp_args:Nno 
        \l_tmpa_cs { ##1 } \l_tmpa_tl 
      }
    }

  }
  \exp_args:Nnno
  \_stex_term_math_arg:nnn{#1}{#2}\l_tmpa_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_term_custom:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_term_custom:nn {
  \str_set:Nn \l_@@_custom_uri { #1 }
  \str_set:Nn \l_tmpa_str { #2 }
  \tl_clear:N \l_tmpa_tl
  \int_zero:N \l_tmpa_int
  \int_set:Nn \l_tmpb_int { \str_count:N \l_tmpa_str }
  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_loop:}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_loop: {
  \bool_set_false:N \l_tmpa_bool
  \bool_while_do:nn {
    \str_if_eq_p:ee X {
      \str_item:Nn \l_tmpa_str { \l_tmpa_int + 1 }
    }
  }{
    \int_incr:N \l_tmpa_int
  }

  \peek_charcode:NTF [ {
    % notation/text component
    \_@@_custom_component:w
  } {
    \int_compare:nNnTF \l_tmpa_int = \l_tmpb_int {
      % all arguments read => finish
      \_@@_custom_final:
    } {
      % arguments missing
      \peek_charcode_remove:NTF * {
        % invisible, specific argument position or both
        \peek_charcode:NTF [ {
          % visible specific argument position
          \_@@_custom_arg:wn
        } {
          % invisible
          \peek_charcode_remove:NTF * {
            % invisible specific argument position
            \_@@_custom_arg_inv:wn
          } {
            % invisible next argument
            \_@@_custom_arg_inv:wn [ \l_tmpa_int + 1 ]
          }
        } 
      } {
        % next normal argument
        \_@@_custom_arg:wn [ \l_tmpa_int + 1 ]
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_arg_inv:wn}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_arg_inv:wn [ #1 ] #2 {
  \bool_set_true:N \l_tmpa_bool
  \_@@_custom_arg:wn [ #1 ] { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_arg:wn}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_arg:wn [ #1 ] #2 {
  \str_set:Nx \l_tmpb_str { 
    \str_item:Nn \l_tmpa_str { #1 }
  }
  \str_case:VnTF \l_tmpb_str {
    { X } {
      \msg_error:nnn{stex}{error/notationarg}{\l_@@_custom_uri}
    }
    { i } { \_@@_custom_set_X:n { #1 } }
    { b } { \_@@_custom_set_X:n { #1 } }
    { a } { \_@@_custom_set_X:n { #1 } } % TODO ?
    { B } { \_@@_custom_set_X:n { #1 } } % TODO ?
  }{}{
    \msg_error:nnn{stex}{error/notationarg}{\l_@@_custom_uri}
  }

  \bool_if:nTF \l_tmpa_bool {
    \tl_put_right:Nx \l_tmpa_tl {
      \stex_annotate_invisible:n {
        \_stex_term_arg:nn { \int_eval:n { #1 } } 
          \exp_not:n { { #2 } }
      }
    }
  } {
    \tl_put_right:Nx \l_tmpa_tl {
      \_stex_term_arg:nn { \int_eval:n { #1 } } 
        \exp_not:n { { #2 } }
    }
  }

  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_set_X:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_set_X:n {
  \str_set:Nx \l_tmpa_str {
    \str_range:Nnn \l_tmpa_str 1 { #1 - 1 }
    X
    \str_range:Nnn \l_tmpa_str { #1 + 1 } { -1 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_component:}
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_custom_component:w [ #1 ] {
  \tl_put_right:Nn \l_tmpa_tl { \comp{ #1 } }
  \_@@_custom_loop:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_@@_custom_final:}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_custom_final: {
  \int_compare:nNnTF \l_tmpb_int = 0 {
    \exp_args:Nnno \_stex_term_oms:nnn
  }{
    \str_if_in:NnTF \l_tmpa_str {b} {
      \exp_args:Nnno \_stex_term_ombind:nnn
    } {
      \exp_args:Nnno \_stex_term_oma:nnn
    }
  }
  { \l_@@_custom_uri } { \l_@@_custom_uri } { \l_tmpa_tl }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symref,\symname}
%    \begin{macrocode}
\NewDocumentCommand \symref { m m }{
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \STEXsymbol{#1}![#2]
  \let\compemph@uri\compemph_uri_prev:
}

\keys_define:nn { stex / symname } {
  post    .str_set_x:N   = \l_stex_symname_post_str
}

\cs_new_protected:Nn \stex_symname_args:n {
  \str_clear:N \l_stex_symname_post_str
  \keys_set:nn { stex / symname } { #1 }
}

\NewDocumentCommand \symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { g_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }![
    \l_tmpa_str \l_stex_symname_post_str
  ] }
  \let\compemph@uri\compemph_uri_prev:
}
%    \end{macrocode}
% \end{macro}
%
%
% \subsection{Notation Components}
%    \begin{macrocode}
%<@@=stex_notationcomps>
%    \end{macrocode}
%
%
% \begin{macro}{\stex_highlight_term:nn}
%    \begin{macrocode}

\str_new:N \l_@@_highlight_uri_str
\cs_new_protected:Nn \stex_highlight_term:nn {
  \exp_args:Nnx
  \use:nn {
    \str_set:Nx \l_@@_highlight_uri_str { #1 }
    #2
  } {
    \str_set:Nx \exp_not:N \l_@@_highlight_uri_str 
      { \l_@@_highlight_uri_str }
  }
}

\cs_new_protected:Nn \stex_unhighlight_term:n {
%  \latexml_if:TF {
%    #1
%  } {
%    \scalatex_if:TF {
%      #1
%    } {
      #1 %\iffalse{{\fi}} #1 {{\iffalse}}\fi
%    }
%  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\comp,\compemph@uri,\compemph,\defemph,\defemph@uri,\symrefemph,\symrefemph@uri}
%    \begin{macrocode}
\cs_new_protected:Npn \comp #1 {
  \str_if_empty:NF \l_@@_highlight_uri_str {
    \scalatex_if:TF {
      \stex_annotate:nnn { comp }{ \l_@@_highlight_uri_str }{ #1 }
    }{
      \exp_args:Nnx \compemph@uri { #1 } { \l_@@_highlight_uri_str }
    }
  }
}

\cs_new_protected:Npn \compemph@uri #1 #2 {
    \compemph{ #1 }
}


\cs_new_protected:Npn \compemph #1 {
    \textcolor{blue}{#1}
}

\cs_new_protected:Npn \defemph@uri #1 #2 {
    \defemph{#1}
}

\cs_new_protected:Npn \defemph #1 {
    \textbf{#1}
}

\cs_new_protected:Npn \symrefemph@uri #1 #2 {
    \symrefemph{#1}
}

\cs_new_protected:Npn \symrefemph #1 {
    \textbf{#1}
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\ellipses}
%    \begin{macrocode}
\NewDocumentCommand \ellipses {} { \ldots }
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\parray,\prmatrix,\parrayline,\parraylineh,\parraycell}
%    \begin{macrocode}
\bool_new:N \l_stex_inparray_bool
\bool_set_false:N \l_stex_inparray_bool
\NewDocumentCommand \parray { m m } {
  \begingroup 
  \bool_set_true:N \l_stex_inparray_bool
  \begin{array}{#1}
    #2
  \end{array}
  \endgroup
}

\NewDocumentCommand \prmatrix { m } {
  \begingroup 
  \bool_set_true:N \l_stex_inparray_bool
  \begin{matrix}
    #1
  \end{matrix}
  \endgroup
}

\def \parrayline #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\}
}

\def \parraylineh #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\\hline}
}

\def \parraycell #1 {
  #1 \bool_if:NT \l_stex_inparray_bool {&}
}
%    \end{macrocode}
% \end{macro}
%
%
%
%    \begin{macrocode}
%</package>
%    \end{macrocode}
%
% \end{implementation}
%
% \PrintIndex

% \endinput
% Local Variables:
% mode: doctex
% TeX-master: t
% End:
