%%
%% This is file `stex.sty',
%% generated with the docstrip utility.
%%
%% The original source files were:
%%
%% basics.dtx  (with options: `package')
%% mathhub.dtx  (with options: `package')
%% references.dtx  (with options: `package')
%% modules.dtx  (with options: `package')
%% inheritance.dtx  (with options: `package')
%% symbols.dtx  (with options: `package')
%% terms.dtx  (with options: `package')
%% features.dtx  (with options: `package')
%% statements.dtx  (with options: `package')
%% sproof.dtx  (with options: `package')
%% others.dtx  (with options: `package')
%% metatheory.dtx  (with options: `package')
%% 

%%%%%%%%%%%%%   basics.dtx   %%%%%%%%%%%%%

\RequirePackage{expl3,l3keys2e,ltxcmds}
\ProvidesExplPackage{stex}{2021/08/01}{1.9}{bla}
\RequirePackage{expl-keystr-compat}


\keys_define:nn { stex } {
  debug     .clist_set:N  = \c_stex_debug_clist ,
  lang      .clist_set:N  = \c_stex_languages_clist ,
  mathhub   .tl_set_x:N   = \mathhub ,
  sms       .bool_set:N   = \c_stex_persist_mode_bool ,
  image     .bool_set:N   = \c_tikzinput_image_bool,
  unknown   .code:n       = {}
}
\ProcessKeysOptions { stex }
\protected\def\stex{%
  \@ifundefined{texorpdfstring}%
  {\let\texorpdfstring\@firstoftwo}%
  {}%
  \texorpdfstring{\raisebox{-.5ex}S\kern-.5ex\TeX}{sTeX}\xspace%
}
\def\sTeX{\stex}
\msg_new:nnn{stex}{error/unknownlanguage}{
  Unknown~language:~#1
}
\msg_new:nnn{stex}{warning/nomathhub}{
  MATHHUB~system~variable~not~found~and~no~
  \detokenize{\mathhub}-value~set!
}
\msg_new:nnn{stex}{error/deactivated-macro}{
  The~\detokenize{#1}~command~is~only~allowed~in~#2!
}
\cs_new_protected:Nn \stex_debug:nn {
  \clist_if_in:NnTF \c_stex_debug_clist { all } {
    \exp_args:Nnnx\msg_set:nnn{stex}{debug / #1}{
      \\Debug~#1:~#2\\
    }
    \msg_none:nn{stex}{debug / #1}
  }{
    \clist_if_in:NnT \c_stex_debug_clist { #1 } {
      \exp_args:Nnnx\msg_set:nnn{stex}{debug / #1}{
        \\Debug~#1:~#2\\
      }
      \msg_none:nn{stex}{debug / #1}
    }
  }
}
\clist_if_in:NnTF \c_stex_debug_clist {all} {
    \msg_redirect_module:nnn{ stex }{ none }{ term }
}{
  \clist_map_inline:Nn \c_stex_debug_clist {
    \msg_redirect_name:nnn{ stex }{ debug / ##1 }{ term }
  }
}

\stex_debug:nn{log}{debug~mode~on}
\iow_new:N \c__stex_persist_sms_iow
\AddToHook{begindocument}{
  \bool_if:NTF \c_stex_persist_mode_bool {
    \ExplSyntaxOn \input{\jobname.sms} \ExplSyntaxOff
  } {
  }
}
\AddToHook{enddocument}{
  \bool_if:NF \c_stex_persist_mode_bool {
  }
}
\cs_new_protected:Nn \stex_add_to_sms:n {
  \bool_if:NF \c_stex_persist_mode_bool {
  }
}
\RequirePackage{rustex}
\rustex_add_Namespace:nn{stex}{http://kwarc.info/ns/sTeX}
\ifcsname if@latexml\endcsname\else
    \expandafter\newif\csname if@latexml\endcsname\@latexmlfalse
\fi

\prg_new_conditional:Nnn \latexml_if: {p, T, F, TF} {
  \if@latexml
    \prg_return_true:
  \else:
    \prg_return_false:
  \fi:
}
\tl_new:N \l__stex_annotate_arg_tl
\tl_const:Nx \c__stex_annotate_emptyarg_tl {
  \rustex_if:TF {
    \rustex_direct_HTML:n { \c_ampersand_str lrm; }
  }{~}
}
\cs_new_protected:Nn \__stex_annotate_checkempty:n {
  \tl_set:Nn \l__stex_annotate_arg_tl { #1 }
  \tl_if_empty:NT \l__stex_annotate_arg_tl {
    \tl_set_eq:NN \l__stex_annotate_arg_tl \c__stex_annotate_emptyarg_tl
  }
}
\bool_new:N \l_stex_html_do_output_bool
\bool_set_true:N \l_stex_html_do_output_bool
\prg_new_conditional:Nnn \stex_if_do_html: {p,T,F,TF} {
  \bool_if:nTF \l_stex_html_do_output_bool
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_suppress_html:n {
  \exp_args:Nne \use:nn {
    \bool_set_false:N \l_stex_html_do_output_bool
    #1
  }{
    \stex_if_do_html:T {
      \bool_set_true:N \l_stex_html_do_output_bool
    }
  }
}
\rustex_if:TF{
  \cs_new_protected:Nn \stex_annotate:nnn {
    \__stex_annotate_checkempty:n { #3 }
    \rustex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2"
    } {
      \mode_if_vertical:TF{
        \tl_use:N \l__stex_annotate_arg_tl\par
      }{
        \tl_use:N \l__stex_annotate_arg_tl
      }
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:n {
    \__stex_annotate_checkempty:n { #1 }
    \rustex_annotate_HTML:nn {
      stex:visible="false" ~
      style:display="none"
    } {
      \mode_if_vertical:TF{
        \tl_use:N \l__stex_annotate_arg_tl\par
      }{
        \tl_use:N \l__stex_annotate_arg_tl
      }
    }
  }
  \cs_new_protected:Nn \stex_annotate_invisible:nnn {
    \__stex_annotate_checkempty:n { #3 }
    \rustex_annotate_HTML:nn {
      property="stex:#1" ~
      resource="#2" ~
      stex:visible="false" ~
      style:display="none"
    } {
      \mode_if_vertical:TF{
        \tl_use:N \l__stex_annotate_arg_tl\par
      }{
        \tl_use:N \l__stex_annotate_arg_tl
      }
    }
  }
  \NewDocumentEnvironment{stex_annotate_env} { m m } {
    \par
    \rustex_annotate_HTML_begin:n {
      property="stex:#1" ~
      resource="#2"
    }
  }{
    \par\rustex_annotate_HTML_end:
  }
}{
  \latexml_if:TF {
    \cs_new_protected:Nn \stex_annotate:nnn {
      \__stex_annotate_checkempty:n { #3 }
      \mode_if_math:TF {
        \cs:w latexml@annotate@math\cs_end:{#1}{#2}{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }{
        \cs:w latexml@annotate@text\cs_end:{#1}{#2}{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:n {
      \__stex_annotate_checkempty:n { #1 }
      \mode_if_math:TF {
        \cs:w latexml@invisible@math\cs_end:{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      } {
        \cs:w latexml@invisible@text\cs_end:{
          \tl_use:N \l__stex_annotate_arg_tl
        }
      }
    }
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {
      \__stex_annotate_checkempty:n { #3 }
      \cs:w latexml@annotate@invisible\cs_end:{#1}{#2}{
        \tl_use:N \l__stex_annotate_arg_tl
      }
    }
    \NewDocumentEnvironment{stex_annotate_env} { m m } {
      \par\begin{latexml@annotateenv}{#1}{#2}
    }{
      \par\end{latexml@annotateenv}
    }
  }{
    \cs_new_protected:Nn \stex_annotate:nnn {#3}
    \cs_new_protected:Nn \stex_annotate_invisible:n {}
    \cs_new_protected:Nn \stex_annotate_invisible:nnn {}
    \NewDocumentEnvironment{stex_annotate_env} { m m } {}{}
  }
}
\prop_const_from_keyval:Nn \c_stex_languages_prop {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}

\prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}
\clist_if_empty:NF \c_stex_languages_clist {
  \clist_clear:N \l_tmpa_clist
  \clist_map_inline:Nn \c_stex_languages_clist {
    \prop_get:NnNTF \c_stex_languages_prop { #1 } \l_tmpa_str {
      \clist_put_right:No \l_tmpa_clist \l_tmpa_str
    } {
      \msg_error:nnx{stex}{error/unknownlanguage}{\l_tmpa_str}
    }
  }
  \stex_debug:nn{lang} {Languages:~\clist_use:Nn \l_tmpa_clist {,~} }
  \RequirePackage[\clist_use:Nn \l_tmpa_clist,]{babel}
}
\cs_new_protected:Nn \stex_deactivate_macro:Nn {
  \exp_after:wN\let\csname \detokenize{#1} - orig\endcsname#1
  \def#1{
    \msg_error:nnnn{stex}{error/deactivated-macro}{#1}{#2}
  }
}
\cs_new_protected:Nn \stex_reactivate_macro:N {
  \exp_after:wN\let\exp_after:wN#1\csname \detokenize{#1} - orig\endcsname
}
\tl_new:N \l__stex_aftergroup_tl
\cs_new_protected:Nn \stex_do_aftergroup:n {
  \int_compare:nNnTF \l_stex_module_group_depth_int = \currentgrouplevel {
    #1
  }{
    #1
    \expandafter \tl_gset:Nn \expandafter \l__stex_aftergroup_tl \expandafter { \l__stex_aftergroup_tl #1 }
    \aftergroup\__stex_aftergroup_do:
  }
}
\cs_new_protected:Nn \__stex_aftergroup_do: {
  \int_compare:nNnTF \l_stex_module_group_depth_int = \currentgrouplevel {
    \l__stex_aftergroup_tl
    \tl_clear:N \l__stex_aftergroup_tl
  }{
    \l__stex_aftergroup_tl
    \aftergroup\__stex_aftergroup_do:
  }
}

%%%%%%%%%%%%%   mathhub.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/norepository}{
  No~archive~#1~found~in~#2
}
\msg_new:nnn{stex}{error/notinarchive}{
  Not~currently~in~an~archive,~but~\detokenize{#1}~
  needs~one!
}
\msg_new:nnn{stex}{error/nofile}{
  \detokenize{#1}~could~not~find~file~#2
}
\msg_new:nnn{stex}{error/twofiles}{
  \detokenize{#1}~found~two~candidates~for~#2
}
\cs_new_protected:Nn \stex_path_from_string:Nn {
  \str_set:Nx \l_tmpa_str { #2 }
  \str_if_empty:NTF \l_tmpa_str {
    \seq_clear:N #1
  }{
    \exp_args:NNNo \seq_set_split:Nnn #1 / { \l_tmpa_str }
    \sys_if_platform_windows:T{
      \seq_clear:N \l_tmpa_tl
      \seq_map_inline:Nn #1 {
        \seq_set_split:Nnn \l_tmpb_tl \c_backslash_str { ##1 }
        \seq_concat:NNN \l_tmpa_tl \l_tmpa_tl \l_tmpb_tl
      }
      \seq_set_eq:NN #1 \l_tmpa_tl
    }
    \stex_path_canonicalize:N #1
  }
}
\cs_generate_variant:Nn \stex_path_from_string:Nn
  { NV, cn, cV }
\cs_new_protected:Nn \stex_path_to_string:NN {
  \exp_args:NNe \str_set:Nn #2 { \seq_use:Nn #1 / }
}

\cs_new:Nn \stex_path_to_string:N {
  \seq_use:Nn #1 /
}
\str_const:Nn \c__stex_path_dot_str {.}
\str_const:Nn \c__stex_path_up_str {..}
\cs_new_protected:Nn \stex_path_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_clear:N \l_tmpa_seq
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NT \l_tmpa_tl {
      \seq_put_right:Nn \l_tmpa_seq {}
    }
    \seq_map_inline:Nn #1 {
      \str_set:Nn \l_tmpa_tl { ##1 }
      \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_dot_str {} {
        \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_up_str {
          \seq_if_empty:NTF \l_tmpa_seq {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
              \c__stex_path_up_str
            }
          }{
            \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
            \str_if_eq:NNTF \l_tmpa_tl \c__stex_path_up_str {
              \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
                \c__stex_path_up_str
              }
            }{
              \seq_pop_right:NN \l_tmpa_seq \l_tmpb_tl
            }
          }
        }{
          \str_if_empty:NF \l_tmpa_tl {
            \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq { \l_tmpa_tl }
          }
        }
      }
    }
    \seq_gset_eq:NN #1 \l_tmpa_seq
  }
}
\prg_new_conditional:Nnn \stex_path_if_absolute:N {p, T, F, TF} {
  \seq_if_empty:NTF #1 {
    \prg_return_false:
  }{
    \seq_get_left:NN #1 \l_tmpa_tl
    \str_if_empty:NTF \l_tmpa_tl {
      \prg_return_true:
    }{
      \prg_return_false:
    }
  }
}
\str_new:N\l_stex_kpsewhich_return_str
\cs_new_protected:Nn \stex_kpsewhich:n {
  \sys_get_shell:nnN { kpsewhich ~ #1 } { } \l_tmpa_tl
  \exp_args:NNo\str_set:Nn\l_stex_kpsewhich_return_str{\l_tmpa_tl}
  \tl_trim_spaces:N \l_stex_kpsewhich_return_str
}
\sys_if_platform_windows:TF{
  \stex_kpsewhich:n{-expand-var~\c_percent_str CD\c_percent_str}
}{
  \stex_kpsewhich:n{-var-value~PWD}
}

\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:nn {mathhub} {PWD:~\str_use:N\c_stex_pwd_str}
\seq_gclear_new:N\g__stex_files_stack
\str_set:Nx \c_stex_mainfile_str {\c_stex_pwd_str/\jobname.tex}
\stex_path_from_string:Nn \c_stex_mainfile_seq
  \c_stex_mainfile_str
\seq_gclear_new:N\g_stex_currentfile_seq
\cs_new_protected:Nn \stex_filestack_push:n {
  \stex_path_from_string:Nn\g_stex_currentfile_seq{#1}
  \stex_path_if_absolute:NF\g_stex_currentfile_seq{
    \stex_path_from_string:Nn\g_stex_currentfile_seq{
      \c_stex_pwd_str/#1
    }
  }
  \seq_gset_eq:NN\g_stex_currentfile_seq\g_stex_currentfile_seq
  \exp_args:NNo\seq_gpush:Nn\g__stex_files_stack\g_stex_currentfile_seq
}
\cs_new_protected:Nn \stex_filestack_pop: {
  \seq_if_empty:NF\g__stex_files_stack{
    \seq_gpop:NN\g__stex_files_stack\l_tmpa_seq
  }
  \seq_if_empty:NTF\g__stex_files_stack{
    \seq_gset_eq:NN\g_stex_currentfile_seq\c_stex_mainfile_seq
  }{
    \seq_get:NN\g__stex_files_stack\l_tmpa_seq
    \seq_gset_eq:NN\g_stex_currentfile_seq\l_tmpa_seq
  }
}

\AddToHook{file/before}{
  \stex_filestack_push:n{\CurrentFilePath/\CurrentFile}
}
\AddToHook{file/after}{
  \stex_filestack_pop:
}
\str_if_empty:NTF\mathhub{
  \stex_kpsewhich:n{-var-value~MATHHUB}
  \str_set_eq:NN\c_stex_mathhub_str\l_stex_kpsewhich_return_str

  \str_if_empty:NTF\c_stex_mathhub_str{
    \msg_warning:nn{stex}{warning/nomathhub}
  }{
    \stex_debug:nn{mathhub} {MathHub:~\str_use:N\c_stex_mathhub_str}
    \exp_args:NNo \stex_path_from_string:Nn\c_stex_mathhub_seq\c_stex_mathhub_str
  }
}{
  \stex_path_from_string:Nn \c_stex_mathhub_seq \mathhub
  \stex_path_if_absolute:NF \c_stex_mathhub_seq {
    \exp_args:NNx \stex_path_from_string:Nn \c_stex_mathhub_seq {
      \c_stex_pwd_str/\mathhub
    }
  }
  \stex_path_to_string:NN\c_stex_mathhub_seq\c_stex_mathhub_str
  \stex_debug:nn{mathhub} {MathHub:~\str_use:N\c_stex_mathhub_str}
}
\cs_new_protected:Nn \__stex_mathhub_do_manifest:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \prop_if_exist:cF {c_stex_mathhub_#1_manifest_prop} {
    \prop_new:c { c_stex_mathhub_#1_manifest_prop }
    \seq_set_split:NnV \l_tmpa_seq / \l_tmpa_str
    \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpa_seq
    \__stex_mathhub_find_manifest:N \l_tmpa_seq
    \seq_if_empty:NTF \l__stex_mathhub_manifest_file_seq {
      \msg_error:nnxx{stex}{error/norepository}{#1}{
        \stex_path_to_string:N \c_stex_mathhub_str
      }
    } {
      \exp_args:No \__stex_mathhub_parse_manifest:n { \l_tmpa_str }
    }
  }
}
\str_new:N\l__stex_mathhub_manifest_file_seq
\cs_new_protected:Nn \__stex_mathhub_find_manifest:N {
  \seq_set_eq:NN\l_tmpa_seq #1
  \bool_set_true:N\l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_if_empty:NTF \l_tmpa_seq {
      \bool_set_false:N\l_tmpa_bool
    }{
      \file_if_exist:nTF{
        \stex_path_to_string:N\l_tmpa_seq/MANIFEST.MF
      }{
        \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
        \bool_set_false:N\l_tmpa_bool
      }{
        \file_if_exist:nTF{
          \stex_path_to_string:N\l_tmpa_seq/META-INF/MANIFEST.MF
        }{
          \seq_put_right:Nn\l_tmpa_seq{META-INF}
          \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
          \bool_set_false:N\l_tmpa_bool
        }{
          \file_if_exist:nTF{
            \stex_path_to_string:N\l_tmpa_seq/meta-inf/MANIFEST.MF
          }{
            \seq_put_right:Nn\l_tmpa_seq{meta-inf}
            \seq_put_right:Nn\l_tmpa_seq{MANIFEST.MF}
            \bool_set_false:N\l_tmpa_bool
          }{
            \seq_pop_right:NN\l_tmpa_seq\l_tmpa_tl
          }
        }
      }
    }
  }
  \seq_set_eq:NN\l__stex_mathhub_manifest_file_seq\l_tmpa_seq
}
\ior_new:N \c__stex_mathhub_manifest_ior
\cs_new_protected:Nn \__stex_mathhub_parse_manifest:n {
  \seq_set_eq:NN \l_tmpa_seq \l__stex_mathhub_manifest_file_seq
  \ior_open:Nn \c__stex_mathhub_manifest_ior {\stex_path_to_string:N \l_tmpa_seq}
  \ior_map_inline:Nn \c__stex_mathhub_manifest_ior {
    \str_set:Nn \l_tmpa_str {##1}
    \exp_args:NNoo \seq_set_split:Nnn
        \l_tmpb_seq \c_colon_str \l_tmpa_str
    \seq_pop_left:NNTF \l_tmpb_seq \l_tmpa_tl {
      \exp_args:NNe \str_set:Nn \l_tmpb_tl {
        \exp_args:NNo \seq_use:Nn \l_tmpb_seq \c_colon_str
      }
      \exp_args:No \str_case:nnTF \l_tmpa_tl {
        {id} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { id } \l_tmpb_tl
        }
        {narration-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { narr } \l_tmpb_tl
        }
        {url-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { docurl } \l_tmpb_tl
        }
        {source-base} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { ns } \l_tmpb_tl
        }
        {ns} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { ns } \l_tmpb_tl
        }
        {dependencies} {
          \prop_gput:cno { c_stex_mathhub_#1_manifest_prop }
            { deps } \l_tmpb_tl
        }
      }{}{}
    }{}
  }
  \ior_close:N \c__stex_mathhub_manifest_ior
}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \prop_set_eq:Nc \l_stex_current_repository_prop {
    c_stex_mathhub_#1_manifest_prop
  }
}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \stex_debug:nn{mathhub}{Opening~archive:~#1}
    \__stex_mathhub_do_manifest:n { #1 }
    \exp_args:Nx \stex_add_to_sms:n {
      \prop_const_from_keyval:cn { c_stex_mathhub_#1_manifest_prop } {
        id   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  id  } ,
        ns   = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } {  ns  } ,
        narr = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { narr } ,
        deps = \prop_item:cn { c_stex_mathhub_#1_manifest_prop } { deps }
      }
    }
  }
}

\__stex_mathhub_find_manifest:N \c_stex_pwd_seq
\seq_if_empty:NTF \l__stex_mathhub_manifest_file_seq {
  \stex_debug:nn{mathhub}{Not~currently~in~a~MathHub~repository}
} {
  \__stex_mathhub_parse_manifest:n { main }
  \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id}
    \l_tmpa_str
  \prop_set_eq:cN { c_stex_mathhub_\l_tmpa_str _manifest_prop }
    \c_stex_mathhub_main_manifest_prop
  \exp_args:Nx \stex_set_current_repository:n { \l_tmpa_str }
  \stex_debug:nn{mathhub}{Current~repository:~
    \prop_item:Nn \l_stex_current_repository_prop {id}
  }
}
\cs_new_protected:Nn \stex_in_repository:nn {
  \str_set:Nx \l_tmpa_str { #1 }
  \cs_set:Npn \l_tmpa_cs ##1 { #2 }
  \str_if_empty:NTF \l_tmpa_str {
    \prop_if_exist:NTF \l_stex_current_repository_prop {
      \stex_debug:nn{mathhub}{do~in~current~repository:~\prop_item:Nn \l_stex_current_repository_prop { id }}
      \exp_args:Ne \l_tmpa_cs{
        \prop_item:Nn \l_stex_current_repository_prop { id }
      }
    }{
      \l_tmpa_cs{}
    }
  }{
    \stex_debug:nn{mathhub}{in~repository:~\l_tmpa_str}
    \stex_require_repository:n \l_tmpa_str
    \str_set:Nx \l_tmpa_str { #1 }
    \exp_args:Nne \use:nn {
      \stex_set_current_repository:n \l_tmpa_str
      \exp_args:Nx \l_tmpa_cs{\l_tmpa_str}
    }{
      \stex_debug:nn{mathhub}{switching~back~to:~
        \prop_if_exist:NTF \l_stex_current_repository_prop {
          \prop_item:Nn \l_stex_current_repository_prop { id }:~
          \meaning\l_stex_current_repository_prop
        }{
          no~repository
        }
      }
      \prop_if_exist:NTF \l_stex_current_repository_prop {
       \stex_set_current_repository:n {
        \prop_item:Nn \l_stex_current_repository_prop { id }
       }
      }{
        \let\exp_not:N\l_stex_current_repository_prop\exp_not:N\undefined
      }
    }
  }
}
\newif \ifinputref \inputreffalse

\cs_new_protected:Nn \stex_mhinput:nn {
  \stex_in_repository:nn {#1} {
    \ifinputref
      \input{ \c_stex_mathhub_str / ##1 / source / #2 }
    \else
      \inputreftrue
      \input{ \c_stex_mathhub_str / ##1 / source / #2 }
      \inputreffalse
    \fi
  }
}
\NewDocumentCommand \mhinput { O{} m}{
  \stex_mhinput:nn{ #1 }{ #2 }
}

\cs_new_protected:Nn \stex_inputref:nn {
  \stex_in_repository:nn {#1} {
    \bool_lazy_any:nTF {
      {\rustex_if_p:} {\latexml_if_p:}
    } {
      \str_clear:N \l_tmpa_str
      \prop_get:NnNF \l_stex_current_repository_prop { narr } \l_tmpa_str {
        \prop_get:NnNF \l_stex_current_repository_prop { ns } \l_tmpa_str {}
      }
      \stex_annotate_invisible:nnn{inputref}{
        \l_tmpa_str / #2
      }{}
    }{
      \begingroup
        \inputreftrue
        \input{ \c_stex_mathhub_str / ##1 / source / #2 }
      \endgroup
    }
  }
}

\NewDocumentCommand \inputref { O{} m}{
  \stex_inputref:nn{ #1 }{ #2 }
}

\cs_new_protected:Nn \stex_mhbibresource:nn {
  \stex_in_repository:nn {#1} {
    \addbibresource{ \c_stex_mathhub_str / ##1 / #2 }
  }
}
\newcommand\addmhbibresource[2][]{
  \stex_mhbibresource:nn{ #1 }{ #2 }
}
  \def \mhpath #1 #2 {
    \exp_args:Ne \str_if_eq:nnTF{#1}{}{
      \c_stex_mathhub_str /
        \prop_item:Nn \l_stex_current_repository_prop { id }
        / source / #2
    }{
      \c_stex_mathhub_str / #1 / source / #2
    }
  }
\cs_new_protected:Npn \libinput #1 {
  \prop_if_exist:NF \l_stex_current_repository_prop {
    \msg_error:nnn{stex}{error/notinarchive}\libinput
  }
  \prop_get:NnNF \l_stex_current_repository_prop {id} \l_tmpa_str {
    \msg_error:nnn{stex}{error/notinarchive}\libinput
  }
  \bool_set_false:N \l_tmpa_bool
  \tl_clear:N \l_tmpa_tl
  \seq_set_eq:NN \l_tmpa_seq \c_stex_mathhub_seq
  \seq_set_split:NnV \l_tmpb_seq / \l_tmpa_str
  \seq_pop_right:NN \l_tmpb_seq \l_tmpa_str
  \seq_pop_left:NNT \l_tmpb_seq \l_tmpb_str {
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq
      / meta-inf / lib / #1.tex}{
        \bool_set_true:N \l_tmpa_bool
        \tl_put_right:Nx \l_tmpa_tl {
          \exp_not:N \input { \stex_path_to_string:N \l_tmpa_seq
          / meta-inf / lib / #1.tex}
        }
      }{}
  }
  \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq
    / \l_tmpa_str / lib / #1.tex
  }{
    \bool_set_true:N \l_tmpa_bool
    \tl_put_right:Nx \l_tmpa_tl {
      \exp_not:N \input { \stex_path_to_string:N \l_tmpa_seq
      / \l_tmpa_str / lib / #1.tex}
    }
  }{}
  \bool_if:NF \l_tmpa_bool {
    \msg_error:nnxx{stex}{error/nofile}{\exp_not:N\libinput}{#1.tex}
  }
  \l_tmpa_tl
}
\NewDocumentCommand \libusepackage {O{} m} {
  \prop_if_exist:NF \l_stex_current_repository_prop {
    \msg_error:nnn{stex}{error/notinarchive}\libusepackage
  }
  \prop_get:NnNF \l_stex_current_repository_prop {id} \l_tmpa_str {
    \msg_error:nnn{stex}{error/notinarchive}\libusepackage
  }
  \bool_set_false:N \l_libusepackage_bool
  \tl_clear:N \l_tmpa_tl
  \seq_set_eq:NN \l_tmpa_seq \c_stex_mathhub_seq
  \seq_set_split:NnV \l_tmpb_seq / \l_tmpa_str
  \seq_pop_right:NN \l_tmpb_seq \l_tmpa_str
  \seq_pop_left:NNT \l_tmpb_seq \l_tmpb_str {
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq
      / meta-inf / lib / #2.sty}{
        \bool_set_true:N \l_libusepackage_bool
        \tl_put_right:Nx \l_tmpa_tl {
          \exp_not:N \usepackage[#1] { \stex_path_to_string:N \l_tmpa_seq
          / meta-inf / lib / #2}
        }
      }{}
  }
  \IfFileExists{ \stex_path_to_string:N \l_tmpa_seq
    / \l_tmpa_str / lib / #2.sty
  }{
    \bool_if:NT \l_libusepackage_bool {
      \msg_error:nnxx{stex}{error/twofiles}{\exp_not:N\libusepackage}{#2.sty}
    }
    \bool_set_true:N \l_libusepackage_bool
    \tl_put_right:Nx \l_tmpa_tl {
      \exp_not:N \usepackage[#1] { \stex_path_to_string:N \l_tmpa_seq
      / \l_tmpa_str / lib / #2}
    }
  }{}
  \bool_if:NF \l_libusepackage_bool {
    \msg_error:nnxx{stex}{error/nofile}{\exp_not:N\libusepackage}{#2.sty}
  }
  \l_tmpa_tl
}

\AddToHook{begindocument}{
\ltx@ifpackageloaded{graphicx}{
    \define@key{Gin}{mhrepos}{\def\Gin@mhrepos{#1}}
    \newcommand\mhgraphics[2][]{%
      \def\Gin@mhrepos{}\setkeys{Gin}{#1}%
      \includegraphics[#1]{\mhpath\Gin@mhrepos{#2}}}
    \newcommand\cmhgraphics[2][]{\begin{center}\mhgraphics[#1]{#2}\end{center}}
  }{}
\ltx@ifpackageloaded{listings}{
    \define@key{lst}{mhrepos}{\def\lst@mhrepos{#1}}
    \newcommand\lstinputmhlisting[2][]{%
      \def\lst@mhrepos{}\setkeys{lst}{#1}%
      \lstinputlisting[#1]{\mhpath\lst@mhrepos{#2}}}
    \newcommand\clstinputmhlisting[2][]{\begin{center}\lstinputmhlisting[#1]{#2}\end{center}}
  }{}
}


%%%%%%%%%%%%%   references.dtx   %%%%%%%%%%%%%


\iow_new:N \c__stex_refs_refs_iow
\AddToHook{begindocument}{
  \iow_open:Nn \c__stex_refs_refs_iow {\jobname.sref}
}
\AddToHook{enddocument}{
  \iow_close:N \c__stex_refs_refs_iow
}

\str_set:Nn \g__stex_refs_title_tl {Unnamed~Document}

\NewDocumentCommand \STEXreftitle { m } {
  \tl_gset:Nx \g__stex_refs_title_tl { #1 }
}
\seq_new:N \g__stex_refs_all_refs_seq

\str_new:N \l_stex_current_docns_str

\cs_new_protected:Nn \stex_get_document_uri: {
  \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \str_clear:N \l_tmpa_str
  \prop_if_exist:NT \l_stex_current_repository_prop {
    \prop_get:NnNF \l_stex_current_repository_prop { narr } \l_tmpa_str {
      \prop_get:NnNF \l_stex_current_repository_prop { ns } \l_tmpa_str {}
    }
  }

  \str_if_empty:NTF \l_tmpa_str {
    \str_set:Nx \l_stex_current_docns_str {
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }{
    \bool_set_true:N \l_tmpa_bool
    \bool_while_do:Nn \l_tmpa_bool {
      \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
      \exp_args:No \str_case:nnTF { \l_tmpb_str } {
        {source} { \bool_set_false:N \l_tmpa_bool }
      }{}{
        \seq_if_empty:NT \l_tmpa_seq {
          \bool_set_false:N \l_tmpa_bool
        }
      }
    }

    \seq_if_empty:NTF \l_tmpa_seq {
      \str_set_eq:NN \l_stex_current_docns_str \l_tmpa_str
    }{
      \str_set:Nx \l_stex_current_docns_str {
        \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
      }
    }
  }
}
\str_new:N \l_stex_current_docurl_str
\cs_new_protected:Nn \stex_get_document_url: {
  \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \str_clear:N \l_tmpa_str
  \prop_if_exist:NT \l_stex_current_repository_prop {
    \prop_get:NnNF \l_stex_current_repository_prop { docurl } \l_tmpa_str {
      \prop_get:NnNF \l_stex_current_repository_prop { narr } \l_tmpa_str {
        \prop_get:NnNF \l_stex_current_repository_prop { ns } \l_tmpa_str {}
      }
    }
  }

  \str_if_empty:NTF \l_tmpa_str {
    \str_set:Nx \l_stex_current_docurl_str {
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }{
    \bool_set_true:N \l_tmpa_bool
    \bool_while_do:Nn \l_tmpa_bool {
      \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
      \exp_args:No \str_case:nnTF { \l_tmpb_str } {
        {source} { \bool_set_false:N \l_tmpa_bool }
      }{}{
        \seq_if_empty:NT \l_tmpa_seq {
          \bool_set_false:N \l_tmpa_bool
        }
      }
    }

    \seq_if_empty:NTF \l_tmpa_seq {
      \str_set_eq:NN \l_stex_current_docurl_str \l_tmpa_str
    }{
      \str_set:Nx \l_stex_current_docurl_str {
        \l_tmpa_str/\stex_path_to_string:N \l_tmpa_seq
      }
    }
  }
}
\str_const:Nn \c__stex_refs_url_str{URL}
\str_const:Nn \c__stex_refs_ref_str{REF}
\cs_new_protected:Nn \stex_ref_new_doc_target:n {
  \stex_get_document_uri:
  \str_set:Nx \l_tmpa_str { #1 }
  \str_if_empty:NT \l_tmpa_str {
    \int_zero:N \l_tmpa_int
    \bool_set_true:N \l_tmpa_bool
    \bool_while_do:Nn \l_tmpa_bool {
      \cs_if_exist:cTF {
        sref_\l_stex_current_docns_str?? REF_\int_use:N \l_tmpa_int _type
      }{
        \int_incr:N \l_tmpa_int
      }{
        \str_set:Nx \l_tmpa_str { REF_\int_use:N \l_tmpa_int }
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }
  \str_set:Nx \l_tmpa_str {
    \l_stex_current_docns_str??\l_tmpa_str
  }
  \seq_gput_right:No \g__stex_refs_all_refs_seq \l_tmpa_str
  \stex_if_smsmode:TF {
    \stex_get_document_url:
    \str_gset_eq:cN {sref_url_\l_tmpa_str _str}\l_stex_current_docurl_str
    \str_gset_eq:cN {sref_\l_tmpa_str _type}\c__stex_refs_url_str
  }{
    \iow_now:Nx \c__stex_refs_refs_iow { \l_tmpa_str~=~\expandafter\unexpanded\expandafter{\@currentlabel}~in~\exp_args:No\unexpanded\g__stex_refs_title_tl,}
    \exp_args:Nx\label{sref_\l_tmpa_str}
    \exp_args:NNNx\immediate\write\@auxout{\stexauxadddocref{\l_tmpa_str}}
    \str_gset:cx {sref_\l_tmpa_str _type}\c__stex_refs_ref_str
  }
}
\cs_new_protected:Npn \stexauxadddocref #1 {
  \str_set:Nx \l_tmpa_str {#1}
  \str_gset_eq:cN{sref_\l_tmpa_str _type}\c__stex_refs_ref_str
  \seq_gput_right:Nx \g__stex_refs_all_refs_seq {\l_tmpa_str}
}
\cs_new_protected:Nn \stex_ref_new_sym_target:n {
  \stex_get_document_uri:
  \stex_if_smsmode:TF {
    \stex_get_document_url:
    \str_gset_eq:cN {sref_sym_url_#1_str}\l_stex_current_docurl_str
    \str_gset_eq:cN {sref_sym_#1_type}\c__stex_refs_url_str

  }{
    \iow_now:Nx \c__stex_refs_refs_iow { \l_tmpa_str~=~\expandafter{\@currentlabel\iffalse}{\fi~in~\exp_args:No\unexpanded\g__stex_refs_title_tl},}
    \exp_args:Nx\label{sref_sym_#1}

    \exp_args:NNNx\immediate\write\@auxout{\stexauxadddocref{sym_#1}}
    \str_gset:cx {sref_sym_#1_type}\c__stex_refs_ref_str
  }
}
\str_new:N \l__stex_refs_indocument_str
\keys_define:nn { stex / sref } {
  linktext      .tl_set:N  = \l__stex_refs_linktext_tl ,
  fallback      .tl_set:N  = \l__stex_refs_fallback_tl ,
  pre           .tl_set:N  = \l__stex_refs_pre_tl ,
  post          .tl_set:N  = \l__stex_refs_post_tl ,
  %indoc         .str_set_x:N  = \l__stex_refs_repo_str ,
}

\bool_new:N \c__stex_refs_hyperref_bool
\bool_set_false:N \c__stex_refs_hyperref_bool
\AddToHook{begindocument}{
  \@ifpackageloaded{hyperref}{
    \bool_set_true:N \c__stex_refs_hyperref_bool
  }{}
}

\cs_new_protected:Nn \__stex_refs_args:n {
  \tl_clear:N \l__stex_refs_linktext_tl
  \tl_clear:N \l__stex_refs_fallback_tl
  \tl_clear:N \l__stex_refs_pre_tl
  \tl_clear:N \l__stex_refs_post_tl
  \str_clear:N \l__stex_refs_repo_str
  \keys_set:nn { stex / sref } { #1 }
}

\NewDocumentCommand \sref { O{} m}{
  \__stex_refs_args:n { #1 }
  \str_if_empty:NTF \l__stex_refs_indocument_str {
    \str_set:Nn \l_tmpa_str { #2 }
    \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
    \tl_set:Nn \l_tmpa_tl {
      \l__stex_refs_fallback_tl
    }
    \seq_map_inline:Nn \g__stex_refs_all_refs_seq {
      \str_set:Nn \l_tmpb_str { ##1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int }{ -1 }
      } {
        \seq_map_break:n {
          \tl_set:Nn \l_tmpa_tl {
            % doc uri in \l_tmpb_str
            \str_set:Nx \l_tmpa_str {\use:c{sref_\l_tmpb_str _type}}
            \str_if_eq:NNTF \l_tmpa_str \c__stex_refs_ref_str {
              % reference
              \cs_if_exist:cTF{autoref}{
                \l__stex_refs_pre_tl\autoref{sref_\l_tmpb_str}\l__stex_refs_post_tl
              }{
                \l__stex_refs_pre_tl\ref{sref_\l_tmpb_str}\l__stex_refs_post_tl
              }
            }{
              % URL
              \if_bool:N \c__stex_refs_hyperref_bool {
                \exp_args:Nx \href{\use:c{sref_url_\l_tmpb_str _str}}{\l__stex_refs_fallback_tl}
              }{
                \l__stex_refs_fallback_tl
              }
            }
          }
        }
      }
    }
    \l_tmpa_tl
  }{
    % TODO
  }
}

\NewDocumentCommand \srefsym { O{} m}{
  \stex_get_symbol:n { #2 }
  \__stex_refs_args:n { #1 }
  \str_if_empty:NTF \l__stex_refs_indocument_str {
    \tl_set:Nn \l_tmpa_tl {
      \l__stex_refs_fallback_tl
    }
    \tl_if_exist:cT{sref_sym_\l_stex_get_symbol_uri_str _type}{
      \tl_set:Nn \l_tmpa_tl {
        % doc uri in \l_tmpb_str
        \str_set:Nx \l_tmpa_str {\use:c{sref_sym_\l_stex_get_symbol_uri_str _type}}
        \str_if_eq:NNTF \l_tmpa_str \c__stex_refs_ref_str {
          % reference
          \cs_if_exist:cTF{autoref}{
            \l__stex_refs_pre_tl\autoref{sref_sym_\l_stex_get_symbol_uri_str}\l__stex_refs_post_tl
          }{
            \l__stex_refs_pre_tl\ref{sref_sym_\l_stex_get_symbol_uri_str}\l__stex_refs_post_tl
          }
        }{
          % URL
          \if_bool:N \c__stex_refs_hyperref_bool {
            \exp_args:Nx \href{\use:c{sref_sym_url_\l_stex_get_symbol_uri_str _str}}{\l__stex_refs_fallback_tl}
          }{
            \l__stex_refs_fallback_tl
          }
        }
      }
    }
    \l_tmpa_tl
  }{
    % TODO
  }
}

\cs_new_protected:Npn \srefsymuri #1 #2 {
  \hyperref[sref_sym_#1]{#2}
}


%%%%%%%%%%%%%   modules.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/unknownmodule}{
  No~module~#1~found
}
\msg_new:nnn{stex}{error/syntax}{
  Syntax~error:~#1
}
\msg_new:nnn{stex}{error/siglanguage}{
  Module~#1~declares~signature~#2,~but~does~not~
  declare~its~language
}

\msg_new:nnn{stex}{error/conflictingmodules}{
  Conflicting~imports~for~module~#1
}
\str_new:N \l_stex_current_module_str
\seq_new:N \l_stex_all_modules_seq
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \str_if_empty:NTF \l_stex_current_module_str
    \prg_return_false: \prg_return_true:
}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \tl_gput_right:cn {c_stex_module_\l_stex_current_module_str _code} { #1 }
}
\cs_new_protected:Npn \STEXexport {
  \begingroup
  \newlinechar=-1\relax
  \endlinechar=-1\relax
  %\catcode`\ = 9\relax
  \expandafter\endgroup\STEXexport:n
}
\cs_new_protected:Nn \STEXexport:n {
  \ignorespaces #1
  \stex_add_to_current_module:n { \ignorespaces #1 }
  \stex_smsmode_do:
}
\stex_deactivate_macro:Nn \STEXexport {module~environments}
\cs_new_protected:Nn \stex_add_constant_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \seq_gput_right:co {c_stex_module_\l_stex_current_module_str _constants} { \l_tmpa_str }
}

\cs_new_protected:Nn \stex_collect_imports:n {
  \seq_clear:N \l_stex_collect_imports_seq
  \__stex_modules_collect_imports:n {#1}
}
\cs_new_protected:Nn \__stex_modules_collect_imports:n {
  \seq_map_inline:cn {c_stex_module_#1_imports} {
    \seq_if_in:NnF \l_stex_collect_imports_seq { ##1 } {
      \__stex_modules_collect_imports:n { ##1 }
    }
  }
  \seq_if_in:NnF \l_stex_collect_imports_seq { #1 } {
    \seq_put_right:Nx \l_stex_collect_imports_seq { #1 }
  }
}
\cs_new_protected:Nn \stex_add_import_to_current_module:n {
  \str_set:Nx \l_tmpa_str { #1 }
  \exp_args:Nno
  \seq_if_in:cnF{c_stex_module_\l_stex_current_module_str _imports}\l_tmpa_str{
    \seq_gput_right:co{c_stex_module_\l_stex_current_module_str _imports}\l_tmpa_str
  }
}
\cs_new_protected:Nn \stex_modules_compute_namespace:nN {
  \str_set:Nx \l_tmpa_str { #1 }
  \seq_set_eq:NN \l_tmpa_seq #2
  % split off file extension
  \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
  \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
  \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
  \seq_put_right:No \l_tmpa_seq \l_tmpb_str

  \bool_set_true:N \l_tmpa_bool
  \bool_while_do:Nn \l_tmpa_bool {
    \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:No \str_case:nnTF { \l_tmpb_str } {
      {source} { \bool_set_false:N \l_tmpa_bool }
    }{}{
      \seq_if_empty:NT \l_tmpa_seq {
        \bool_set_false:N \l_tmpa_bool
      }
    }
  }

  \stex_path_to_string:NN \l_tmpa_seq \l_stex_modules_subpath_str
  \str_if_empty:NTF \l_stex_modules_subpath_str {
    \str_set_eq:NN \l_stex_modules_ns_str \l_tmpa_str
  }{
    \str_set:Nx \l_stex_modules_ns_str {
      \l_tmpa_str/\l_stex_modules_subpath_str
    }
  }
}
\str_new:N \l_stex_modules_ns_str
\str_new:N \l_stex_modules_subpath_str
\cs_new_protected:Nn \stex_modules_current_namespace: {
  \str_clear:N \l_stex_modules_subpath_str
  \prop_if_exist:NTF \l_stex_current_repository_prop {
    \prop_get:NnN \l_stex_current_repository_prop { ns } \l_tmpa_str
    \stex_modules_compute_namespace:nN \l_tmpa_str \g_stex_currentfile_seq
  }{
    % split off file extension
    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
    \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq . \l_tmpb_str
    \seq_get_left:NN \l_tmpb_seq \l_tmpb_str
    \seq_put_right:No \l_tmpa_seq \l_tmpb_str
    \str_set:Nx \l_stex_modules_ns_str {
      file:/\stex_path_to_string:N \l_tmpa_seq
    }
  }
}
\keys_define:nn { stex / module } {
  title         .tl_set:N     = \smoduletitle ,
  type          .str_set_x:N  = \smoduletype ,
  id            .str_set_x:N  = \smoduleid ,
  ns            .str_set_x:N  = \l_stex_module_ns_str ,
  lang          .str_set_x:N  = \l_stex_module_lang_str ,
  sig           .str_set_x:N  = \l_stex_module_sig_str ,
  creators      .str_set_x:N  = \l_stex_module_creators_str ,
  contributors  .str_set_x:N  = \l_stex_module_contributors_str ,
  meta          .str_set_x:N  = \l_stex_module_meta_str ,
  srccite       .str_set_x:N  = \l_stex_module_srccite_str
}

\cs_new_protected:Nn \__stex_modules_args:n {
  \str_clear:N \smoduletitle
  \str_clear:N \smoduletype
  \str_clear:N \smoduleid
  \str_clear:N \l_stex_module_ns_str
  \str_clear:N \l_stex_module_lang_str
  \str_clear:N \l_stex_module_sig_str
  \str_clear:N \l_stex_module_creators_str
  \str_clear:N \l_stex_module_contributors_str
  \str_clear:N \l_stex_module_meta_str
  \str_clear:N \l_stex_module_srccite_str
  \keys_set:nn { stex / module } { #1 }
}


\cs_new_protected:Nn \stex_module_setup:nn {
  \str_set:Nx \l_stex_module_name_str { #2 }
  \__stex_modules_args:n { #1 }
  \stex_if_in_module:TF {
    % Nested module
    \prop_get:cnN {c_stex_module_\l_stex_current_module_str _prop}
      { ns } \l_stex_module_ns_str
    \str_set:Nx \l_stex_module_name_str {
      \prop_item:cn {c_stex_module_\l_stex_current_module_str _prop}
        { name } / \l_stex_module_name_str
    }
  }{
    % not nested:
    \str_if_empty:NT \l_stex_module_ns_str {
      \stex_modules_current_namespace:
      \str_set_eq:NN \l_stex_module_ns_str \l_stex_modules_ns_str
      \exp_args:NNNo \seq_set_split:Nnn \l_tmpa_seq
          / {\l_stex_module_ns_str}
      \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
      \str_if_eq:NNT \l_tmpa_str \l_stex_module_name_str {
        \str_set:Nx \l_stex_module_ns_str {
          \stex_path_to_string:N \l_tmpa_seq
        }
      }
    }
  }
  \str_if_empty:NT \l_stex_module_lang_str {
    \seq_get_right:NN \g_stex_currentfile_seq \l_tmpa_str
    \seq_set_split:NnV \l_tmpa_seq . \l_tmpa_str
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str % .tex
    \seq_pop_left:NN \l_tmpa_seq \l_tmpa_str % <filename>
    \seq_if_empty:NF \l_tmpa_seq { %remaining element should be language
      \stex_debug:nn{modules} {Language~\l_stex_module_lang_str~
        inferred~from~file~name}
      \seq_pop_left:NN \l_tmpa_seq \l_stex_module_lang_str
    }
  }

  \stex_if_smsmode:F { \str_if_empty:NF \l_stex_module_lang_str {
    \prop_get:NVNTF \c_stex_languages_prop \l_stex_module_lang_str
      \l_tmpa_str {
        \ltx@ifpackageloaded{babel}{
          \exp_args:Nx \selectlanguage { \l_tmpa_str }
        }{}
      } {
        \msg_error:nnx{stex}{error/unknownlanguage}{\l_tmpa_str}
      }
  }}
  \str_if_empty:NTF \l_stex_module_sig_str {
    \exp_args:Nnx \prop_gset_from_keyval:cn {
      c_stex_module_\l_stex_module_ns_str?\l_stex_module_name_str _prop
    } {
      name      = \l_stex_module_name_str ,
      ns        = \l_stex_module_ns_str ,
      file      = \exp_not:o { \g_stex_currentfile_seq } ,
      lang      = \l_stex_module_lang_str ,
      sig       = \l_stex_module_sig_str ,
      meta      = \l_stex_module_meta_str
    }
    \seq_clear:c {c_stex_module_\l_stex_module_ns_str?\l_stex_module_name_str _imports}
    \seq_clear:c {c_stex_module_\l_stex_module_ns_str?\l_stex_module_name_str _fields}
    \seq_clear:c {c_stex_module_\l_stex_module_ns_str?\l_stex_module_name_str _constants}
    \tl_clear:c {c_stex_module_\l_stex_module_ns_str?\l_stex_module_name_str _code}
    \str_set:Nx\l_stex_current_module_str{\l_stex_module_ns_str?\l_stex_module_name_str}
    \str_if_empty:NT \l_stex_module_meta_str {
      \str_set:Nx \l_stex_module_meta_str {
        \c_stex_metatheory_ns_str ? Metatheory
      }
    }
    \str_if_eq:VnF \l_stex_module_meta_str {NONE} {
      \bool_set_true:N \l_stex_in_meta_bool
      \exp_args:Nx \stex_add_to_current_module:n {
        \bool_set_true:N \l_stex_in_meta_bool
        \stex_activate_module:n {\l_stex_module_meta_str}
        \bool_set_false:N \l_stex_in_meta_bool
      }
      \stex_activate_module:n {\l_stex_module_meta_str}
      \bool_set_false:N \l_stex_in_meta_bool
    }
  }{
    \str_if_empty:NT \l_stex_module_lang_str {
      \msg_error:nnxx{stex}{error/siglanguage}{
        \l_stex_module_ns_str?\l_stex_module_name_str
      }{\l_stex_module_sig_str}
    }

    \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str
    \seq_set_split:NnV \l_tmpb_seq . \l_tmpa_str
    \seq_pop_right:NN \l_tmpb_seq \l_tmpa_str % .tex
    \seq_pop_left:NN \l_tmpb_seq \l_tmpa_str % <filename>
    \str_set:Nx \l_tmpa_str {
      \stex_path_to_string:N \l_tmpa_seq /
      \l_tmpa_str . \l_stex_module_sig_str .tex
    }
    \IfFileExists \l_tmpa_str {
      \exp_args:No \stex_file_in_smsmode:nn { \l_tmpa_str } {
        \str_clear:N \l_stex_current_module_str
        \seq_clear:N \l_stex_all_modules_seq
        \stex_debug:nn{modules}{Loading~signature~\l_tmpa_str}
      }
    }{
      \msg_error:nnx{stex}{error/unknownmodule}{for~signature~\l_tmpa_str}
    }
    \stex_if_smsmode:F {
      \stex_activate_module:n {
        \l_stex_module_ns_str ? \l_stex_module_name_str
      }
    }
    \str_set:Nx\l_stex_current_module_str{\l_stex_module_ns_str?\l_stex_module_name_str}
  }
}
\int_new:N \l_stex_module_group_depth_int
\cs_new_protected:Nn \__stex_modules_begin_module: {
  \stex_reactivate_macro:N \STEXexport
  \stex_reactivate_macro:N \importmodule
  \stex_reactivate_macro:N \symdecl
  \stex_reactivate_macro:N \notation
  \stex_reactivate_macro:N \symdef

  \stex_debug:nn{modules}{
    New~module:\\
    Namespace:~\l_stex_module_ns_str\\
    Name:~\l_stex_module_name_str\\
    Language:~\l_stex_module_lang_str\\
    Signature:~\l_stex_module_sig_str\\
    Metatheory:~\l_stex_module_meta_str\\
    File:~\stex_path_to_string:N \g_stex_currentfile_seq
  }

  \seq_put_right:Nx \l_stex_all_modules_seq {
    \l_stex_module_ns_str ? \l_stex_module_name_str
  }


  \stex_if_smsmode:F{
    \begin{stex_annotate_env} {theory} {
      \l_stex_module_ns_str ? \l_stex_module_name_str
    }

    \stex_annotate_invisible:nnn{header}{} {
      \stex_annotate:nnn{language}{ \l_stex_module_lang_str }{}
      \stex_annotate:nnn{signature}{ \l_stex_module_sig_str }{}
      \str_if_eq:VnF \l_stex_module_meta_str {NONE} {
        \stex_annotate:nnn{metatheory}{ \l_stex_module_meta_str }{}
      }
      \str_if_empty:NF \smoduletype {
        \stex_annotate:nnn{type}{\smoduletype}{}
      }
    }
  }
  \int_set:Nn \l_stex_module_group_depth_int {\currentgrouplevel}
  % TODO: Inherit metatheory for nested modules?
}
\iffalse \end{stex_annotate_env} \fi %^^A make syntax highlighting work again
\cs_new_protected:Nn \__stex_modules_end_module: {
  %^^A \prop_new:c { \l_tmpa_str }
  \stex_debug:nn{modules}{Closing~module~\prop_item:cn {c_stex_module_\l_stex_current_module_str _prop} { name }}
}
\iffalse \begin{stex_annotate_env} \fi %^^A make syntax highlighting work again
\NewDocumentEnvironment { smodule } { O{} m } {
  \stex_module_setup:nn{#1}{#2}
  \par
  \stex_if_smsmode:F{
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \smoduletype {
      \tl_if_exist:cT {__stex_modules_smodule_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_modules_smodule_##1_start:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_modules_smodule_start:
    }{
      \l_tmpa_tl
    }
  }
  \__stex_modules_begin_module:
  \stex_ref_new_doc_target:n \smoduleid
  \stex_smsmode_do:
} {
  \__stex_modules_end_module:
  \stex_if_smsmode:TF {
  }{
    \end{stex_annotate_env}
    \clist_set:No \l_tmpa_clist \smoduletype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_modules_smodule_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_modules_smodule_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_modules_smodule_end:
    }{
      \l_tmpa_tl
    }
  }
}

\cs_new_protected:Nn \__stex_modules_smodule_start: {}
\cs_new_protected:Nn \__stex_modules_smodule_end: {}

\newcommand\stexpatchmodule[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_modules_smodule_start: { #2 }
      \tl_set:Nn \__stex_modules_smodule_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_modules_smodule_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_modules_smodule_#1_end:\endcsname{ #3 }
    }
}

\NewDocumentCommand \STEXModule { m } {
  \exp_args:NNx \str_set:Nn \l_tmpa_str { #1 }
  \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
  \tl_set:Nn \l_tmpa_tl {
    \msg_error:nnx{stex}{error/unknownmodule}{#1}
  }
  \seq_map_inline:Nn \l_stex_all_modules_seq {
    \str_set:Nn \l_tmpb_str { ##1 }
    \str_if_eq:eeT { \l_tmpa_str } {
      \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
    } {
      \seq_map_break:n {
        \tl_set:Nn \l_tmpa_tl {
          \stex_invoke_module:n { ##1 }
        }
      }
    }
  }
  \l_tmpa_tl
}

\cs_new_protected:Nn \stex_invoke_module:n {
  \stex_debug:nn{modules}{Invoking~module~#1}
  \peek_charcode_remove:NTF ! {
    \__stex_modules_invoke_uri:nN { #1 }
  } {
    \peek_charcode_remove:NTF ? {
      \__stex_modules_invoke_symbol:nn { #1 }
    } {
      \msg_error:nnx{stex}{error/syntax}{
        ?~or~!~expected~after~
        \c_backslash_str STEXModule{#1}
      }
    }
  }
}

\cs_new_protected:Nn \__stex_modules_invoke_uri:nN {
  \str_set:Nn #2 { #1 }
}

\cs_new_protected:Nn \__stex_modules_invoke_symbol:nn {
  \stex_invoke_symbol:n{#1?#2}
}
\bool_new:N \l_stex_in_meta_bool
\bool_set_false:N \l_stex_in_meta_bool
\cs_new_protected:Nn \stex_activate_module:n {
  \stex_debug:nn{modules}{Activating~module~#1}
  \seq_if_in:NnT \l_stex_implicit_morphisms_seq { #1 }{
    \msg_error:nnn{stex}{error/conflictingmodules}{ #1 }
  }
  \exp_args:NNx \seq_if_in:NnF \l_stex_all_modules_seq { #1 } {
    \seq_put_right:Nx \l_stex_all_modules_seq { #1 }
    \use:c{ c_stex_module_#1_code }
  }
}

%%%%%%%%%%%%%   inheritance.dtx   %%%%%%%%%%%%%

\tl_new:N \g_stex_smsmode_allowedmacros_tl
\tl_new:N \g_stex_smsmode_allowedmacros_escape_tl
\seq_new:N \g_stex_smsmode_allowedenvs_seq

\tl_set:Nn \g_stex_smsmode_allowedmacros_tl {
  \makeatletter
  \makeatother
  \ExplSyntaxOn
  \ExplSyntaxOff
  \rustexBREAK
}

\tl_set:Nn \g_stex_smsmode_allowedmacros_escape_tl {
  \symdef
  \importmodule
  \notation
  \symdecl
  \STEXexport
  \inlineass
  \inlinedef
  \inlineex
  \endinput
}

\exp_args:NNx \seq_set_from_clist:Nn \g_stex_smsmode_allowedenvs_seq {
  \tl_to_str:n {
    smodule,
    copymodule,
    interpretmodule
    sdefinition,
    sexample,
    sassertion,
    sparagraph
  }
}
\bool_new:N \g__stex_smsmode_bool
\bool_set_false:N \g__stex_smsmode_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g__stex_smsmode_bool \prg_return_true: \prg_return_false:
}
\cs_new_protected:Nn \stex_in_smsmode:nn {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_eq:cN { l__stex_smsmode_#1_bool } \g__stex_smsmode_bool
    \bool_gset_true:N \g__stex_smsmode_bool
    #2
    \bool_gset_eq:Nc \g__stex_smsmode_bool { l__stex_smsmode_#1_bool }
  }
  \box_clear:N \l_tmpa_box
}

\quark_new:N \q__stex_smsmode_break

\cs_new_protected:Nn \stex_file_in_smsmode:nn {
 % \tl_clear:N \l__stex_smsmode_filecontent_tl
 % \ior_open:Nn \c__stex_smsmode_ior {#1}
 % \ior_map_inline:Nn \c__stex_smsmode_ior {
 %   \tl_put_right:Nn \l__stex_smsmode_filecontent_tl { ##1 }
 % }
 % \ior_close:N \c__stex_smsmode_ior
  \stex_filestack_push:n{#1}
  \stex_in_smsmode:nn{#1} {
    #2
    \everyeof{\q__stex_smsmode_break\noexpand}
    \expandafter\expandafter\expandafter
    \stex_smsmode_do:
    \csname @ @ input\endcsname "#1"\relax
    %\expandafter \stex_smsmode_do: \l__stex_smsmode_filecontent_tl
  }
  \stex_filestack_pop:
}
\cs_new_protected:Npn \stex_smsmode_do: {
  \stex_if_smsmode:T {
    \__stex_smsmode_do:w
  }
}
\cs_new_protected:Npn \__stex_smsmode_do:w #1 {
  \exp_args:Nx \tl_if_empty:nTF { \tl_tail:n{ #1 }}{
    \expandafter\if\expandafter\relax\noexpand#1
      \expandafter\__stex_smsmode_do_aux:N\expandafter#1
    \else\expandafter\__stex_smsmode_do:w\fi
  }{
    \__stex_smsmode_do:w %#1
  }
}
\cs_new_protected:Nn \__stex_smsmode_do_aux:N {
  \cs_if_eq:NNF #1 \q__stex_smsmode_break {
    \tl_if_in:NnTF \g_stex_smsmode_allowedmacros_tl {#1} {
      #1\__stex_smsmode_do:w
    }{
      \tl_if_in:NnTF \g_stex_smsmode_allowedmacros_escape_tl {#1} {
        #1
      }{
        \cs_if_eq:NNTF \begin #1 {
          \__stex_smsmode_check_begin:n
        }{
          \cs_if_eq:NNTF \end #1 {
            \__stex_smsmode_check_end:n
          }{
            \__stex_smsmode_do:w
          }
        }
      }
    }
  }
}

\cs_new_protected:Nn \__stex_smsmode_check_begin:n {
  \seq_if_in:NxTF \g_stex_smsmode_allowedenvs_seq { \detokenize{#1} }{
    \begin{#1}
  }{
    \__stex_smsmode_do:w
  }
}
\cs_new_protected:Nn \__stex_smsmode_check_end:n {
  \seq_if_in:NxTF \g_stex_smsmode_allowedenvs_seq { \detokenize{#1} }{
    \end{#1}\__stex_smsmode_do:w
  }{
    \str_if_eq:nnTF{#1}{document}{\endinput}{\__stex_smsmode_do:w}
  }
}

\cs_new_protected:Nn \stex_import_module_uri:nn {
  \str_set:Nx \l_stex_import_archive_str { #1 }
  \str_set:Nn \l_stex_import_path_str { #2 }

  \exp_args:NNNo \seq_set_split:Nnn \l_tmpb_seq ? { \l_stex_import_path_str }
  \seq_pop_right:NN \l_tmpb_seq \l_stex_import_name_str
  \str_set:Nx \l_stex_import_path_str { \seq_use:Nn \l_tmpb_seq ? }

  \stex_modules_current_namespace:
  \bool_lazy_all:nTF {
    {\str_if_empty_p:N \l_stex_import_archive_str}
    {\str_if_empty_p:N \l_stex_import_path_str}
    {\stex_if_module_exists_p:n { \l_stex_module_ns_str ? \l_stex_import_name_str } }
  }{
    \str_set_eq:NN \l_stex_import_path_str \l_stex_modules_subpath_str
    \str_set_eq:NN \l_stex_import_ns_str \l_stex_module_ns_str
  }{
    \str_if_empty:NT \l_stex_import_archive_str {
      \prop_if_exist:NT \l_stex_current_repository_prop {
        \prop_get:NnN \l_stex_current_repository_prop { id } \l_stex_import_archive_str
      }
    }
    \str_if_empty:NTF \l_stex_import_archive_str {
      \str_if_empty:NF \l_stex_import_path_str {
        \str_set:Nx \l_stex_import_ns_str {
          \l_stex_module_ns_str / \l_stex_import_path_str
        }
      }
    }{
      \stex_require_repository:n \l_stex_import_archive_str
      \prop_get:cnN { c_stex_mathhub_\l_stex_import_archive_str _manifest_prop } { ns }
        \l_stex_import_ns_str
      \str_if_empty:NF \l_stex_import_path_str {
        \str_set:Nx \l_stex_import_ns_str {
          \l_stex_import_ns_str / \l_stex_import_path_str
        }
      }
    }
  }
}
\str_new:N \l_stex_import_name_str
\str_new:N \l_stex_import_archive_str
\str_new:N \l_stex_import_path_str
\str_new:N \l_stex_import_ns_str
\cs_new_protected:Nn \stex_import_require_module:nnnn {
  \exp_args:Nx \stex_if_module_exists:nF { #1 ? #4 } {

    % archive
    \str_set:Nx \l_tmpa_str { #2 }
    \str_if_empty:NTF \l_tmpa_str {
      \seq_set_eq:NN \l_tmpa_seq \g_stex_currentfile_seq
    } {
      \stex_path_from_string:Nn \l_tmpb_seq { \l_tmpa_str }
      \seq_concat:NNN \l_tmpa_seq \c_stex_mathhub_seq \l_tmpb_seq
      \seq_put_right:Nn \l_tmpa_seq { source }
    }

    % path
    \str_set:Nx \l_tmpb_str { #3 }
    \str_if_empty:NTF \l_tmpb_str {
      \str_set:Nx \l_tmpa_str { \stex_path_to_string:N \l_tmpa_seq / #4 }

      \ltx@ifpackageloaded{babel} {
        \exp_args:NNx \prop_get:NnNF \c_stex_language_abbrevs_prop
            { \languagename } \l_tmpb_str {
              \msg_error:nnx{stex}{error/unknownlanguage}{\languagename}
            }
      } {
        \str_clear:N \l_tmpb_str
      }

      \stex_debug:nn{modules}{Checking~\l_tmpa_str.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
        \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.\l_tmpb_str.tex }
      }{
        \stex_debug:nn{modules}{Checking~\l_tmpa_str.tex}
        \IfFileExists{ \l_tmpa_str.tex }{
          \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.tex }
        }{
          % try english as default
          \stex_debug:nn{modules}{Checking~\l_tmpa_str.en.tex}
          \IfFileExists{ \l_tmpa_str.en.tex }{
            \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.en.tex }
          }{
            \msg_error:nnx{stex}{error/unknownmodule}{#1?#4}
          }
        }
      }

    } {
      \seq_set_split:NnV \l_tmpb_seq / \l_tmpb_str
      \seq_concat:NNN \l_tmpa_seq \l_tmpa_seq \l_tmpb_seq

      \ltx@ifpackageloaded{babel} {
        \exp_args:NNx \prop_get:NnNF \c_stex_language_abbrevs_prop
            { \languagename } \l_tmpb_str {
              \msg_error:nnx{stex}{error/unknownlanguage}{\languagename}
            }
      } {
        \str_clear:N \l_tmpb_str
      }

      \stex_path_to_string:NN \l_tmpa_seq \l_tmpa_str

      \stex_debug:nn{modules}{Checking~\l_tmpa_str/#4.\l_tmpb_str.tex}
      \IfFileExists{ \l_tmpa_str/#4.\l_tmpb_str.tex }{
        \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str/#4.\l_tmpb_str.tex }
      }{
        \stex_debug:nn{modules}{Checking~\l_tmpa_str/#4.tex}
        \IfFileExists{ \l_tmpa_str/#4.tex }{
          \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str/#4.tex }
        }{
          % try english as default
          \stex_debug:nn{modules}{Checking~\l_tmpa_str/#4.en.tex}
          \IfFileExists{ \l_tmpa_str/#4.en.tex }{
            \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str/#4.en.tex }
          }{
            \stex_debug:nn{modules}{Checking~\l_tmpa_str.\l_tmpb_str.tex}
            \IfFileExists{ \l_tmpa_str.\l_tmpb_str.tex }{
              \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.\l_tmpb_str.tex }
            }{
              \stex_debug:nn{modules}{Checking~\l_tmpa_str.tex}
              \IfFileExists{ \l_tmpa_str.tex }{
                \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.tex }
              }{
                % try english as default
                \stex_debug:nn{modules}{Checking~\l_tmpa_str.en.tex}
                \IfFileExists{ \l_tmpa_str.en.tex }{
                  \str_gset:Nx \g__stex_importmodule_file_str { \l_tmpa_str.en.tex }
                }{
                  \msg_error:nnx{stex}{error/unknownmodule}{#1?#4}
                }
              }
            }
          }
        }
      }
    }

    \exp_args:No \stex_file_in_smsmode:nn { \g__stex_importmodule_file_str } {
      \seq_clear:N \l_stex_all_modules_seq
      \str_clear:N \l_stex_current_module_str
      \str_set:Nx \l_tmpb_str { #2 }
      \str_if_empty:NF \l_tmpb_str {
        \stex_set_current_repository:n { #2 }
      }
      \stex_debug:nn{modules}{Loading~\g__stex_importmodule_file_str}
    }

    \stex_if_module_exists:nF { #1 ? #4 } {
      \msg_error:nnx{stex}{error/unknownmodule}{
        #1?#4~(in~file~\g__stex_importmodule_file_str)
      }
    }
  }
  \stex_activate_module:n { #1 ? #4 }
}
\NewDocumentCommand \importmodule { O{} m } {
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_debug:nn{modules}{Importing~module:~
    \l_stex_import_ns_str ? \l_stex_import_name_str
  }
  \stex_if_smsmode:F {
    \stex_import_require_module:nnnn
    { \l_stex_import_ns_str } { \l_stex_import_archive_str }
    { \l_stex_import_path_str } { \l_stex_import_name_str }
    \stex_annotate_invisible:nnn
      {import} {\l_stex_import_ns_str ? \l_stex_import_name_str} {}
  }
  \exp_args:Nx \stex_add_to_current_module:n {
    \stex_import_require_module:nnnn
    { \l_stex_import_ns_str } { \l_stex_import_archive_str }
    { \l_stex_import_path_str } { \l_stex_import_name_str }
  }
  \exp_args:Nx \stex_add_import_to_current_module:n {
    \l_stex_import_ns_str ? \l_stex_import_name_str
  }
  \stex_smsmode_do:
}
\stex_deactivate_macro:Nn \importmodule {module~environments}
\NewDocumentCommand \usemodule { O{} m } {
  \stex_if_smsmode:F {
    \stex_import_module_uri:nn { #1 } { #2 }
    \stex_import_require_module:nnnn
    { \l_stex_import_ns_str } { \l_stex_import_archive_str }
    { \l_stex_import_path_str } { \l_stex_import_name_str }
    \stex_annotate_invisible:nnn
      {usemodule} {\l_stex_import_ns_str ? \l_stex_import_name_str} {}
  }
  \stex_smsmode_do:
}

%%%%%%%%%%%%%   symbols.dtx   %%%%%%%%%%%%%


\seq_new:N \l_stex_all_symbols_seq
\NewDocumentCommand \STEXsymbol { m } {
  \stex_get_symbol:n { #1 }
  \exp_args:No
  \stex_invoke_symbol:n { \l_stex_get_symbol_uri_str }
}
\keys_define:nn { stex / symdecl } {
  name        .str_set_x:N  = \l_stex_symdecl_name_str ,
  local       .bool_set:N  = \l_stex_symdecl_local_bool ,
  args        .str_set_x:N  = \l_stex_symdecl_args_str ,
  type        .tl_set:N    = \l_stex_symdecl_type_tl ,
  align       .str_set:N    = \l_stex_symdecl_align_str , % TODO(?)
  gfc         .str_set:N    = \l_stex_symdecl_gfc_str , % TODO(?)
  specializes .str_set:N    = \l_stex_symdecl_specializes_str , % TODO(?)
  def         .tl_set:N    = \l_stex_symdecl_definiens_tl
}

\bool_new:N \l_stex_symdecl_make_macro_bool

\cs_new_protected:Nn \__stex_symdecl_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl
  \tl_clear:N \l_stex_symdecl_definiens_tl

  \keys_set:nn { stex / symdecl } { #1 }
}

\NewDocumentCommand \symdecl { s O{} m } {
  \__stex_symdecl_args:n { #2 }
  \IfBooleanTF #1 {
    \bool_set_false:N \l_stex_symdecl_make_macro_bool
  } {
    \bool_set_true:N \l_stex_symdecl_make_macro_bool
  }
  \stex_symdecl_do:n { #3 }
  \stex_smsmode_do:
}
\stex_deactivate_macro:Nn \symdecl {module~environments}
\cs_new_protected:Nn \stex_symdecl_do:n {
  \stex_if_in_module:F {
    % TODO throw error? some default namespace?
  }

  \str_if_empty:NT \l_stex_symdecl_name_str {
    \str_set:Nx \l_stex_symdecl_name_str { #1 }
  }

  \prop_if_exist:cT { l_stex_symdecl_
      \l_stex_current_module_str ?
      \l_stex_symdecl_name_str
    _prop
  }{
    % TODO throw error (beware of circular dependencies)
  }

  \prop_clear:N \l_tmpa_prop
  \prop_put:Nnx \l_tmpa_prop { module } { \l_stex_current_module_str }
  \seq_clear:N \l_tmpa_seq
  \prop_put:Nno \l_tmpa_prop { name } \l_stex_symdecl_name_str
  \prop_put:Nno \l_tmpa_prop { type } \l_stex_symdecl_type_tl

  \exp_args:No \stex_add_constant_to_current_module:n {
    \l_stex_symdecl_name_str
  }

  % arity/args
  \int_zero:N \l_tmpb_int

  \bool_set_true:N \l_tmpa_bool
  \str_map_inline:Nn \l_stex_symdecl_args_str {
    \token_case_meaning:NnF ##1 {
      0 {} 1 {} 2 {} 3 {} 4 {} 5 {} 6 {} 7 {} 8 {} 9 {}
      {\tl_to_str:n i} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n b} { \bool_set_false:N \l_tmpa_bool }
      {\tl_to_str:n a} {
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
      {\tl_to_str:n B} {
        \bool_set_false:N \l_tmpa_bool
        \int_incr:N \l_tmpb_int
      }
    }{
      \msg_set:nnn{stex}{error/wrongargs}{
        args~value~in~symbol~declaration~for~
        \l_stex_current_module_str ?
        \l_stex_symdecl_name_str ~
        needs~to~be~
        i,~a,~b~or~B,~but~##1~given
      }
      \msg_error:nn{stex}{error/wrongargs}
    }
  }
  \bool_if:NTF \l_tmpa_bool {
    % possibly numeric
    \str_if_empty:NTF \l_stex_symdecl_args_str {
      \prop_put:Nnn \l_tmpa_prop { args } {}
      \prop_put:Nnn \l_tmpa_prop { arity } { 0 }
    }{
      \int_set:Nn \l_tmpa_int { \l_stex_symdecl_args_str }
      \prop_put:Nnx \l_tmpa_prop { arity } { \int_use:N \l_tmpa_int }
      \str_clear:N \l_tmpa_str
      \int_step_inline:nn \l_tmpa_int {
        \str_put_right:Nn \l_tmpa_str i
      }
      \prop_put:Nnx \l_tmpa_prop { args } { \l_tmpa_str }
    }
  } {
    \prop_put:Nnx \l_tmpa_prop { args } { \l_stex_symdecl_args_str }
    \prop_put:Nnx \l_tmpa_prop { arity }
      { \str_count:N \l_stex_symdecl_args_str }
  }
  \prop_put:Nnx \l_tmpa_prop { assocs } { \int_use:N \l_tmpb_int }

  % semantic macro

  \bool_if:NT \l_stex_symdecl_make_macro_bool {
    \exp_args:Nx \stex_do_aftergroup:n {
      \tl_set:cn { #1 } { \stex_invoke_symbol:n {
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
      }}
    }

    \bool_if:NF \l_stex_symdecl_local_bool {
      \exp_args:Nx \stex_add_to_current_module:n {
        \tl_set:cn { #1 } { \stex_invoke_symbol:n {
          \l_stex_current_module_str ? \l_stex_symdecl_name_str
        } }
      }
    }
  }

  % add to all symbols

  \bool_if:NF \l_stex_symdecl_local_bool {
    \exp_args:Nx \stex_add_to_current_module:n {
      \seq_put_right:Nn \exp_not:N \l_stex_all_symbols_seq {
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
      }
    }
  }

  \stex_debug:nn{symbols}{New~symbol:~
    \l_stex_current_module_str ? \l_stex_symdecl_name_str^^J
    Type:~\exp_not:o { \l_stex_symdecl_type_tl }^^J
    Args:~\prop_item:Nn \l_tmpa_prop { args }
  }

  % circular dependencies require this:

  \prop_if_exist:cF {
    l_stex_symdecl_
    \l_stex_current_module_str ? \l_stex_symdecl_name_str
    _prop
  } {
    \prop_set_eq:cN {
      l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_symdecl_name_str
      _prop
    } \l_tmpa_prop
  }

  \seq_clear:c {
    l_stex_symdecl_
    \l_stex_current_module_str ? \l_stex_symdecl_name_str
    _notations
  }

  \bool_if:NF \l_stex_symdecl_local_bool {
    \exp_args:Nx
    \stex_add_to_current_module:n {
      \seq_clear:c {
        l_stex_symdecl_
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
        _notations
      }
      \prop_set_from_keyval:cn {
        l_stex_symdecl_
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
        _prop
      } {
        name      = \prop_item:Nn \l_tmpa_prop { name }       ,
        module    = \prop_item:Nn \l_tmpa_prop { module }     ,
        type      = \prop_item:Nn \l_tmpa_prop { type }       ,
        args      = \prop_item:Nn \l_tmpa_prop { args }       ,
        arity     = \prop_item:Nn \l_tmpa_prop { arity }      ,
        assocs    = \prop_item:Nn \l_tmpa_prop { assocs }
      }
    }
  }

  \stex_if_smsmode:TF {
    \bool_if:NF \l_stex_symdecl_local_bool {
    }
  }{
    \exp_args:Nx \stex_do_aftergroup:n {
        \seq_put_right:Nn \exp_not:N \l_stex_all_symbols_seq {
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
      }
    }
    \stex_if_do_html:T {
      \stex_annotate_invisible:nnn {symdecl} {
        \l_stex_current_module_str ? \l_stex_symdecl_name_str
      } {
        \tl_if_empty:NF \l_stex_symdecl_type_tl {\stex_annotate_invisible:nnn{type}{}{$\l_stex_symdecl_type_tl$}}
        \stex_annotate_invisible:nnn{args}{}{
          \prop_item:Nn \l_tmpa_prop { args }
        }
        \stex_annotate_invisible:nnn{macroname}{#1}{}
        \tl_if_empty:NF \l_stex_symdecl_definiens_tl {
          \stex_annotate_invisible:nnn{definiens}{}
            {$\l_stex_symdecl_definiens_tl$}
        }
      }
    }
  }
}
\str_new:N \l_stex_get_symbol_uri_str

\cs_new_protected:Nn \stex_get_symbol:n {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \__stex_symdecl_get_symbol_from_cs:n { #1 }
  }{
    % argument is a string
    % is it a command name?
    \cs_if_exist:cTF { #1 }{
      \cs_set_eq:Nc \l_tmpa_tl { #1 }
      \str_set:Nx \l_tmpa_str { \cs_argument_spec:N \l_tmpa_tl }
      \str_if_empty:NTF \l_tmpa_str {
        \exp_args:Nx \cs_if_eq:NNTF {
          \tl_head:N \l_tmpa_tl
        } \stex_invoke_symbol:n {
          \exp_args:No \__stex_symdecl_get_symbol_from_cs:n { \use:c { #1 } }
        }{
          \__stex_symdecl_get_symbol_from_string:n { #1 }
        }
      } {
        \__stex_symdecl_get_symbol_from_string:n { #1 }
      }
    }{
      % argument is not a command name
      \__stex_symdecl_get_symbol_from_string:n { #1 }
      % \l_stex_all_symbols_seq
    }
  }
}

\cs_new_protected:Nn \__stex_symdecl_get_symbol_from_string:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \bool_set_false:N \l_tmpa_bool
  \stex_if_in_module:T {
    \exp_args:Nno \seq_if_in:cnT {c_stex_module_\l_stex_current_module_str _constants} { \l_tmpa_str } {
      \bool_set_true:N \l_tmpa_bool
      \str_set:Nx \l_stex_get_symbol_uri_str {
        \l_stex_current_module_str ? #1
      }
    }
  }
  \bool_if:NF \l_tmpa_bool {
    \tl_set:Nn \l_tmpa_tl {
      \msg_set:nnn{stex}{error/unknownsymbol}{
        No~symbol~#1~found!
      }
      \msg_error:nn{stex}{error/unknownsymbol}
    }
    \str_set:Nn \l_tmpa_str { #1 }
    \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
    \seq_map_inline:Nn \l_stex_all_symbols_seq {
      \str_set:Nn \l_tmpb_str { ##1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
      } {
        \seq_map_break:n {
          \tl_set:Nn \l_tmpa_tl {
            \str_set:Nn \l_stex_get_symbol_uri_str {
              ##1
            }
          }
        }
      }
    }
    \l_tmpa_tl
  }
}

\cs_new_protected:Nn \__stex_symdecl_get_symbol_from_cs:n {
  \exp_args:NNx \tl_set:Nn \l_tmpa_tl
    { \tl_tail:N \l_tmpa_tl }
  \tl_if_single:NTF \l_tmpa_tl {
    \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
      \exp_after:wN \str_set:Nn \exp_after:wN
        \l_stex_get_symbol_uri_str \l_tmpa_tl
    }{
      % TODO
      % tail is not a single group
    }
  }{
    % TODO
    % tail is not a single group
  }
}
\keys_define:nn { stex / notation } {
  lang    .tl_set_x:N  = \l__stex_notation_lang_str ,
  variant .tl_set_x:N  = \l__stex_notation_variant_str ,
  prec    .str_set_x:N = \l__stex_notation_prec_str ,
  op      .tl_set:N    = \l__stex_notation_op_tl ,
  primary .bool_set:N  = \l__stex_notation_primary_bool ,
  primary .default:n   = {true} ,
  unknown .code:n      = \str_set:Nx
      \l__stex_notation_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_stex_notation_args:n {
  \str_clear:N \l__stex_notation_lang_str
  \str_clear:N \l__stex_notation_variant_str
  \str_clear:N \l__stex_notation_prec_str
  \tl_clear:N \l__stex_notation_op_tl
  \bool_set_false:N \l__stex_notation_primary_bool

  \keys_set:nn { stex / notation } { #1 }
}
\NewDocumentCommand \notation { O{} m } {
  \_stex_notation_args:n { #1 }
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \stex_get_symbol:n { #2 }
  \stex_notation_do:nn { \l_stex_get_symbol_uri_str }
}
\stex_deactivate_macro:Nn \notation {module~environments}
\cs_new_protected:Nn \stex_notation_do:nn {
  \let\l_stex_current_symbol_str\relax
  \prop_set_eq:Nc \l_tmpa_prop {
    l_stex_symdecl_ #1 _prop
  }

  \prop_clear:N \l_tmpb_prop
  \prop_put:Nno \l_tmpb_prop { symbol } { #1 }
  \prop_put:Nno \l_tmpb_prop { language } \l__stex_notation_lang_str
  \prop_put:Nno \l_tmpb_prop { variant } \l__stex_notation_variant_str

  % precedences
  \seq_clear:N \l_tmpb_seq
  \exp_args:NNno
  \str_if_empty:NTF \l__stex_notation_prec_str {
    \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
    \int_compare:nNnTF \l_tmpa_str = 0 {
      \exp_args:NNnx
      \prop_put:Nno \l_tmpb_prop { opprec }
        { \neginfprec }
    }{
      \prop_put:Nnn \l_tmpb_prop { opprec } { 0 }
    }
  } {
    \str_if_eq:onTF \l__stex_notation_prec_str {nobrackets}{
      \exp_args:NNnx
      \prop_put:Nno \l_tmpb_prop { opprec }
        { \neginfprec }
      \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
      \int_step_inline:nn { \l_tmpa_str } {
        \exp_args:NNx
        \seq_put_right:Nn \l_tmpb_seq { \infprec }
      }
    }{
      \seq_set_split:NnV \l_tmpa_seq ; \l__stex_notation_prec_str
      \seq_pop_left:NNTF \l_tmpa_seq \l_tmpa_str {
        \prop_put:Nno \l_tmpb_prop { opprec } \l_tmpa_str
        \seq_pop_left:NNT \l_tmpa_seq \l_tmpa_str {
          \exp_args:NNNo \exp_args:NNno \seq_set_split:Nnn
            \l_tmpa_seq {\tl_to_str:n{x} } { \l_tmpa_str }
          \seq_map_inline:Nn \l_tmpa_seq {
            \seq_put_right:Nn \l_tmpb_seq { ##1 }
          }
        }
        \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
      }{
        \prop_get:NnN \l_tmpa_prop { arity } \l_tmpa_str
        \int_compare:nNnTF \l_tmpa_str = 0 {
          \exp_args:NNnx
          \prop_put:Nno \l_tmpb_prop { opprec }
            { \infprec }
        }{
          \prop_put:Nnn \l_tmpb_prop { opprec } { 0 }
        }
      }
    }
  }

  \seq_set_eq:NN \l_tmpa_seq \l_tmpb_seq
  \int_step_inline:nn { \l_tmpa_str } {
    \seq_pop_left:NNF \l_tmpa_seq \l_tmpb_str {
      \exp_args:NNx
      \seq_put_right:Nn \l_tmpb_seq {
        \prop_item:Nn \l_tmpb_prop { opprec }
      }
    }
  }

  \prop_put:Nno \l_tmpb_prop { argprecs } \l_tmpb_seq
  \tl_clear:N \l_tmpa_tl

  \int_compare:nNnTF \l_tmpa_str = 0 {
    \exp_args:NNe
    \cs_set:Npn \l__stex_notation_macrocode_cs {
      \_stex_term_math_oms:nnnn { \l_stex_current_symbol_str }
        { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
        { \prop_item:Nn \l_tmpb_prop { opprec } }
        { \exp_not:n { #2 } }
    }
    \__stex_notation_final:
  }{
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpb_str
    \str_if_in:NnTF \l_tmpb_str b {
      \exp_args:Nne \use:nn
      {
      \cs_generate_from_arg_count:NNnn \l__stex_notation_macrocode_cs
      \cs_set:Npn \l_tmpa_str } { {
        \_stex_term_math_omb:nnnn { \l_stex_current_symbol_str }
          { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
          { \prop_item:Nn \l_tmpb_prop { opprec } }
          { \exp_not:n { #2 } }
      }}
    }{
      \str_if_in:NnTF \l_tmpb_str B {
        \exp_args:Nne \use:nn
        {
        \cs_generate_from_arg_count:NNnn \l__stex_notation_macrocode_cs
        \cs_set:Npn \l_tmpa_str } { {
          \_stex_term_math_omb:nnnn { \l_stex_current_symbol_str }
            { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
            { \prop_item:Nn \l_tmpb_prop { opprec } }
            { \exp_not:n { #2 } }
        } }
      }{
        \exp_args:Nne \use:nn
        {
        \cs_generate_from_arg_count:NNnn \l__stex_notation_macrocode_cs
        \cs_set:Npn \l_tmpa_str } { {
          \_stex_term_math_oma:nnnn { \l_stex_current_symbol_str }
            { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
            { \prop_item:Nn \l_tmpb_prop { opprec } }
            { \exp_not:n { #2 } }
        } }
      }
    }

    \int_zero:N \l_tmpa_int
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
    \__stex_notation_arguments:
  }
}
\cs_new_protected:Nn \__stex_notation_arguments: {
  \int_incr:N \l_tmpa_int
  \str_if_empty:NTF \l_tmpa_str {
    \__stex_notation_final:
  }{
    \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
    \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
    \str_if_eq:VnTF \l_tmpb_str a {
      \__stex_notation_argument_assoc:n
    }{
      \str_if_eq:VnTF \l_tmpb_str B {
        \__stex_notation_argument_assoc:n
      }{
        \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
        \tl_put_right:Nx \l_tmpa_tl {
          { \_stex_term_math_arg:nnn
            { \int_use:N \l_tmpa_int }
            { \l_tmpb_str }
            { ####\int_use:N \l_tmpa_int }
          }
        }
        \__stex_notation_arguments:
      }
    }
  }
}
\cs_new_protected:Nn \__stex_notation_argument_assoc:n {
  \seq_pop_left:NN \l_tmpa_seq \l_tmpb_str
  \cs_set:Npn \l_tmpa_cs ##1 ##2 { #1 }
  \tl_put_right:Nx \l_tmpa_tl {
    { \_stex_term_math_assoc_arg:nnnn
      { \int_use:N \l_tmpa_int }
      { \l_tmpb_str }
      \exp_args:No \exp_not:n
      {\exp_after:wN { \l_tmpa_cs {####1} {####2} } }
      { ####\int_use:N \l_tmpa_int }
    }
  }
  \__stex_notation_arguments:
}
\cs_new_protected:Nn \__stex_notation_final: {
  \prop_get:NnN \l_tmpa_prop { arity } \l_tmpb_str
  \prop_get:NnN \l_tmpb_prop { symbol } \l_tmpa_str
  \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:cNnn {
      stex_notation_ \l_tmpa_str \c_hash_str
      \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
      _cs
    }
    \cs_set:Npn \l_tmpb_str } { {
      \exp_after:wN \exp_after:wN \exp_after:wN
      \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN
      { \exp_after:wN \l__stex_notation_macrocode_cs \l_tmpa_tl }
  } }

  \tl_if_empty:NF \l__stex_notation_op_tl {
    \cs_set:cpx {
      stex_op_notation_ \l_tmpa_str \c_hash_str
      \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
      _cs
    } {
      \_stex_term_oms:nnn {
        \l_tmpa_str \c_hash_str \l__stex_notation_variant_str \c_hash_str
        \l__stex_notation_lang_str
      }{
        \l_tmpa_str
      }{ \comp{ \exp_args:No \exp_not:n { \l__stex_notation_op_tl } } }
    }
  }

  \exp_args:Ne
  \stex_add_to_current_module:n {
    \cs_generate_from_arg_count:cNnn {
      stex_notation_ \l_tmpa_str \c_hash_str
      \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
      _cs
    } \cs_set:Npn {\l_tmpb_str} {
        \exp_after:wN \exp_after:wN \exp_after:wN
        \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN
        { \exp_after:wN \l__stex_notation_macrocode_cs \l_tmpa_tl }
    }
    \tl_if_empty:NF \l__stex_notation_op_tl {
      \cs_set:cpn {
        stex_op_notation_ \l_tmpa_str \c_hash_str
        \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
        _cs
      } {
        \_stex_term_oms:nnn {
          \l_tmpa_str \c_hash_str \l__stex_notation_variant_str \c_hash_str
          \l__stex_notation_lang_str
        }{
          \l_tmpa_str
        }{ \comp{ \exp_args:No \exp_not:n { \l__stex_notation_op_tl } } }
      }
    }
  }

  \seq_put_right:cx {
    l_stex_symdecl_
      \prop_item:Nn \l_tmpb_prop { symbol }
    _notations
  } {
    \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
  }

  \stex_debug:nn{symbols}{
    Notation~\l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
    ~for~\prop_item:Nn \l_tmpb_prop { symbol }^^J
    Operator~precedence:~
      \prop_item:Nn \l_tmpb_prop { opprec }^^J
    Argument~precedences:~
      \seq_use:Nn \l_tmpa_seq {,~}^^J
    Notation: \cs_meaning:c {
      stex_notation_ \l_tmpa_str \c_hash_str
      \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
      _cs
    }
  }

  \prop_set_eq:cN {
    l_stex_notation_ \l_tmpa_str \c_hash_str \l__stex_notation_variant_str
      \c_hash_str \l__stex_notation_lang_str _prop
  } \l_tmpb_prop

  \exp_args:Ne
  \stex_add_to_current_module:n {
    \seq_put_right:cn {
      l_stex_symdecl_
        \prop_item:Nn \l_tmpb_prop { symbol }
      _notations
    } {
      \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str
    }
    \prop_set_from_keyval:cn {
      l_stex_notation_ \l_tmpa_str \c_hash_str \l__stex_notation_variant_str
        \c_hash_str \l__stex_notation_lang_str _prop
    } {
      symbol    = \prop_item:Nn \l_tmpb_prop { symbol }     ,
      language  = \prop_item:Nn \l_tmpb_prop { language }   ,
      variant   = \prop_item:Nn \l_tmpb_prop { variant }    ,
      opprec    = \prop_item:Nn \l_tmpb_prop { opprec }     ,
      argprecs  = \prop_item:Nn \l_tmpb_prop { argprecs }   ,
    }
  }

  \stex_if_smsmode:TF {
  }{

    % HTML annotations
    \stex_if_do_html:T {
      \stex_annotate_invisible:nnn { notation }
      { \prop_item:Nn \l_tmpb_prop { symbol } } {
        \stex_annotate_invisible:nnn { notationfragment }
          { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }{}
        \prop_get:NnN \l_tmpb_prop { argprecs } \l_tmpa_seq
        \stex_annotate_invisible:nnn { precedence }
          { \prop_item:Nn \l_tmpb_prop { opprec };
            \seq_use:Nn \l_tmpa_seq { x }
          }{}

        \int_zero:N \l_tmpa_int
        \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
        \tl_clear:N \l_tmpa_tl
        \int_step_inline:nn { \prop_item:Nn \l_tmpa_prop { arity } }{
          \int_incr:N \l_tmpa_int
          \str_set:Nx \l_tmpb_str { \str_head:N \l_tmpa_str }
          \str_set:Nx \l_tmpa_str { \str_tail:N \l_tmpa_str }
          \str_if_eq:VnTF \l_tmpb_str a {
            \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
              \c_hash_str \c_hash_str \int_use:N \l_tmpa_int a ,
              \c_hash_str \c_hash_str \int_use:N \l_tmpa_int b
            } }
          }{
            \str_if_eq:VnTF \l_tmpb_str B {
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int a ,
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int b
              } }
            }{
              \tl_set:Nx \l_tmpa_tl { \l_tmpa_tl {
                \c_hash_str \c_hash_str \int_use:N \l_tmpa_int
              } }
            }
          }
        }
        \stex_annotate_invisible:nnn { notationcomp }{}{
          \str_set:Nx \l_stex_current_symbol_str {\prop_item:Nn \l_tmpb_prop { symbol }}
          $ \exp_args:Nno \use:nn { \use:c {
            stex_notation_ \l_stex_current_symbol_str
            \c_hash_str \l__stex_notation_variant_str
            \c_hash_str \l__stex_notation_lang_str _cs
          } } { \l_tmpa_tl } $
        }
      }
    }
  }
  \stex_smsmode_do:
}
\keys_define:nn { stex / setnotation } {
  lang    .tl_set_x:N  = \l__stex_notation_lang_str ,
  variant .tl_set_x:N  = \l__stex_notation_variant_str ,
  unknown .code:n      = \str_set:Nx
      \l__stex_notation_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \_stex_setnotation_args:n {
  \str_clear:N \l__stex_notation_lang_str
  \str_clear:N \l__stex_notation_variant_str
  \keys_set:nn { stex / setnotation } { #1 }
}

\NewDocumentCommand \setnotation {m m} {
  \stex_get_symbol:n { #1 }
  \_stex_setnotation_args:n { #2 }
  \exp_args:Nnx \seq_if_in:cnTF { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
    { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }{
      \exp_args:Nnx \seq_remove_all:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
        { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
      \exp_args:Nnx \seq_remove_all:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
        { \c_hash_str }
      \exp_args:Nnx \seq_put_left:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
        { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
      \exp_args:Nx \stex_add_to_current_module:n {
        \exp_args:Nnx \seq_remove_all:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
          { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
        \exp_args:Nnx \seq_put_left:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
          { \l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str }
        \exp_args:Nnx \seq_remove_all:cn { l_stex_symdecl_\l_stex_get_symbol_uri_str _notations }
          { \c_hash_str }
      }
      \stex_debug:nn {notations}{
        Setting~default~notation~
        {\l__stex_notation_variant_str \c_hash_str \l__stex_notation_lang_str}~for~
        \l_stex_get_symbol_uri_str \\
        \expandafter\meaning\csname
        l_stex_symdecl_\l_stex_get_symbol_uri_str _notations\endcsname
      }
    }{
      % todo throw error
    }
}

\keys_define:nn { stex / symdef } {
  name    .str_set_x:N = \l_stex_symdecl_name_str ,
  local   .bool_set:N  = \l_stex_symdecl_local_bool ,
  args    .str_set_x:N = \l_stex_symdecl_args_str ,
  type    .tl_set:N    = \l_stex_symdecl_type_tl ,
  def     .tl_set:N    = \l_stex_symdecl_definiens_tl ,
  op      .tl_set:N    = \l__stex_notation_op_tl ,
  lang    .str_set_x:N = \l__stex_notation_lang_str ,
  variant .str_set_x:N = \l__stex_notation_variant_str ,
  prec    .str_set_x:N = \l__stex_notation_prec_str ,
  unknown .code:n      = \str_set:Nx
      \l__stex_notation_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \__stex_notation_symdef_args:n {
  \str_clear:N \l_stex_symdecl_name_str
  \str_clear:N \l_stex_symdecl_args_str
  \bool_set_false:N \l_stex_symdecl_local_bool
  \tl_clear:N \l_stex_symdecl_type_tl
  \tl_clear:N \l_stex_symdecl_definiens_tl
  \str_clear:N \l__stex_notation_lang_str
  \str_clear:N \l__stex_notation_variant_str
  \str_clear:N \l__stex_notation_prec_str
  \tl_clear:N \l__stex_notation_op_tl

  \keys_set:nn { stex / symdef } { #1 }
}

\NewDocumentCommand \symdef { O{} m } {
  \__stex_notation_symdef_args:n { #1 }
  \bool_set_true:N \l_stex_symdecl_make_macro_bool
  \stex_symdecl_do:n { #2 }
  \exp_args:Nx \stex_notation_do:nn {
    \l_stex_current_module_str ? \l_stex_symdecl_name_str
  }
}
\stex_deactivate_macro:Nn \symdef {module~environments}


%%%%%%%%%%%%%   terms.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/nonotation}{
  Symbol~#1~invoked,~but~has~no~notation#2!
}
\msg_new:nnn{stex}{error/notationarg}{
  Error~in~parsing~notation~#1
}
\msg_new:nnn{stex}{error/noop}{
  Symbol~#1~has~no~operator~notation~for~notation~#2
}

\keys_define:nn { stex / terms } {
  lang    .tl_set_x:N = \l__stex_terms_lang_str ,
  variant .tl_set_x:N = \l__stex_terms_variant_str ,
  unknown .code:n     = \str_set:Nx
      \l__stex_terms_variant_str \l_keys_key_str
}

\cs_new_protected:Nn \__stex_terms_args:n {
  \str_clear:N \l__stex_terms_lang_str
  \str_clear:N \l__stex_terms_variant_str
  \str_clear:N \l__stex_terms_prec_str
  \tl_clear:N \l__stex_terms_op_tl

  \keys_set:nn { stex / terms } { #1 }
}
\cs_new_protected:Nn \stex_invoke_symbol:n {
  \if_mode_math:
    \exp_after:wN \__stex_terms_invoke_math:n
  \else:
    \exp_after:wN \__stex_terms_invoke_text:n
  \fi: { #1 }
}
\cs_new_protected:Nn \__stex_terms_invoke_math:n {
  \peek_charcode_remove:NTF ! {
    \peek_charcode:NTF [ {
      \__stex_terms_invoke_op:nw { #1 }
    }{
      \peek_charcode_remove:NTF ! {
        \peek_charcode:NTF [ {
          \__stex_terms_invoke_op_custom:nw
        }{
          % TODO throw error
        }
      }{
        \__stex_terms_invoke_op:nw { #1 } []
      }
    }
  }{
    \peek_charcode_remove:NTF * {
      \__stex_terms_invoke_text:n { #1 }
    }{
      \peek_charcode:NTF [ {
        \__stex_terms_invoke_math:nw { #1 }
      }{
        \__stex_terms_invoke_math:nw { #1 } []
      }
    }
  }
}
\cs_new_protected:Npn \__stex_terms_invoke_op_custom:nw  #1 [#2] {
  \_stex_term_oms:nnn {#1 \c_hash_str\c_hash_str}{#1}{
    \stex_highlight_term:nn{#1}{#2}
  }
}
\cs_new_protected:Npn \__stex_terms_invoke_op:nw  #1 [#2] {
  \__stex_terms_args:n { #2 }
  \cs_if_exist:cTF {
    stex_op_notation_ #1 \c_hash_str
    \l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str _cs
  }{
    \csname stex_op_notation_ #1 \c_hash_str
      \l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str _cs
    \endcsname
  }{
    \msg_error:nnxx{stex}{error/noop}{#1}{\l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str}
  }
}
\cs_new_protected:Npn \__stex_terms_invoke_math:nw  #1 [#2] {
  \__stex_terms_args:n { #2 }
  \seq_if_empty:cTF {
    l_stex_symdecl_ #1 _notations
  } {
    \msg_error:nnxx{stex}{error/nonotation}{#1}{s}
  } {
    \seq_if_in:cxTF {
      l_stex_symdecl_ #1 _notations
    }
      { \l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str }{
      \str_set:Nn \l_stex_current_symbol_str { #1 }
      \use:c{
        stex_notation_ #1 \c_hash_str
        \l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str
        _cs
      }
    }{
      \str_if_empty:NTF \l__stex_terms_variant_str {
        \str_if_empty:NTF \l__stex_terms_lang_str {
          \seq_get_left:cN {
            l_stex_symdecl_ #1 _notations
          } \l_tmpa_str
          \str_set:Nn \l_stex_current_symbol_str { #1 }
          \use:c{
            stex_notation_ #1 \c_hash_str \l_tmpa_str
            _cs
          }
        }{
          \msg_error:nnxx{stex}{error/nonotation}{#1}{
            ~\l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str
          }
        }
      }{
        \msg_error:nnxx{stex}{error/nonotation}{#1}{
          ~\l__stex_terms_variant_str \c_hash_str \l__stex_terms_lang_str
        }
      }
    }
  }
}
\cs_new_protected:Nn \__stex_terms_invoke_text:n {
  \peek_charcode_remove:NTF ! {
    \stex_term_custom:nn { #1 } { }
  }{
    \prop_set_eq:Nc \l_tmpa_prop {
      l_stex_symdecl_ #1 _prop
    }
    \prop_get:NnN \l_tmpa_prop { args } \l_tmpa_str
    \exp_args:Nnx \stex_term_custom:nn { #1 } { \l_tmpa_str }
  }
}
\tl_const:Nx \infprec {\int_use:N \c_max_int}
\tl_const:Nx \neginfprec {-\int_use:N \c_max_int}
\int_new:N \l__stex_terms_downprec
\int_set_eq:NN \l__stex_terms_downprec \infprec
\tl_set:Nn \l__stex_terms_left_bracket_str (
\tl_set:Nn \l__stex_terms_right_bracket_str )
\cs_new_protected:Nn \__stex_terms_maybe_brackets:nn {
  \bool_if:NTF \l__stex_terms_brackets_done_bool {
    \bool_set_false:N \l__stex_terms_brackets_done_bool
    #2
  } {
    \int_compare:nNnTF { #1 } > \l__stex_terms_downprec {
      \bool_if:NTF \l_stex_inparray_bool { #2 }{
        \stex_debug:nn{dobrackets}{\number#1 > \number\l__stex_terms_downprec; \detokenize{#2}}
        \dobrackets { #2 }
      }
    }{ #2 }
  }
}
\bool_new:N \l__stex_terms_brackets_done_bool
\cs_new_protected:Npn \dobrackets #1 {
  %\ThisStyle{\if D\m@switch
  %    \exp_args:Nnx \use:nn
  %    { \exp_after:wN \left\l__stex_terms_left_bracket_str #1 }
  %    { \exp_not:N\right\l__stex_terms_right_bracket_str }
  %  \else
      \exp_args:Nnx \use:nn
      {
        \bool_set_true:N \l__stex_terms_brackets_done_bool
        \int_set:Nn \l__stex_terms_downprec \infprec
        \l__stex_terms_left_bracket_str
        #1
      }
      {
        \bool_set_false:N \l__stex_terms_brackets_done_bool
        \l__stex_terms_right_bracket_str
        \int_set:Nn \l__stex_terms_downprec { \int_use:N \l__stex_terms_downprec }
      }
  %\fi}
}
\cs_new_protected:Npn \withbrackets #1 #2 #3 {
  \exp_args:Nnx \use:nn
  {
    \tl_set:Nx \l__stex_terms_left_bracket_str { #1 }
    \tl_set:Nx \l__stex_terms_right_bracket_str { #2 }
    #3
  }
  {
    \tl_set:Nn \exp_not:N \l__stex_terms_left_bracket_str
      {\l__stex_terms_left_bracket_str}
    \tl_set:Nn \exp_not:N \l__stex_terms_right_bracket_str
      {\l__stex_terms_right_bracket_str}
  }
}
\cs_new_protected:Npn \STEXinvisible #1 {
  \stex_annotate_invisible:n { #1 }
}
\cs_new_protected:Nn \_stex_term_oms:nnn {
  \stex_annotate:nnn{ OMID }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 }
  }
}

\cs_new_protected:Nn \_stex_term_math_oms:nnnn {
  \__stex_terms_maybe_brackets:nn { #3 }{
    \_stex_term_oms:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
\cs_new_protected:Nn \_stex_term_oma:nnn {
  \stex_annotate:nnn{ OMA }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 }
  }
}

\cs_new_protected:Nn \_stex_term_math_oma:nnnn {
  \__stex_terms_maybe_brackets:nn { #3 }{
    \_stex_term_oma:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
\cs_new_protected:Nn \_stex_term_ombind:nnn {
  \stex_annotate:nnn{ OMBIND }{ #2 }{
    \stex_highlight_term:nn { #1 } { #3 }
  }
}

\cs_new_protected:Nn \_stex_term_math_omb:nnnn {
  \__stex_terms_maybe_brackets:nn { #3 }{
    \_stex_term_ombind:nnn { #1 } { #1\c_hash_str#2 } { #4 }
  }
}
\cs_new_protected:Nn \_stex_term_arg:nn {
  \stex_unhighlight_term:n {
    \stex_annotate:nnn{ arg }{ #1 }{ #2 }
  }
}
\cs_new_protected:Nn \_stex_term_math_arg:nnn {
  \exp_args:Nnx \use:nn
    { \int_set:Nn \l__stex_terms_downprec { #2 }
        \_stex_term_arg:nn { #1 }{ #3 }
    }
    { \int_set:Nn \exp_not:N \l__stex_terms_downprec { \int_use:N \l__stex_terms_downprec } }
}
\cs_new_protected:Nn \_stex_term_math_assoc_arg:nnnn {
  \clist_set:Nn \l_tmpa_clist{ #4 }
  \int_compare:nNnTF { \clist_count:N \l_tmpa_clist } < 2 {
    \tl_set:Nn \l_tmpa_tl { #4 }
  }{
    \cs_set:Npn \l_tmpa_cs ##1 ##2 { #3 }
    \clist_reverse:N \l_tmpa_clist
    \clist_pop:NN \l_tmpa_clist \l_tmpa_tl

    \clist_map_inline:Nn \l_tmpa_clist {
      \exp_args:NNNo \exp_args:NNo \tl_set:No \l_tmpa_tl {
        \exp_args:Nno
        \l_tmpa_cs { ##1 } \l_tmpa_tl
      }
    }

  }
  \exp_args:Nnno
  \_stex_term_math_arg:nnn{#1}{#2}\l_tmpa_tl
}
\cs_new_protected:Nn \stex_term_custom:nn {
  \str_set:Nn \l__stex_terms_custom_uri { #1 }
  \str_set:Nn \l_tmpa_str { #2 }
  \tl_clear:N \l_tmpa_tl
  \int_zero:N \l_tmpa_int
  \int_set:Nn \l_tmpb_int { \str_count:N \l_tmpa_str }
  \__stex_terms_custom_loop:
}
\cs_new_protected:Nn \__stex_terms_custom_loop: {
  \bool_set_false:N \l_tmpa_bool
  \bool_while_do:nn {
    \str_if_eq_p:ee X {
      \str_item:Nn \l_tmpa_str { \l_tmpa_int + 1 }
    }
  }{
    \int_incr:N \l_tmpa_int
  }

  \peek_charcode:NTF [ {
    % notation/text component
    \__stex_terms_custom_component:w
  } {
    \int_compare:nNnTF \l_tmpa_int = \l_tmpb_int {
      % all arguments read => finish
      \__stex_terms_custom_final:
    } {
      % arguments missing
      \peek_charcode_remove:NTF * {
        % invisible, specific argument position or both
        \peek_charcode:NTF [ {
          % visible specific argument position
          \__stex_terms_custom_arg:wn
        } {
          % invisible
          \peek_charcode_remove:NTF * {
            % invisible specific argument position
            \__stex_terms_custom_arg_inv:wn
          } {
            % invisible next argument
            \__stex_terms_custom_arg_inv:wn [ \l_tmpa_int + 1 ]
          }
        }
      } {
        % next normal argument
        \__stex_terms_custom_arg:wn [ \l_tmpa_int + 1 ]
      }
    }
  }
}
\cs_new_protected:Npn \__stex_terms_custom_arg_inv:wn [ #1 ] #2 {
  \bool_set_true:N \l_tmpa_bool
  \__stex_terms_custom_arg:wn [ #1 ] { #2 }
}
\cs_new_protected:Npn \__stex_terms_custom_arg:wn [ #1 ] #2 {
  \str_set:Nx \l_tmpb_str {
    \str_item:Nn \l_tmpa_str { #1 }
  }
  \str_case:VnTF \l_tmpb_str {
    { X } {
      \msg_error:nnx{stex}{error/notationarg}{\l__stex_terms_custom_uri}
    }
    { i } { \__stex_terms_custom_set_X:n { #1 } }
    { b } { \__stex_terms_custom_set_X:n { #1 } }
    { a } { \__stex_terms_custom_set_X:n { #1 } } % TODO ?
    { B } { \__stex_terms_custom_set_X:n { #1 } } % TODO ?
  }{}{
    \msg_error:nnx{stex}{error/notationarg}{\l__stex_terms_custom_uri}
  }

  \bool_if:nTF \l_tmpa_bool {
    \tl_put_right:Nx \l_tmpa_tl {
      \stex_annotate_invisible:n {
        \_stex_term_arg:nn { \int_eval:n { #1 } }
          \exp_not:n { { #2 } }
      }
    }
  } {
    \tl_put_right:Nx \l_tmpa_tl {
      \_stex_term_arg:nn { \int_eval:n { #1 } }
        \exp_not:n { { #2 } }
    }
  }

  \__stex_terms_custom_loop:
}
\cs_new_protected:Nn \__stex_terms_custom_set_X:n {
  \str_set:Nx \l_tmpa_str {
    \str_range:Nnn \l_tmpa_str 1 { #1 - 1 }
    X
    \str_range:Nnn \l_tmpa_str { #1 + 1 } { -1 }
  }
}
\cs_new_protected:Npn \__stex_terms_custom_component:w [ #1 ] {
  \tl_put_right:Nn \l_tmpa_tl { \comp{ #1 } }
  \__stex_terms_custom_loop:
}
\cs_new_protected:Nn \__stex_terms_custom_final: {
  \int_compare:nNnTF \l_tmpb_int = 0 {
    \exp_args:Nnno \_stex_term_oms:nnn
  }{
    \str_if_in:NnTF \l_tmpa_str {b} {
      \exp_args:Nnno \_stex_term_ombind:nnn
    } {
      \exp_args:Nnno \_stex_term_oma:nnn
    }
  }
  { \l__stex_terms_custom_uri } { \l__stex_terms_custom_uri } { \l_tmpa_tl }
}
\NewDocumentCommand \symref { m m }{
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \STEXsymbol{#1}![#2]
  \let\compemph@uri\compemph_uri_prev:
}

\keys_define:nn { stex / symname } {
  post    .str_set_x:N   = \l_stex_symname_post_str
}

\cs_new_protected:Nn \stex_symname_args:n {
  \str_clear:N \l_stex_symname_post_str
  \keys_set:nn { stex / symname } { #1 }
}

\NewDocumentCommand \symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}

  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }![
    \l_tmpa_str \l_stex_symname_post_str
  ] }
  \let\compemph@uri\compemph_uri_prev:
}

\str_new:N \l_stex_current_symbol_str
\cs_new_protected:Nn \stex_highlight_term:nn {
  \exp_args:Nnx
  \use:nn {
    \str_set:Nx \l_stex_current_symbol_str { #1 }
    #2
  } {
    \str_set:Nx \exp_not:N \l_stex_current_symbol_str
      { \l_stex_current_symbol_str }
  }
}

\cs_new_protected:Nn \stex_unhighlight_term:n {
      #1 %\iffalse{{\fi}} #1 {{\iffalse}}\fi
}
\cs_new_protected:Npn \comp #1 {
  \str_if_empty:NF \l_stex_current_symbol_str {
    \rustex_if:TF {
      \stex_annotate:nnn { comp }{ \l_stex_current_symbol_str }{ #1 }
    }{
      \exp_args:Nnx \compemph@uri { #1 } { \l_stex_current_symbol_str }
    }
  }
}

\cs_new_protected:Npn \compemph@uri #1 #2 {
    \compemph{ #1 }
}

\cs_new_protected:Npn \compemph #1 {
    #1
}

\cs_new_protected:Npn \defemph@uri #1 #2 {
    \defemph{#1}
}

\cs_new_protected:Npn \defemph #1 {
    \textbf{#1}
}

\cs_new_protected:Npn \symrefemph@uri #1 #2 {
    \symrefemph{#1}
}

\cs_new_protected:Npn \symrefemph #1 {
    \textbf{#1}
}
\NewDocumentCommand \ellipses {} { \ldots }
\bool_new:N \l_stex_inparray_bool
\bool_set_false:N \l_stex_inparray_bool
\NewDocumentCommand \parray { m m } {
  \begingroup
  \bool_set_true:N \l_stex_inparray_bool
  \begin{array}{#1}
    #2
  \end{array}
  \endgroup
}

\NewDocumentCommand \prmatrix { m } {
  \begingroup
  \bool_set_true:N \l_stex_inparray_bool
  \begin{matrix}
    #1
  \end{matrix}
  \endgroup
}

\def \maybephline {
  \bool_if:NT \l_stex_inparray_bool {\hline}
}

\def \parrayline #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\}
}

\def \pmrow #1 { \parrayline{}{ #1 } }

\def \parraylineh #1 #2 {
  #1 #2 \bool_if:NT \l_stex_inparray_bool {\\\hline}
}

\def \parraycell #1 {
  #1 \bool_if:NT \l_stex_inparray_bool {&}
}


%%%%%%%%%%%%%   features.dtx   %%%%%%%%%%%%%

\msg_new:nnn{stex}{error/copymodule/notallowed}{
  Symbol~#1~can~not~be~assigned~in~copymodule~#2
}
\msg_new:nnn{stex}{error/interpretmodule/nodefiniens}{
  Symbol~#1~not~assigned~in~interpretmodule~#2
}

\cs_new_protected:Nn \stex_get_symbol_in_copymodule:n {
  \tl_if_head_eq_catcode:nNTF { #1 } \relax {
    \__stex_features_get_symbol_from_cs:n { #1 }
  }{
    % argument is a string
    % is it a command name?
    \cs_if_exist:cTF { #1 }{
      \cs_set_eq:Nc \l_tmpa_tl { #1 }
      \str_set:Nx \l_tmpa_str { \cs_argument_spec:N \l_tmpa_tl }
      \str_if_empty:NTF \l_tmpa_str {
        \exp_args:Nx \cs_if_eq:NNTF {
          \tl_head:N \l_tmpa_tl
        } \stex_invoke_symbol:n {
          \exp_args:No \__stex_features_get_symbol_from_cs:n { \use:c { #1 } }
        }{
          \__stex_features_get_symbol_from_string:n { #1 }
        }
      } {
        \__stex_features_get_symbol_from_string:n { #1 }
      }
    }{
      % argument is not a command name
      \__stex_features_get_symbol_from_string:n { #1 }
      % \l_stex_all_symbols_seq
    }
  }
}

\cs_new_protected:Nn \__stex_features_get_symbol_from_string:n {
  \str_set:Nn \l_tmpa_str { #1 }
  \bool_set_false:N \l_tmpa_bool
  \bool_if:NF \l_tmpa_bool {
    \tl_set:Nn \l_tmpa_tl {
      \msg_set:nnn{stex}{error/unknownsymbol}{
        No~symbol~#1~found!
      }
      \msg_error:nn{stex}{error/unknownsymbol}
    }
    \str_set:Nn \l_tmpa_str { #1 }
    \int_set:Nn \l_tmpa_int { \str_count:N \l_tmpa_str }
    \seq_map_inline:Nn \l__stex_features_copymodule_fields_seq {
      \str_set:Nn \l_tmpb_str { ##1 }
      \str_if_eq:eeT { \l_tmpa_str } {
        \str_range:Nnn \l_tmpb_str { -\l_tmpa_int } { -1 }
      } {
        \seq_map_break:n {
          \tl_set:Nn \l_tmpa_tl {
            \str_set:Nn \l_stex_get_symbol_uri_str {
              ##1
            }
            \__stex_features_get_symbol_check:
          }
        }
      }
    }
    \l_tmpa_tl
  }
}

\cs_new_protected:Nn \__stex_features_get_symbol_from_cs:n {
  \exp_args:NNx \tl_set:Nn \l_tmpa_tl
    { \tl_tail:N \l_tmpa_tl }
  \tl_if_single:NTF \l_tmpa_tl {
    \exp_args:No \tl_if_head_is_group:nTF \l_tmpa_tl {
      \exp_after:wN \str_set:Nn \exp_after:wN
        \l_stex_get_symbol_uri_str \l_tmpa_tl
      \__stex_features_get_symbol_check:
    }{
      % TODO
      % tail is not a single group
    }
  }{
    % TODO
    % tail is not a single group
  }
}

\cs_new_protected:Nn \__stex_features_get_symbol_check: {
  \exp_args:NNno \seq_set_split:Nnn \l_tmpa_seq {?} \l_stex_get_symbol_uri_str
  \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} = 3 {
    \seq_pop_right:NN \l_tmpa_seq \l_tmpb_str
    \str_set:Nx \l_tmpa_str {\seq_use:Nn \l_tmpa_seq ?}
    \seq_if_in:NoF \l__stex_features_copymodule_modules_seq \l_tmpa_str {
      \msg_error:nnxx{stex}{error/copymodule/notallowed}{\l_stex_get_symbol_uri_str}{
        \l_stex_current_copymodule_name_str\\Allowed:~\seq_use:Nn \l__stex_features_copymodule_modules_seq {,~}
        }
    }
  }{
    \msg_error:nnxx{stex}{error/copymodule/notallowed}{\l_stex_get_symbol_uri_str}{
      \l_stex_current_copymodule_name_str~(inexplicably)
    }
  }
}

\cs_new_protected:Nn \stex_copymodule_start:nnnn {
  \stex_import_module_uri:nn { #1 } { #2 }
  \str_set:Nx \l_stex_current_copymodule_name_str {#3}
  \stex_import_require_module:nnnn
    { \l_stex_import_ns_str } { \l_stex_import_archive_str }
    { \l_stex_import_path_str } { \l_stex_import_name_str }
  \stex_collect_imports:n {\l_stex_import_ns_str ?\l_stex_import_name_str }
  \seq_set_eq:NN \l__stex_features_copymodule_modules_seq \l_stex_collect_imports_seq
  \seq_clear:N \l__stex_features_copymodule_fields_seq
  \seq_map_inline:Nn \l__stex_features_copymodule_modules_seq {
    \seq_map_inline:cn {c_stex_module_##1_constants}{
      \exp_args:NNx \seq_put_right:Nn \l__stex_features_copymodule_fields_seq {
        ##1 ? ####1
      }
    }
  }
  \seq_clear:N \l_tmpa_seq
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_copymodule_prop {
    name      = \l_stex_current_copymodule_name_str ,
    module    = \l_stex_current_module_str ,
    from      = \l_stex_import_ns_str ?\l_stex_import_name_str ,
    includes  = \l_tmpa_seq ,
    fields    = \l_tmpa_seq
  }
  \stex_debug:nn{copymodule}{#4~for~module~{\l_stex_import_ns_str ?\l_stex_import_name_str}
    as~\l_stex_current_module_str?\l_stex_current_copymodule_name_str}
    \stex_debug:nn{copymodule}{modules:\seq_use:Nn \l__stex_features_copymodule_modules_seq {,~}}
  \stex_debug:nn{copymodule}{fields:\seq_use:Nn \l__stex_features_copymodule_fields_seq {,~}}
  \stex_if_smsmode:F {
    \begin{stex_annotate_env} {#4} {
      \l_stex_current_module_str?\l_stex_current_copymodule_name_str
    }
    \stex_annotate_invisible:nnn{from}{\l_stex_import_ns_str ?\l_stex_import_name_str}{}
  }
  \bool_set_eq:NN \l__stex_features_oldhtml_bool \l_stex_html_do_output_bool
  \bool_set_false:N \l_stex_html_do_output_bool
}
\cs_new_protected:Nn \stex_copymodule_end:n {
  \def \l_tmpa_cs ##1 ##2 {#1}
  \bool_set_eq:NN \l_stex_html_do_output_bool \l__stex_features_oldhtml_bool
  \tl_clear:N \l_tmpa_tl
  \prop_get:NnN \l_stex_current_copymodule_prop {fields} \l_tmpa_seq
  \seq_map_inline:Nn \l__stex_features_copymodule_modules_seq {
    \seq_map_inline:cn {c_stex_module_##1_constants}{\stex_annotate:nnn{assignment} {##1?####1} {
      \l_tmpa_cs{##1}{####1}
      \str_if_exist:cTF {l__stex_features_copymodule_##1?####1_name_str} {
        \tl_put_right:Nx \l_tmpa_tl {
          \prop_set_from_keyval:cn {
            l_stex_symdecl_\l_stex_current_module_str ? \use:c{l__stex_features_copymodule_##1?####1_name_str}_prop
          }{
            \exp_after:wN \prop_to_keyval:N \csname
              l_stex_symdecl_\l_stex_current_module_str ? \use:c{l__stex_features_copymodule_##1?####1_name_str}_prop
            \endcsname
          }
          \seq_clear:c {
            l_stex_symdecl_
            \l_stex_current_module_str ? \use:c{l__stex_features_copymodule_##1?####1_name_str}
            _notations
          }
        }
        \stex_annotate_invisible:nnn{alias}{\use:c{l__stex_features_copymodule_##1?####1_name_str}}{}
        \seq_put_right:Nx \l_tmpa_seq {\l_stex_current_module_str ? \use:c{l__stex_features_copymodule_##1?####1_name_str}}
        \str_if_exist:cT {l__stex_features_copymodule_##1?####1_macroname_str} {
          \stex_annotate_invisible:nnn{macroname}{\use:c{l__stex_features_copymodule_##1?####1_macroname_str}}{}
          \tl_put_right:Nx \l_tmpa_tl {
            \tl_set:cx {\use:c{l__stex_features_copymodule_##1?####1_macroname_str}}{
              \stex_invoke_symbol:n {
                \l_stex_current_module_str ? \use:c{l__stex_features_copymodule_##1?####1_name_str}
              }
            }
          }
        }
      }{
        \prop_set_eq:Nc \l_tmpa_prop {l_stex_symdecl_ ##1?####1 _prop}
        \prop_put:Nnx \l_tmpa_prop { name }{ \l_stex_current_copymodule_name_str / ####1 }
        \prop_put:Nnx \l_tmpa_prop { module }{ \l_stex_current_module_str }
        \tl_put_right:Nx \l_tmpa_tl {
          \prop_set_from_keyval:cn {
            l_stex_symdecl_\l_stex_current_module_str ? \l_stex_current_copymodule_name_str / ####1_prop
          }{
            \prop_to_keyval:N \l_tmpa_prop
          }
          \seq_clear:c {
            l_stex_symdecl_
            \l_stex_current_module_str ? \l_stex_current_copymodule_name_str / ####1
            _notations
          }
        }
        \seq_put_right:Nx \l_tmpa_seq {\l_stex_current_module_str ? \l_stex_current_copymodule_name_str / ####1 }
        \str_if_exist:cT {l__stex_features_copymodule_##1?####1_macroname_str} {
          \stex_annotate_invisible:nnn{macroname}{\use:c{l__stex_features_copymodule_##1?####1_macroname_str}}{}
          \tl_put_right:Nx \l_tmpa_tl {
            \tl_set:cx {\use:c{l__stex_features_copymodule_##1?####1_macroname_str}}{
              \stex_invoke_symbol:n {
                \l_stex_current_module_str ? \l_stex_current_copymodule_name_str / ####1
              }
            }
          }
        }
      }
      \tl_if_exist:cT {l__stex_features_copymodule_##1?####1_def_tl}{
        \stex_annotate_invisible:nnn{definiens}{}{$\use:c{l__stex_features_copymodule_##1?####1_def_tl}$}
      }
      % todo notations
    }}
  }
  \prop_put:Nno \l_stex_current_copymodule_prop {fields} \l_tmpa_seq
  \tl_put_left:Nx \l_tmpa_tl {
    \prop_set_from_keyval:cn {
      l_stex_copymodule_ \l_stex_current_module_str?\l_stex_current_copymodule_name_str _prop
    }{
      \prop_to_keyval:N \l_stex_current_copymodule_prop
    }
  }
  \exp_args:No \stex_add_to_current_module:n \l_tmpa_tl
  \stex_debug:nn{copymodule}{result:\meaning \l_tmpa_tl}
  \exp_args:Nx \stex_do_aftergroup:n {
      \exp_args:No \exp_not:n \l_tmpa_tl
  }
  \stex_if_smsmode:F {
    \end{stex_annotate_env}
  }
}

\NewDocumentEnvironment {copymodule} { O{} m m}{
  \stex_copymodule_start:nnnn { #1 }{ #2 }{ #3 }{ structure }
  \stex_deactivate_macro:Nn \symdecl {module~environments}
  \stex_deactivate_macro:Nn \symdef {module~environments}
  \stex_deactivate_macro:Nn \notation {module~environments}
  \stex_reactivate_macro:N \assign
  \stex_reactivate_macro:N \renamedecl
  \stex_reactivate_macro:N \donotcopy
  \stex_smsmode_do:
}{
  \stex_copymodule_end:n {}
}

\NewDocumentEnvironment {interpretmodule} { O{} m m}{
  \stex_copymodule_start:nnnn { #1 }{ #2 }{ #3 }{ realization }
  \stex_deactivate_macro:Nn \symdecl {module~environments}
  \stex_deactivate_macro:Nn \symdef {module~environments}
  \stex_deactivate_macro:Nn \notation {module~environments}
  \stex_reactivate_macro:N \assign
  \stex_reactivate_macro:N \renamedecl
  \stex_reactivate_macro:N \donotcopy
  \stex_smsmode_do:
}{
  \stex_copymodule_end:n {
    \tl_if_exist:cF {
      l__stex_features_copymodule_##1?##2_def_tl
    }{
      \msg_error:nnxx{stex}{error/interpretmodule/nodefiniens}{
        ##1?##2
      }{\l_stex_current_copymodule_name_str}
    }
  }
}

\NewDocumentCommand \donotcopy { O{} m}{
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_collect_imports:n {\l_stex_import_ns_str ?\l_stex_import_name_str }
  \seq_map_inline:Nn \l_stex_collect_imports_seq {
    \seq_remove_all:Nn \l__stex_features_copymodule_modules_seq { ##1 }
    \seq_map_inline:cn {c_stex_module_##1_constants}{
      \seq_remove_all:Nn \l__stex_features_copymodule_fields_seq { ##1 ? ####1 }
      \bool_lazy_any_p:nT {
        { \cs_if_exist_p:c {l__stex_features_copymodule_##1?####1_name_str}}
        { \cs_if_exist_p:c {l__stex_features_copymodule_##1?####1_macroname_str}}
        { \cs_if_exist_p:c {l__stex_features_copymodule_##1?####1_def_tl}}
      }{
        % TODO throw error
      }
    }
  }

  \prop_get:NnN \l_stex_current_copymodule_prop { includes } \l_tmpa_seq
  \seq_put_right:Nx \l_tmpa_seq {\l_stex_import_ns_str ?\l_stex_import_name_str }
  \prop_put:Nnx \l_stex_current_copymodule_prop {includes} \l_tmpa_seq
}

\NewDocumentCommand \assign { m m }{
  \stex_get_symbol_in_copymodule:n {#1}
  \stex_debug:nn{assign}{defining~{\l_stex_get_symbol_uri_str}~as~\detokenize{#2}}
  \tl_set:cn {l__stex_features_copymodule_\l_stex_get_symbol_uri_str _def_tl}{#2}
}

\keys_define:nn { stex / renamedecl } {
  name        .str_set_x:N  = \l_stex_renamedecl_name_str
}
\cs_new_protected:Nn \__stex_features_renamedecl_args:n {
  \str_clear:N \l_stex_renamedecl_name_str

  \keys_set:nn { stex / renamedecl } { #1 }
}

\NewDocumentCommand \renamedecl { O{} m m}{
  \__stex_features_renamedecl_args:n { #1 }
  \stex_get_symbol_in_copymodule:n {#2}
  \stex_debug:nn{renamedecl}{renaming~{\l_stex_get_symbol_uri_str}~to~#3}
  \str_set:cx {l__stex_features_copymodule_\l_stex_get_symbol_uri_str _macroname_str}{#3}
  \str_if_empty:NTF \l_stex_renamedecl_name_str {
    \tl_set:cx { #3 }{ \stex_invoke_symbol:n {
      \l_stex_get_symbol_uri_str
    } }
  } {
    \str_set:cx {l__stex_features_copymodule_\l_stex_get_symbol_uri_str _name_str}{\l_stex_renamedecl_name_str}
    \stex_debug:nn{renamedecl}{@~\l_stex_current_module_str ? \l_stex_renamedecl_name_str}
    \prop_set_eq:cc {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop}
    \seq_set_eq:cc {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _notations
    }{l_stex_symdecl_ \l_stex_get_symbol_uri_str _notations}
    \prop_put:cnx {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{ name }{ \l_stex_renamedecl_name_str }
    \prop_put:cnx {l_stex_symdecl_
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
      _prop
    }{ module }{ \l_stex_current_module_str }
    \exp_args:NNx \seq_put_left:Nn \l__stex_features_copymodule_fields_seq {
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
    }
    \tl_set:cx { #3 }{ \stex_invoke_symbol:n {
      \l_stex_current_module_str ? \l_stex_renamedecl_name_str
    } }
  }
}
\stex_deactivate_macro:Nn \assign {copymodules}
\stex_deactivate_macro:Nn \renamedecl {copymodules}
\stex_deactivate_macro:Nn \donotcopy {copymodules}

\seq_new:N \l_stex_implicit_morphisms_seq
\NewDocumentCommand \implicitmorphism { O{} m m}{
  \stex_import_module_uri:nn { #1 } { #2 }
  \stex_debug:nn{implicits}{
    Implicit~morphism:~
    \l_stex_module_ns_str ? \l__stex_features_name_str
  }
  \exp_args:NNx \seq_if_in:NnT \l_stex_all_modules_seq {
    \l_stex_module_ns_str ? \l__stex_features_name_str
  }{
    \msg_error:nnn{stex}{error/conflictingmodules}{
      \l_stex_module_ns_str ? \l__stex_features_name_str
    }
  }

  % TODO

  \seq_put_right:Nx \l_stex_implicit_morphisms_seq {
    \l_stex_module_ns_str ? \l__stex_features_name_str
  }
}


\NewDocumentEnvironment{structural@feature}{ m m m }{
  \stex_if_in_module:F {
    \msg_set:nnn{stex}{error/nomodule}{
      Structural~Feature~has~to~occur~in~a~module:\\
      Feature~#2~of~type~#1\\
      In~File:~\stex_path_to_string:N \g_stex_currentfile_seq
    }
    \msg_error:nn{stex}{error/nomodule}
  }

  \str_set:Nx \l_stex_module_name_str {
    \prop_item:Nn \l_stex_current_module_prop
      { name } / #2 - feature
  }

  \str_set:Nx \l_stex_module_ns_str {
    \prop_item:Nn \l_stex_current_module_prop
      { ns }
  }

  \str_clear:N \l_tmpa_str
  \seq_clear:N \l_tmpa_seq
  \tl_clear:N \l_tmpa_tl
  \exp_args:NNx \prop_set_from_keyval:Nn \l_stex_current_module_prop {
    origname  = #2,
    name      = \l_stex_module_name_str ,
    ns        = \l_stex_module_ns_str ,
    imports   = \exp_not:o { \l_tmpa_seq } ,
    constants = \exp_not:o { \l_tmpa_seq } ,
    content   = \exp_not:o { \l_tmpa_tl }  ,
    file      = \exp_not:o { \g_stex_currentfile_seq } ,
    lang      = \l_stex_module_lang_str ,
    sig       = \l_tmpa_str ,
    meta      = \l_tmpa_str ,
    feature   = #1 ,
  }

  \stex_if_smsmode:F {
    \begin{stex_annotate_env}{ feature:#1 }{}
      \stex_annotate_invisible:nnn{header}{}{ #3 }
  }
}{
  \str_set:Nx \l_tmpa_str {
    c_stex_feature_
    \prop_item:Nn \l_stex_current_module_prop { ns } ?
    \prop_item:Nn \l_stex_current_module_prop { name }
    _prop
  }
  \prop_gset_eq:cN { \l_tmpa_str } \l_stex_current_module_prop
  \prop_gset_eq:NN \g_stex_last_feature_prop \l_stex_current_module_prop
  \stex_if_smsmode:TF {
    \exp_args:Nx \stex_add_to_sms:n {
      \prop_gset_from_keyval:cn {
        c_stex_feature_
        \prop_item:Nn \l_stex_current_module_prop { ns } ?
        \prop_item:Nn \l_stex_current_module_prop { name }
        _prop
      } {
        origname  = #2,
        name      = \prop_item:cn { \l_tmpa_str } { name } ,
        ns        = \prop_item:cn { \l_tmpa_str } { ns } ,
        imports   = \prop_item:cn { \l_tmpa_str } { imports } ,
        constants = \prop_item:cn { \l_tmpa_str } { constants } ,
        content   = \prop_item:cn { \l_tmpa_str } { content } ,
        file      = \prop_item:cn { \l_tmpa_str } { file } ,
        lang      = \prop_item:cn { \l_tmpa_str } { lang } ,
        sig       = \prop_item:cn { \l_tmpa_str } { sig } ,
        meta      = \prop_item:cn { \l_tmpa_str } { meta } ,
        feature   = \prop_item:cn { \l_tmpa_str } { feature }
      }
    }
  } {
      \end{stex_annotate_env}
  }
}


\prop_new:N \l_stex_all_structures_prop

\keys_define:nn { stex / features / structure } {
  name         .str_set_x:N  = \l__stex_features_structure_name_str ,
}

\cs_new_protected:Nn \__stex_features_structure_args:n {
  \str_clear:N \l__stex_features_structure_name_str
  \keys_set:nn { stex / features / structure } { #1 }
}


\NewDocumentEnvironment{mathstructure}{ O{} m }{
  \__stex_features_structure_args:n { #1 }
  \str_if_empty:NT \l__stex_features_structure_name_str {
    \str_set:Nx \l__stex_features_structure_name_str { #2 }
  }
  \exp_args:Nnnx
  \begin{structural@feature}{ structure }
    { \l__stex_features_structure_name_str }{}
    \seq_clear:N \l_tmpa_seq
    \prop_put:Nno \l_stex_current_module_prop { fields } \l_tmpa_seq
  \stex_smsmode_do:
}{
    \prop_get:NnN \l_stex_current_module_prop { constants } \l_tmpa_seq
    \prop_get:NnN \l_stex_current_module_prop { fields } \l_tmpb_seq
    \str_set:Nx \l_tmpa_str {
      \prop_item:Nn \l_stex_current_module_prop { ns } ?
      \prop_item:Nn \l_stex_current_module_prop { name }
    }
    \seq_map_inline:Nn \l_tmpa_seq {
      \exp_args:NNx \seq_put_right:Nn \l_tmpb_seq { \l_tmpa_str ? ##1 }
    }
    \prop_put:Nno \l_stex_current_module_prop { fields } { \l_tmpb_seq }
    \exp_args:Nnx
    \AddToHookNext { env / mathstructure / after }{
      \symdecl[type = \exp_not:N\collection,def={\STEXsymbol{module-type}{
        \_stex_term_math_oms:nnnn { \l_tmpa_str }{}{0}{}
      }}, name = \prop_item:Nn \l_stex_current_module_prop { origname }]{ #2 }
      \STEXexport {
        \prop_put:Nno \exp_not:N \l_stex_all_structures_prop
          {\prop_item:Nn \l_stex_current_module_prop { origname }}
          {\l_tmpa_str}
          \prop_put:Nno \exp_not:N \l_stex_all_structures_prop
            {#2}{\l_tmpa_str}
      }
    }

  \end{structural@feature}
  % \g_stex_last_feature_prop
}
\seq_new:N \l__stex_features_structure_field_seq
\str_new:N \l__stex_features_structure_field_str
\str_new:N \l__stex_features_structure_def_tl
\prop_new:N \l__stex_features_structure_prop
\NewDocumentCommand \instantiate { m O{} m }{
  \prop_get:NnN \l_stex_all_structures_prop {#1} \l_tmpa_str
  \prop_set_eq:Nc \l__stex_features_structure_prop {
    c_stex_feature_\l_tmpa_str _prop
  }
  \seq_set_from_clist:Nn \l__stex_features_structure_field_seq { #2 }
  \seq_map_inline:Nn \l__stex_features_structure_field_seq {
    \seq_set_split:Nnn \l_tmpa_seq{=}{ ##1 }
    \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
      \seq_get_left:NN \l_tmpa_seq \l_tmpa_tl
      \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq
        {!} \l_tmpa_tl
      \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
        \str_set:Nx \l__stex_features_structure_field_str {\seq_item:Nn \l_tmpb_seq 1}
        \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
        \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
      }{
        \str_set:Nx \l__stex_features_structure_field_str \l_tmpa_tl
        \seq_get_right:NN \l_tmpa_seq \l_tmpa_tl
        \exp_args:NNno \seq_set_split:Nnn \l_tmpb_seq{!}
          \l_tmpa_tl
        \int_compare:nNnTF {\seq_count:N \l_tmpb_seq} > 1 {
          \seq_get_left:NN \l_tmpb_seq \l_tmpa_tl
          \seq_get_right:NN \l_tmpb_seq \l_tmpb_tl
        }{
          \tl_clear:N \l_tmpb_tl
        }
      }
    }{
      \seq_set_split:Nnn \l_tmpa_seq{!}{ ##1 }
      \int_compare:nNnTF {\seq_count:N \l_tmpa_seq} > 1 {
        \str_set:Nx \l__stex_features_structure_field_str {\seq_item:Nn \l_tmpa_seq 1}
        \seq_get_right:NN \l_tmpa_seq \l_tmpb_tl
        \tl_clear:N \l_tmpa_tl
      }{
        % TODO throw error
      }
    }
    % \l_tmpa_str: name
    % \l_tmpa_tl: definiens
    % \l_tmpb_tl: notation
    \tl_if_empty:NT \l__stex_features_structure_field_str {
      % TODO throw error
    }
    \str_clear:N \l_tmpb_str

    \prop_get:NnN \l__stex_features_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ####1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpb_str
      \str_if_eq:NNT \l__stex_features_structure_field_str \l_tmpb_str {
        \seq_map_break:n {
          \str_set:Nn \l_tmpb_str { ####1 }
        }
      }
    }
    \prop_get:cnN { l_stex_symdecl_ \l_tmpb_str _prop } {args}
      \l_tmpb_str

    \tl_if_empty:NTF \l_tmpb_tl {
      \tl_if_empty:NF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdecl[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l__stex_features_structure_field_str}
        }
      }
    }{
      \tl_if_empty:NTF \l_tmpa_tl {
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str]{#3/\l__stex_features_structure_field_str}\exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }

      }{
        \exp_args:Nx \use:n {
          \symdef[args=\l_tmpb_str,def={\exp_args:No\exp_not:n{\l_tmpa_tl}}]{#3/\l__stex_features_structure_field_str}
          \exp_after:wN\exp_not:n\exp_after:wN{\l_tmpb_tl}
        }
      }
    }
  }

  \tl_clear:N \l__stex_features_structure_def_tl

  \prop_get:NnN \l__stex_features_structure_prop { fields } \l_tmpa_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
    \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
    \exp_args:Nx \use:n {
      \tl_put_right:Nn \exp_not:N \l__stex_features_structure_def_tl {

      }
    }

    \prop_if_exist:cF {
      l_stex_symdecl_
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ?
      #3/\l_tmpa_str
      _prop
    }{
      \prop_get:cnN { l_stex_symdecl_ ##1 _prop } {args}
        \l_tmpb_str
      \exp_args:Nx \use:n {
        \symdecl[args=\l_tmpb_str]{#3/\l_tmpa_str}
      }
    }
  }

  \symdecl*[type={\STEXsymbol{module-type}{
    \_stex_term_math_oms:nnnn {
      \prop_item:Nn \l__stex_features_structure_prop {ns} ?
      \prop_item:Nn \l__stex_features_structure_prop {name}
      }{}{0}{}
  }}]{#3}

  % TODO: -> sms file

  \tl_set:cx{ #3 }{
    \stex_invoke_structure:nnn {
      \prop_item:Nn \l_stex_current_module_prop {ns} ?
      \prop_item:Nn \l_stex_current_module_prop {name} ? #3
    } {
      \prop_item:Nn \l__stex_features_structure_prop {ns} ?
      \prop_item:Nn \l__stex_features_structure_prop {name}
    }
  }
  \stex_smsmode_do:
}
\cs_new_protected:Nn \stex_invoke_structure:nnn {
  \tl_if_empty:nTF{ #3 }{
    \prop_set_eq:Nc \l__stex_features_structure_prop {
      c_stex_feature_ #2 _prop
    }
    \tl_clear:N \l_tmpa_tl
    \prop_get:NnN \l__stex_features_structure_prop { fields } \l_tmpa_seq
    \seq_map_inline:Nn \l_tmpa_seq {
      \seq_set_split:Nnn \l_tmpb_seq ? { ##1 }
      \seq_get_right:NN \l_tmpb_seq \l_tmpa_str
      \cs_if_exist:cT {
        stex_notation_ #1/\l_tmpa_str \c_hash_str\c_hash_str _cs
      }{
        \tl_if_empty:NF \l_tmpa_tl {
          \tl_put_right:Nn \l_tmpa_tl {,}
        }
        \tl_put_right:Nx \l_tmpa_tl {
          \stex_invoke_symbol:n {#1/\l_tmpa_str}!
        }
      }
    }
    \exp_args:No \mathstruct \l_tmpa_tl
  }{
    \stex_invoke_symbol:n{#1/#3}
  }
}

%%%%%%%%%%%%%   features.dtx   %%%%%%%%%%%%%

\protected\def\ignorespacesandpars{
  \begingroup\catcode13=10\relax
  \@ifnextchar\par{
    \endgroup\expandafter\ignorespacesandpars\@gobble
  }{
    \endgroup
  }
}


\def\titleemph#1{\textbf{#1}}
\keys_define:nn {stex / definiendum }{
  post    .tl_set:N     = \l__stex_statements_definiendum_post_tl,
  root    .str_set_x:N  = \l__stex_statements_definiendum_root_str,
  gfa     .str_set_x:N  = \l__stex_statements_definiendum_gfa_str
}
\cs_new_protected:Nn \__stex_statements_definiendum_args:n {
  \str_clear:N \l__stex_statements_definiendum_root_str
  \tl_clear:N \l__stex_statements_definiendum_post_tl
  \str_clear:N \l__stex_statements_definiendum_gfa_str
  \keys_set:nn { stex / definiendum }{ #1 }
}
\NewDocumentCommand \definiendum { O{} m m} {
  \__stex_statements_definiendum_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \str_if_empty:NTF \l__stex_statements_definiendum_root_str {
    \tl_if_empty:NTF \l__stex_statements_definiendum_post_tl {
      \tl_set:Nn \l_tmpa_tl { #3 }
    } {
      \str_set:Nx \l__stex_statements_definiendum_root_str { #3 }
      \tl_set:Nn \l_tmpa_tl {
        \l__stex_statements_definiendum_root_str\l__stex_statements_definiendum_post_tl
       }
    }
  } {
    \tl_set:Nn \l_tmpa_tl { #3 }
  }

  % TODO root
  \rustex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } { \l_tmpa_tl }
  } {
    \exp_args:Nnx \defemph@uri { \l_tmpa_tl } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \definiendum {definition~environments}

\cs_new:Nn \stex_capitalize:n { \uppercase{#1} }

\NewDocumentCommand \definame { O{} m } {
  \__stex_statements_definiendum_args:n { #1 }
  % TODO: root
  \stex_get_symbol:n { #2 }
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \rustex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } {
      \l_tmpa_str\l__stex_statements_definiendum_post_tl
      }
  } {
    \defemph@uri {
      \l_tmpa_str\l__stex_statements_definiendum_post_tl
    } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \definame {definition~environments}

\NewDocumentCommand \Definame { O{} m } {
  \__stex_statements_definiendum_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \stex_ref_new_sym_target:n \l_stex_get_symbol_uri_str
  \rustex_if:TF {
    \stex_annotate:nnn { definiendum } { \l_stex_get_symbol_uri_str } {
      \l_tmpa_str\l__stex_statements_definiendum_post_tl
     }
  } {
    \defemph@uri {
      \exp_after:wN \stex_capitalize:n \l_tmpa_str\l__stex_statements_definiendum_post_tl
    } { \l_stex_get_symbol_uri_str }
  }
}
\stex_deactivate_macro:Nn \Definame {definition~environments}

\NewDocumentCommand \Symname { O{} m }{
  \stex_symname_args:n { #1 }
  \stex_get_symbol:n { #2 }
  \str_set:Nx \l_tmpa_str {
    \prop_item:cn { l_stex_symdecl_ \l_stex_get_symbol_uri_str _prop } { name }
  }
  \exp_args:NNno \str_replace_all:Nnn \l_tmpa_str {-} {~}
  \let\compemph_uri_prev:\compemph@uri
  \let\compemph@uri\symrefemph@uri
  \exp_args:NNx \use:nn
  \stex_invoke_symbol:n { { \l_stex_get_symbol_uri_str }![
    \exp_after:wN \stex_capitalize:n \l_tmpa_str
      \l_stex_symname_post_str
  ] }
  \let\compemph@uri\compemph_uri_prev:
}

\keys_define:nn {stex / sdefinition }{
  type    .str_set_x:N  = \sdefinitiontype,
  id      .str_set_x:N  = \sdefinitionid,
  name    .str_set_x:N  = \sdefinitionname,
  for     .clist_set:N  = \l__stex_statements_sdefinition_for_clist ,
  title   .tl_set:N     = \sdefinitiontitle
}
\cs_new_protected:Nn \__stex_statements_sdefinition_args:n {
  \str_clear:N \sdefinitiontype
  \str_clear:N \sdefinitionid
  \str_clear:N \sdefinitionname
  \clist_clear:N \l__stex_statements_sdefinition_for_clist
  \tl_clear:N \sdefinitiontitle
  \keys_set:nn { stex / sdefinition }{ #1 }
}

\NewDocumentEnvironment{sdefinition}{O{}}{
  \__stex_statements_sdefinition_args:n{ #1 }
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \stex_reactivate_macro:N \Definame
  \stex_if_smsmode:F{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sdefinition_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{definition}{\seq_use:Nn \l_tmpa_seq {,}}
    \str_if_empty:NF \sdefinitiontype {
      \stex_annotate_invisible:nnn{type}{\sdefinitiontype}{}
    }
    \clist_set:No \l_tmpa_clist \sdefinitiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sdefinition_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sdefinition_##1_start:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sdefinition_start:
    }{
      \l_tmpa_tl
    }
  }
  \stex_ref_new_doc_target:n \sdefinitionid
  \stex_smsmode_do:
}{
  \str_if_empty:NF \sdefinitionname { \symdecl*{\sdefinitionname} }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sdefinitiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sdefinition_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sdefinition_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sdefinition_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}
\cs_new_protected:Nn \__stex_statements_sdefinition_start: {
  \par\noindent\titleemph{Definition\tl_if_empty:NF \sdefinitiontitle {
    ~(\sdefinitiontitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sdefinition_end: {\par\medskip}

\newcommand\stexpatchdefinition[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sdefinition_start: { #2 }
      \tl_set:Nn \__stex_statements_sdefinition_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sdefinition_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sdefinition_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlinedef }{
  type    .str_set_x:N  = \sdefinitiontype,
  id      .str_set_x:N  = \sdefinitionid,
  for     .clist_set:N  = \l__stex_statements_sdefinition_for_clist ,
  name    .str_set_x:N  = \sdefinitionname
}
\cs_new_protected:Nn \__stex_statements_inlinedef_args:n {
  \str_clear:N \sdefinitiontype
  \str_clear:N \sdefinitionid
  \str_clear:N \sdefinitionname
  \clist_clear:N \l__stex_statements_sdefinition_for_clist
  \keys_set:nn { stex / inlinedef }{ #1 }
}
\NewDocumentCommand \inlinedef { O{} m } {
  \begingroup
  \__stex_statements_inlinedef_args:n{ #1 }
  \stex_ref_new_doc_target:n \sdefinitionid
  \stex_reactivate_macro:N \definiendum
  \stex_reactivate_macro:N \definame
  \stex_reactivate_macro:N \Definame
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sdefinitionname { \symdecl*{\sdefinitionname} }
  }{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sdefinition_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnx
    \stex_annotate:nnn{definition}{\seq_use:Nn \l_tmpa_seq {,}}{
      \str_if_empty:NF \sdefinitiontype {
        \stex_annotate_invisible:nnn{type}{\sdefinitiontype}{}
      }
      #2
      \str_if_empty:NF \sdefinitionname { \symdecl*{\sdefinitionname} }
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\keys_define:nn {stex / sassertion }{
  type    .str_set_x:N  = \sassertiontype,
  id      .str_set_x:N  = \sassertionid,
  title   .tl_set:N     = \sassertiontitle ,
  for     .clist_set:N  = \l__stex_statements_sassertion_for_clist ,
  name    .str_set_x:N  = \sassertionname
}
\cs_new_protected:Nn \__stex_statements_sassertion_args:n {
  \str_clear:N \sassertiontype
  \str_clear:N \sassertionid
  \str_clear:N \sassertionname
  \clist_clear:N \l__stex_statements_sassertion_for_clist
  \tl_clear:N \sassertiontitle
  \keys_set:nn { stex / sassertion }{ #1 }
}


\NewDocumentEnvironment{sassertion}{O{}}{
  \__stex_statements_sassertion_args:n{ #1 }
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sassertion_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{assertion}{\seq_use:Nn \l_tmpa_seq {,}}
    \str_if_empty:NF \sassertiontype {
      \stex_annotate_invisible:nnn{type}{\sassertiontype}{}
    }
    \clist_set:No \l_tmpa_clist \sassertiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sassertion_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sassertion_##1_start:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sassertion_start:
    }{
      \l_tmpa_tl
    }
  }
  \stex_ref_new_doc_target:n \sassertionid
  \stex_smsmode_do:
}{
  \str_if_empty:NF \sassertionname { \symdecl*{\sassertionname} }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sassertiontype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sassertion_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sassertion_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sassertion_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sassertion_start: {
  \par\noindent\titleemph{Assertion~\tl_if_empty:NF \sassertiontitle {
    (\sassertiontitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sassertion_end: {\par\medskip}

\newcommand\stexpatchassertion[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sassertion_start: { #2 }
      \tl_set:Nn \__stex_statements_sassertion_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sassertion_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sassertion_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlineass }{
  type    .str_set_x:N  = \sassertiontype,
  id      .str_set_x:N  = \sassertionid,
  for     .clist_set:N  = \l__stex_statements_sassertion_for_clist ,
  name    .str_set_x:N  = \sassertionname
}
\cs_new_protected:Nn \__stex_statements_inlineass_args:n {
  \str_clear:N \sassertiontype
  \str_clear:N \sassertionid
  \str_clear:N \sassertionname
  \clist_clear:N \l__stex_statements_sassertion_for_clist
  \keys_set:nn { stex / inlineass }{ #1 }
}
\NewDocumentCommand \inlineass { O{} m } {
  \begingroup
  \__stex_statements_inlineass_args:n{ #1 }
  \stex_ref_new_doc_target:n \sassertionid
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sassertionname { \symdecl*{\sassertionname} }
  }{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sassertion_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnx
    \stex_annotate:nnn{assertion}{\seq_use:Nn \l_tmpa_seq {,}}{
      \str_if_empty:NF \sassertiontype {
        \stex_annotate_invisible:nnn{type}{\sassertiontype}{}
      }
      #2
      \str_if_empty:NF \sassertionname { \symdecl*{\sassertionname} }
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\keys_define:nn {stex / sexample }{
  type    .str_set_x:N  = \exampletype,
  id      .str_set_x:N  = \sexampleid,
  title   .tl_set:N     = \sexampletitle,
  for     .clist_set:N  = \l__stex_statements_sexample_for_clist,
}
\cs_new_protected:Nn \__stex_statements_sexample_args:n {
  \str_clear:N \sexampletype
  \str_clear:N \sexampleid
  \tl_clear:N \sexampletitle
  \clist_clear:N \l__stex_statements_sexample_for_clist
  \keys_set:nn { stex / sexample }{ #1 }
}

\NewDocumentEnvironment{sexample}{O{}}{
  \__stex_statements_sexample_args:n{ #1 }
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sexample_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{example}{\seq_use:Nn \l_tmpa_seq {,}}
    \str_if_empty:NF \sexampletype {
      \stex_annotate_invisible:nnn{type}{\sexampletype}{}
    }
    \clist_set:No \l_tmpa_clist \sexampletype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sexample_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sexample_##1_start:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sexample_start:
    }{
      \l_tmpa_tl
    }
  }
  \stex_ref_new_doc_target:n \sexampleid
  \stex_smsmode_do:
}{
  \str_if_empty:NF \sexamplename { \symdecl*{\sexamplename} }
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sexampletype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sexample_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sexample_##1_end:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sexample_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sexample_start: {
  \par\noindent\titleemph{Example~\tl_if_empty:NF \sexampletitle {
    (\sexampletitle)
  }~}
}
\cs_new_protected:Nn \__stex_statements_sexample_end: {\par\medskip}

\newcommand\stexpatchexample[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sexample_start: { #2 }
      \tl_set:Nn \__stex_statements_sexample_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sexample_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sexample_#1_end:\endcsname{ #3 }
    }
}
\keys_define:nn {stex / inlineex }{
  type    .str_set_x:N  = \sexampletype,
  id      .str_set_x:N  = \sexampleid,
  for     .clist_set:N  = \l__stex_statements_sexample_for_clist ,
  name    .str_set_x:N  = \sexamplename
}
\cs_new_protected:Nn \__stex_statements_inlineex_args:n {
  \str_clear:N \sexampletype
  \str_clear:N \sexampleid
  \str_clear:N \sexamplename
  \clist_clear:N \l__stex_statements_sexample_for_clist
  \keys_set:nn { stex / inlineex }{ #1 }
}
\NewDocumentCommand \inlineex { O{} m } {
  \begingroup
  \__stex_statements_inlineex_args:n{ #1 }
  \stex_ref_new_doc_target:n \sexampleid
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sexamplename { \symdecl*{\examplename} }
  }{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sexample_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnx
    \stex_annotate:nnn{example}{\seq_use:Nn \l_tmpa_seq {,}}{
      \str_if_empty:NF \sexampletype {
        \stex_annotate_invisible:nnn{type}{\sexampletype}{}
      }
      #2
      \str_if_empty:NF \sexamplename { \symdecl*{\sexamplename} }
    }
  }
  \endgroup
  \stex_smsmode_do:
}
\keys_define:nn { stex / sparagraph} {
  id      .str_set_x:N   = \sparagraphid ,
  title   .tl_set:N      = \l_stex_sparagraph_title_tl ,
  type    .str_set_x:N   = \sparagraphtype ,
  for     .clist_set:N   = \l__stex_statements_sparagraph_for_clist ,
  from    .tl_set:N      = \sparagraphfrom ,
  to      .tl_set:N      = \sparagraphto ,
  start   .tl_set:N      = \l_stex_sparagraph_start_tl ,
  name    .str_set:N     = \sparagraphname
}

\cs_new_protected:Nn \stex_sparagraph_args:n {
  \tl_clear:N \l_stex_sparagraph_title_tl
  \tl_clear:N \sparagraphfrom
  \tl_clear:N \sparagraphto
  \tl_clear:N \l_stex_sparagraph_start_tl
  \str_clear:N \sparagraphid
  \str_clear:N \sparagraphtype
  \clist_clear:N \l__stex_statements_sparagraph_for_clist
  \str_clear:N \sparagraphname
  \keys_set:nn { stex / sparagraph }{ #1 }
}
\newif\if@in@omtext\@in@omtextfalse

\NewDocumentEnvironment {sparagraph} { O{} } {
  \stex_sparagraph_args:n { #1 }
  \tl_if_empty:NTF \l_stex_sparagraph_start_tl {
    \tl_set_eq:NN \sparagraphtitle \l_stex_sparagraph_title_tl
  }{
    \tl_set_eq:NN \sparagraphtitle \l_stex_sparagraph_start_tl
  }
  \@in@omtexttrue
  \stex_if_smsmode:F {
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sparagraph_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnnx
    \begin{stex_annotate_env}{paragraph}{\seq_use:Nn \l_tmpa_seq {,}}
    \str_if_empty:NF \sparagraphtype {
      \stex_annotate_invisible:nnn{type}{\sparagraphtype}{}
    }
    \str_if_empty:NF \sparagraphfrom {
      \stex_annotate_invisible:nnn{from}{\sparagraphfrom}{}
    }
    \str_if_empty:NF \sparagraphto {
      \stex_annotate_invisible:nnn{to}{\sparagraphto}{}
    }
    \clist_set:No \l_tmpa_clist \sparagraphtype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \sparagraphtype {
      \tl_if_exist:cT {__stex_statements_sparagraph_##1_start:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sparagraph_##1_start:}}
      }
    }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sparagraph_start:
    }{
      \l_tmpa_tl
    }
  }
  \stex_ref_new_doc_target:n \sparagraphid
  \stex_smsmode_do:
  \ignorespacesandpars
}{
  \stex_if_smsmode:F {
    \clist_set:No \l_tmpa_clist \sparagraphtype
    \tl_clear:N \l_tmpa_tl
    \clist_map_inline:Nn \l_tmpa_clist {
      \tl_if_exist:cT {__stex_statements_sparagraph_##1_end:}{
        \tl_set:Nn \l_tmpa_tl {\use:c{__stex_statements_sparagraph_##1_end:}}
      }
    }
    \str_if_empty:NF \sparagraphname { \symdecl*{\sparagraphname} }
    \tl_if_empty:NTF \l_tmpa_tl {
      \__stex_statements_sparagraph_end:
    }{
      \l_tmpa_tl
    }
    \end{stex_annotate_env}
  }
}

\cs_new_protected:Nn \__stex_statements_sparagraph_start: {
  \par\noindent\tl_if_empty:NTF \l_stex_sparagraph_start_tl {
    \tl_if_empty:NF \l_stex_sparagraph_title_tl {
      \titleemph{\l_stex_sparagraph_title_tl}:~
    }
  }{
    \titleemph{\l_stex_sparagraph_start_tl}~
  }
}
\cs_new_protected:Nn \__stex_statements_sparagraph_end: {\par\medskip}

\newcommand\stexpatchparagraph[3][] {
    \str_set:Nx \l_tmpa_str{ #1 }
    \str_if_empty:NTF \l_tmpa_str {
      \tl_set:Nn \__stex_statements_sparagraph_start: { #2 }
      \tl_set:Nn \__stex_statements_sparagraph_end: { #3 }
    }{
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sparagraph_#1_start:\endcsname{ #2 }
      \exp_after:wN \tl_set:Nn \csname __stex_statements_sparagraph_#1_end:\endcsname{ #3 }
    }
}

\keys_define:nn { stex / inlinepara} {
  id      .str_set_x:N   = \sparagraphid ,
  type    .str_set_x:N   = \sparagraphtype ,
  for     .clist_set:N   = \l__stex_statements_sparagraph_for_clist ,
  from    .tl_set:N      = \sparagraphfrom ,
  to      .tl_set:N      = \sparagraphto ,
  name    .str_set:N     = \sparagraphname
}
\cs_new_protected:Nn \__stex_statements_inlinepara_args:n {
  \tl_clear:N \sparagraphfrom
  \tl_clear:N \sparagraphto
  \str_clear:N \sparagraphid
  \str_clear:N \sparagraphtype
  \clist_clear:N \l__stex_statements_sparagraph_for_clist
  \str_clear:N \sparagraphname
  \keys_set:nn { stex / inlinepara }{ #1 }
}
\NewDocumentCommand \inlinepara { O{} m } {
  \begingroup
  \__stex_statements_inlinepara_args:n{ #1 }
  \stex_ref_new_doc_target:n \sparagraphid
  \stex_if_smsmode:TF{
    \str_if_empty:NF \sparagraphname { \symdecl*{\sparagraphname} }
  }{
    \seq_clear:N \l_tmpa_seq
    \clist_map_inline:Nn \l__stex_statements_sparagraph_for_clist {
      \str_if_eq:nnF{ ##1 }{}{
        \stex_get_symbol:n { ##1 }
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq {
          \l_stex_get_symbol_uri_str
        }
      }
    }
    \exp_args:Nnx
    \stex_annotate:nnn{paragraph}{\seq_use:Nn \l_tmpa_seq {,}}{
      \str_if_empty:NF \sparagraphtype {
        \stex_annotate_invisible:nnn{type}{\sparagraphtype}{}
      }
      \str_if_empty:NF \sparagraphfrom {
        \stex_annotate_invisible:nnn{from}{\sparagraphfrom}{}
      }
      \str_if_empty:NF \sparagraphto {
        \stex_annotate_invisible:nnn{to}{\sparagraphto}{}
      }
      #2
      \str_if_empty:NF \sparagraphname { \symdecl*{\sparagraphname} }
    }
  }
  \endgroup
  \stex_smsmode_do:
}

\NewDocumentEnvironment{symboldoc}{ m }{
  \seq_set_split:Nnn \l_tmpa_seq , { #1 }
  \seq_clear:N \l_tmpb_seq
  \seq_map_inline:Nn \l_tmpa_seq {
    \str_if_eq:nnF{ ##1 }{}{
      \stex_get_symbol:n { ##1 }
      \exp_args:NNo \seq_put_right:Nn \l_tmpb_seq {
        \l_stex_get_symbol_uri_str
      }
    }
  }
  \par
  \exp_args:Nnnx
  \begin{stex_annotate_env}{symboldoc}{\seq_use:Nn \l_tmpb_seq {,}}
}{
  \end{stex_annotate_env}
}


%%%%%%%%%%%%%   sproof.dtx   %%%%%%%%%%%%%

\keys_define:nn { stex / spf } {
  id          .str_set_x:N  = \l__stex_sproof_spf_id_str,
  display     .tl_set:N     = \l__stex_sproof_spf_display_tl,
  for         .tl_set:N     = \l__stex_sproof_spf_for_tl ,
  from        .tl_set:N     = \l__stex_sproof_spf_from_tl ,
  proofend    .tl_set:N     = \l__stex_sproof_spf_proofend_tl,
  type        .tl_set:N     = \l__stex_sproof_spf_type_tl,
  title       .tl_set:N     = \l__stex_sproof_spf_title_tl,
  continues   .tl_set:N     = \l__stex_sproof_spf_continues_tl,
  functions   .tl_set:N     = \l__stex_sproof_spf_functions_tl,
  method      .tl_set:N     = \l__stex_sproof_spf_method_tl
}
\cs_new_protected:Nn \__stex_sproof_spf_args:n {
\str_clear:N \l__stex_sproof_spf_id_str
\tl_clear:N \l__stex_sproof_spf_display_tl
\tl_clear:N \l__stex_sproof_spf_for_tl
\tl_clear:N \l__stex_sproof_spf_from_tl
\tl_set:Nn \l__stex_sproof_spf_proofend_tl {\sproof@box}
\tl_clear:N \l__stex_sproof_spf_type_tl
\tl_clear:N \l__stex_sproof_spf_title_tl
\tl_clear:N \l__stex_sproof_spf_continues_tl
\tl_clear:N \l__stex_sproof_spf_functions_tl
\tl_clear:N \l__stex_sproof_spf_method_tl
\keys_set:nn { stex / spf }{ #1 }
}
\def\spf@flow{flow}
\newcount\count_ten
\newenvironment{pst@with@label}[1]{
  \edef\pst@label{#1}
  \advance\count_ten by 1\relax
  \count_ten=1
}{
  \advance\count_ten by -1\relax
}
\def\the@pst@label{
  \pst@make@label\pst@label{\number\count_ten}\l__stex_sproof_pstlabel_postfix_tl
}
\keys_define:nn { stex / pstlabel }{
  prefix      .tl_set:N   = \l__stex_sproof_pstlabel_prefix_tl,
  delimiter   .tl_set:N   = \l__stex_sproof_pstlabel_delimiter_tl,
  postfix     .tl_set:N   = \l__stex_sproof_pstlabel_postfix_tl
}
\cs_new_protected:Nn \__stex_sproof_pstlabel_args:n {
  \tl_set:Nn \l__stex_sproof_pstlabel_prefix_tl {P}
  \tl_set:Nn \l__stex_sproof_pstlabel_delimiter_tl {.}
  \tl_clear:N \l__stex_sproof_pstlabel_postfix_tl
}
\__stex_sproof_pstlabel_args:n {}
\newcommand\setpstlabelstyle[1]{
  \__stex_sproof_pstlabel_args:n {#1}
}
\newcommand\setpstlabelstyledefault{%
  \__stex_sproof_pstlabel_args:n{prefix=P,delimiter=.,postfix={}}
}
\ExplSyntaxOff
\def\pst@make@label@long#1#2{\@for\@I:=#1\do{\expandafter\expandafter\expandafter\@I\csname l__stex_sproof_pstlabel_delimiter_tl\endcsname}#2}
\def\pst@make@label@angles#1#2{\ensuremath{\@for\@I:=#1\do{\rangle}}#2}
\def\pst@make@label@short#1#2{#2}
\def\pst@make@label@empty#1#2{}
\ExplSyntaxOn
\def\pstlabelstyle#1{%
  \def\pst@make@label{\use:c{pst@make@label@#1}}%
}%
\pstlabelstyle{long}%
\def\next@pst@label{%
  \global\advance\count\count10 by 1%
}%
\def\sproof@box{
  \hbox{\vrule\vbox{\hrule width 6 pt\vskip 6pt\hrule}\vrule}
}
\def\spf@proofend{\sproof@box}
\def\sproofend{
  \tl_if_empty:NF \l__stex_sproof_spf_proofend_tl {
    \hfil\null\nobreak\hfill\l__stex_sproof_spf_proofend_tl\par\smallskip
  }
}
\def\sProofEndSymbol#1{\def\sproof@box{#1}}
\def\spf@proofsketch@kw{Proof Sketch}
\def\spf@proof@kw{Proof}
\def\spf@step@kw{Step}
\AddToHook{begindocument}{
  \ltx@ifpackageloaded{babel}{
    \makeatletter
    \clist_set:Nx \l_tmpa_clist {\bbl@loaded}
    \clist_if_in:NnT \l_tmpa_clist {ngerman}{
      \input{sproof-ngerman.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {finnish}{
      \input{sproof-finnish.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {french}{
      \input{sproof-french.ldf}
    }
    \clist_if_in:NnT \l_tmpa_clist {russian}{
      \input{sproof-russian.ldf}
    }
    \makeatother
  }{}
}
\newcommand\spfsketch[2][]{
  \__stex_sproof_spf_args:n{#1}
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \titleemph{
      \tl_if_empty:NTF \l__stex_sproof_spf_type_tl {
        \spf@proofsketch@kw
      }{
        \l__stex_sproof_spf_type_tl
      }
    }:
  }
  {~#2}
  %\sref@label@id{this \ifx\spf@type\@empty\spf@proofsketch@kw\else\spf@type\fi}
  \sproofend
}
\newenvironment{spfeq}[2][]{
  \__stex_sproof_spf_args:n{#1}
  %\sref@target
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \titleemph{
      \tl_if_empty:NTF \l__stex_sproof_spf_type_tl {
        \spf@proof@kw
      }{
        \l__stex_sproof_spf_type_tl
      }
    }:
  }
  {~#2}
  \begin{displaymath}\begin{array}{rcll}
}{
  \end{array}\end{displaymath}
}
\newenvironment{spf@proof}[2][]{
  \__stex_sproof_spf_args:n{#1}
  %\sref@target
  \count_ten=10
  \par\noindent
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \titleemph{
      \tl_if_empty:NTF \l__stex_sproof_spf_type_tl {
        \spf@proof@kw
      }{
        \l__stex_sproof_spf_type_tl
      }
    }:
  }
  {~#2}
  %\sref@label@id{this \ifx\spf@type\@empty\spf@proof@kw\else\spf@type\fi}
  \def\pst@label{}
  \newcount\pst@count% initialize the labeling mechanism
  \begin{description}\begin{pst@with@label}{\l__stex_sproof_pstlabel_prefix_tl}
}{
  \end{pst@with@label}\end{description}
}
\newenvironment{sproof}[2][]{\begin{spf@proof}[#1]{#2}}{\sproofend\end{spf@proof}}
\newenvironment{sProof}[2][]{\begin{spf@proof}[#1]{#2}}{\end{spf@proof}}
\newcommand\spfidea[2][]{
  \__stex_sproof_spf_args:n{#1}
  \titleemph{
    \tl_if_empty:NTF \l__stex_sproof_spf_type_tl {Proof~Idea}{
      \l__stex_sproof_spf_type_tl
    }:
  }~#2
  \sproofend
}
\newenvironment{spfstep}[1][]{
  \__stex_sproof_spf_args:n{#1}
  \@in@omtexttrue
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \item[\the@pst@label]
  }
  \tl_if_empty:NF \l__stex_sproof_spf_title_tl {
    {(\titleemph{\l__stex_sproof_spf_title_tl})\enspace}
  }
  %\sref@label@id{\pst@label}
  \ignorespacesandpars
}{
  \next@pst@label\ignorespacesandpars
}
\newenvironment{sproofcomment}[1][]{
  \__stex_sproof_spf_args:n{#1}
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \item[\the@pst@label]
  }
}{
  \next@pst@label
}
\newenvironment{subproof}[2][]{
  \__stex_sproof_spf_args:n{#1}
  \def\@test{#2}
  \ifx\@test\empty\else
    \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
      \item[\the@pst@label]
    }{#2}
  \fi
  \begin{pst@with@label}{\pst@label,\number\count_ten}
}{
  \end{pst@with@label}\next@pst@label
}
\newenvironment{spfcases}[2][]{
  \def\@test{#1}
  \ifx\@test\empty
    \begin{subproof}[method=by-cases]{#2}
  \else
    \begin{subproof}[#1,method=by-cases]{#2}
  \fi
}{
  \end{subproof}
}
\newenvironment{spfcase}[2][]{
  \__stex_sproof_spf_args:n{#1}
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \item[\the@pst@label]
  }
  \def\@test{#2}
  \ifx\@test\@empty
  \else
    {\titleemph{#2}:~}
  \fi
  \begin{pst@with@label}{\pst@label,\number\count_ten}
}{
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \sproofend
  }
  \end{pst@with@label}
  \next@pst@label
}
\newcommand\spfcasesketch[3][]{
  \__stex_sproof_spf_args:n{#1}
  \tl_if_eq:NNF \l__stex_sproof_spf_display_tl\spf@flow{
    \item[\the@pst@label]
  }
  \def\@test{#2}
  \ifx\@test\@empty
  \else
    {\titleemph{#2}:~}
  \fi#3
  \next@pst@label
}%
\keys_define:nn { stex / just }{
  id        .str_set_x:N  = \l__stex_sproof_just_id_str,
  method    .tl_set:N     = \l__stex_sproof_just_method_tl,
  premises  .tl_set:N     = \l__stex_sproof_just_premises_tl,
  args      .tl_set:N     = \l__stex_sproof_just_args_tl
}
\newenvironment{justification}[1][]{}{}
\newcommand\premise[2][]{#2}
\newcommand\justarg[2][]{#2}

%%%%%%%%%%%%%   others.dtx   %%%%%%%%%%%%%

  % None
\NewDocumentCommand \MSC {m} {
  % TODO
}
\@ifpackageloaded{tikzinput}{
  \RequirePackage{stex-tikzinput}
}{}

%%%%%%%%%%%%%   metatheory.dtx   %%%%%%%%%%%%%

\str_const:Nn \c_stex_metatheory_ns_str {http://mathhub.info/sTeX}
\begingroup
\stex_module_setup:nn{
  ns=\c_stex_metatheory_ns_str,
  meta=NONE
}{Metatheory}
\stex_reactivate_macro:N \symdecl
\stex_reactivate_macro:N \notation
\stex_reactivate_macro:N \symdef
\ExplSyntaxOff
\csname stex_suppress_html:n\endcsname{
  % is-a (a:A, a \in A, a is an A, etc.)
  \symdecl[args=ai]{isa}
  \notation[typed]{isa}{#1 \comp{:} #2}{#1 \comp, #2}
  \notation[in]{isa}{#1 \comp\in #2}{#1 \comp, #2}
  \notation[pred]{isa}{#2\comp(#1 \comp)}{#1 \comp, #2}

  % bind (\forall, \Pi, \lambda etc.)
  \symdecl[args=Bi]{bind}
  \notation[forall]{bind}{\comp\forall #1.\;#2}{#1 \comp, #2}
  \notation[Pi]{bind}{\comp\prod_{#1}#2}{#1 \comp, #2}
  \notation[depfun]{bind}{\comp( #1 \comp{)\;\to\;} #2}{#1 \comp, #2}

  % dummy variable
  \symdecl{dummyvar}
  \notation[underscore]{dummyvar}{\comp\_}
  \notation[dot]{dummyvar}{\comp\cdot}
  \notation[dash]{dummyvar}{\comp{{\rm --}}}

  %fromto (function space, Hom-set, implication etc.)
  \symdecl[args=ai]{fromto}
  \notation[xarrow]{fromto}{#1 \comp\to #2}{#1 \comp\times #2}
  \notation[arrow]{fromto}{#1 \comp\to #2}{#1 \comp\to #2}

  % mapto (lambda etc.)
  %\symdecl[args=Bi]{mapto}
  %\notation[mapsto]{mapto}{#1 \comp\mapsto #2}{#1 \comp, #2}
  %\notation[lambda]{mapto}{\comp\lambda #1 \comp.\; #2}{#1 \comp, #2}
  %\notation[lambdau]{mapto}{\comp\lambda_{#1} \comp.\; #2}{#1 \comp, #2}

  % function/operator application
  \symdecl[args=ia]{apply}
  \notation[prec=0;0x\infprec,parens]{apply}{#1 \comp( #2 \comp)}{#1 \comp, #2}
  \notation[prec=0;0x\infprec,lambda]{apply}{#1 \; #2 }{#1 \; #2}

  % ``type'' of all collections (sets,classes,types,kinds)
  \symdecl{collection}
  \notation[U]{collection}{\comp{\mathcal{U}}}
  \notation[set]{collection}{\comp{\textsf{Set}}}

  % sequences
  \symdecl[args=1]{seqtype}
  \notation[kleene]{seqtype}{#1^{\comp\ast}}

  \symdef[args=2,li,prec=nobrackets]{sequence-index}{{#1}_{#2}}
  \notation[ui,prec=nobrackets]{sequence-index}{{#1}^{#2}}

  %\symdef[args=3,li]{sequence-from-to}{#1_{#2}\comp{,\ellipses,}#1_{#3}}
  %\notation[ui]{sequence-from-to}{#1^{#2}\comp{,\ellipses,}#1^{#3}}
  % ^ superceded by \aseqfromto and \livar/\uivar

  \symdef[args=a,prec=nobrackets]{aseqdots}{#1\comp{,\ellipses}}{#1\comp,#2}
  \symdef[args=ai,prec=nobrackets]{aseqfromto}{#1\comp{,\ellipses,}#2}{#1\comp,#2}
  \symdef[args=aii,prec=nobrackets]{aseqfromtovia}{#1\comp{,\ellipses,}#2\comp{,\ellipses,}#3}{#1\comp,#2}

  % letin (``let'', local definitions, variable substitution)
  \symdecl[args=bii]{letin}
  \notation[let]{letin}{\comp{{\rm let}}\;#1\comp{=}#2\;\comp{{\rm in}}\;#3}
  \notation[subst]{letin}{#3 \comp[ #1 \comp/ #2 \comp]}
  \notation[frac]{letin}{#3 \comp[ \frac{#2}{#1} \comp]}

  % structures
  \symdecl*[args=1]{module-type}
  \notation{module-type}{\mathtt{MOD} #1}
  \symdecl[name=mathematical-structure,args=a]{mathstruct} % TODO
  \notation[angle,prec=nobrackets]{mathstruct}{\comp\langle #1 \comp\rangle}{#1 \comp, #2}

}
  \ExplSyntaxOn
  \stex_add_to_current_module:n{
    \let\nappa\apply
    \def\nappli#1#2#3#4{\apply{#1}{\naseqli{#2}{#3}{#4}}}
    \def\nappui#1#2#3#4{\apply{#1}{\nasequi{#2}{#3}{#4}}}
    \def\livar{\csname sequence-index\endcsname[li]}
    \def\uivar{\csname sequence-index\endcsname[ui]}
    \def\naseqli#1#2#3{\aseqfromto{\livar{#1}{#2}}{\livar{#1}{#3}}}
    \def\nasequi#1#2#3{\aseqfromto{\uivar{#1}{#2}}{\uivar{#1}{#3}}}
    \def\nappe#1#2#3{\apply{#1}{\aseqfromto{#2}{#3}}}
  }
\__stex_modules_end_module:
\endgroup

\endinput
%%
%% End of file `stex.sty'.
