\begin{smodule}{Aux Macros}
  \importmodule[sTeX/Documentation]{macros?AllMacros}

  \CodedocExplain

  %^^A\CodedocExplainEXP
  %^^A\CodedocExplainREXP
  %^^A\CodedocExplainTF

  \begin{sfunction}{stex_debug:nn}{\stex_debug:nn}
    \begin{syntax}
      \dcs \marg{prefix} \marg{msg}
    \end{syntax}
    Logs the debug message \marg{msg} under the prefix
    \marg{prefix}. A message is shown if its prefix
    is in a list of prefixes given either via the
    package option |debug=|\meta{prefixes} or
    the environment variable |STEX_DEBUG=|\meta{prefixes},
    where the latter overrides the former.
  \end{sfunction}

  \begin{sfunction}{_stex_do_deprecation:n}{\_stex_do_deprecation:n}
    TODO \dcs
  \end{sfunction}

\begin{sfragment}{Documents}

  \begin{svariable}{l_stex_docheader_sect}{\l_stex_docheader_sect}
    integer register keeping track of the current sectioning level:
    \begin{itemize}
      \item[0] part
      \item[1] chapter
      \item[2] section
      \item[3] subsection
      \item[4] subsubsection
      \item[5] paragraph
      \item[$>5$] subparagraph
    \end{itemize}
    \cs{setsectionlevel} sets \cs{l_stex_docheader_sect} to the corresponding
    integer value.
  \end{svariable}

  \begin{sfunction}{stex_ref_new_doc_target:n}{\stex_ref_new_doc_target:n}
    internal variant of \cs{sreflabel}. If the argument is empty,
    the label is determined to be |REF|\meta{counter}
    and \meta{counter} is increased.
  \end{sfunction}

  \begin{sfunction}{stex_ref_new_symbol:n}{\stex_ref_new_symbol:n}
    registers a new link target for the symbol with the given full uri 
    (as string), using the |url-base|-field of the current
    archive's manifest file to link the symbol to
    \meta{url-base}|/symbol?|\meta{uri}.
  \end{sfunction}

  \begin{sfunction}{stex_ref_new_sym_target:n}{\stex_ref_new_sym_target:n}
    sets a new label for the symbol with the given full uri (as string).
    If called in sms-mode, defers to \cs{stex_ref_new_symbol:n},
    if not already registered. 
    Otherwise, sets a \cs{label} for the symbol.
  \end{sfunction}

  \begin{sfunction}{stex_ref_new_sym_target:nn}{\stex_ref_new_sym_target:nn}
    \begin{syntax}\dcs\marg{symbol}\marg{target}
    \end{syntax}
    redirects links for \meta{symbol} to the one for the symbol
    \meta{target}. Useful for e.g. symbols elaborated from
    structural features. Note that this acts as a \emph{default},
    in that previous or subsequent 
    calls of \cs{stex_ref_new_sym_target:n}\marg{symbol}
    are prioritized.

    Requires that either \cs{stex_ref_new_sym_target:n}\marg{target}
    or
    \cs{stex_ref_new_sym_target:nn}\marg{target}\marg{other-target}
    have been called previously.
  \end{sfunction}

\end{sfragment}

\begin{sfragment}{Modules}

  \stexmacro{stex_add_module_decl:nnnnnnN}
  \stexmacro{stex_add_module_notation:nnnnn}
  \stexmacro{stex_add_module_dependency:nnn}

  The contents of a module with full URI
  \meta{uri} are represented as four macros:
  \begin{itemize}
    \item |\c_stex_module_|\meta{uri}|_code|: code to be executed
      every time the module is \emph{activated}; e.g. the contents
      of \cs{STEXexport}, defines semantic macros and macros for
      notations, activates dependency modules, etc.
    \item |\c_stex_module_|\meta{uri}|_dependencies_prop|: property list
      containing all module dependencies of this module 
      (see \cs{stex_add_module_dependency:nnn}).
    \item |\c_stex_module_|\meta{uri}|_declarations_prop|: property list
      containing all declarations in this module (see \cs{stex_add_module_decl:nnnnnnN}).
    \item |\c_stex_module_|\meta{uri}|_notations_prop|: property list
      containing all notations introduced in this module
      (see \cs{stex_add_module_notation:nnnnn}).
  \end{itemize}

  \begin{svariable}{l_stex_current_module_str}{\l_stex_current_module_str}
    contains the full URI of the current module.
  \end{svariable}

  \begin{svariable}{l_stex_all_modules_seq}{\l_stex_all_modules_seq}
    contains the full URIs of all modules currently in scope.
  \end{svariable}

  \stexmacro{l_stex_key_sig_str}
  \begin{sfunction}{stex_module_setup:n}{\stex_module_setup:n}
    \begin{syntax} \dcs\marg{name} \end{syntax}
    Computes the full URI of a new module with name \meta{name}
    in the current namespace, initializes the
    four macros above and sets \cs{l_stex_current_module_str}
    accordingly. Also takes care of correct naming for nested
    modules, activates the meta theory and loads the signature module 
    if |sig=| was provided (according to \cs{l_stex_key_sig_str}).
  \end{sfunction}

  \stexmacro{stex_persist:n}
  \begin{sfunction}{stex_close_module:}{\stex_close_module:}
    closes the current module; checks whether we are currently in
    sms mode, and if so, calls \cs{stex_persist:n} 
    to write the module contents to the sms-file.
  \end{sfunction}

  \begin{sfunction}{stex_every_module:n}{\stex_every_module:n}
    \begin{syntax}\dcs\marg{code}\end{syntax}
    executes \meta{code} every time a new module is opened.
  \end{sfunction}

  \begin{sfunction}{stex_if_in_module:}[pTF]{\stex_if_in_module:}
    tests whether we are currently in a module.
  \end{sfunction}

  \begin{sfunction}{stex_if_module_exists:n}[pTF]{\stex_if_module_exists:n}
    tests whether a module with the given full URI exists, in the sense
    of \emph{has been parsed at some point in the current document}.
  \end{sfunction}

  \begin{sfunction}{stex_activate_module:n}{\stex_activate_module:n,\stex_activate_module:o,\stex_activate_module:x}
    activates the module with the given full URI \emph{if and only if}
    it has not already been activated in the current scope.
  \end{sfunction}

  \stexmacro{stex_metagroup_do_in:nn}

  \begin{sfragment}{Adding Activation Code to Modules}

  \begin{sfunction}{stex_execute_in_module:n}{\stex_execute_in_module:n,\stex_execute_in_module:x}
    executes the provided code, adds it to the current module
    activation code, and makes
    sure the macros defined in it are valid in the current module 
    \TeX\ group level.
  \end{sfunction}

  This macro is a combination of the following two macros:

  \begin{sfunction}{stex_do_up_to_module:n}{\stex_do_up_to_module:n,\stex_do_up_to_module:x}
    executes the provided code such that all definitions in it
    are valid in the current module regardless of \TeX\ group level
    (using \cs{stex_metagroup_do_in:nn}).
  \end{sfunction}

  \begin{sfunction}{stex_add_to_current_module:n}{\stex_add_to_current_module:n,\stex_add_to_current_module:x}
    adds the provided code to the module's
    |\c_stex_module_|\meta{uri}|_code|-macro.
  \end{sfunction}

  \end{sfragment}

  \begin{sfragment}{Adding Module Dependencies to a Module}
    \begin{sfunction}{stex_add_module_dependency:nnnn}{\stex_add_module_dependency:nnnn, \stex_add_module_dependency:nonn, \stex_add_module_dependency:oonn}
      adds a new module dependency to the current module
      \begin{arguments}
        \item The name of the dependency (may be empty for e.g. \cs{importmodule},
          but may be named for e.g. \env{copymodule}),
        \item the URI of the module being ``imported'',
        \item the ``type'' of the dependency (e.g. |import| or |copymdule|),
        \item a list of assignments as pairs 
          |{|\meta{source}|}{|\meta{target}|}| that signify that
          the symbol with full URI \meta{source} is being mapped or elaborated to
          the new symbol with name \meta{target} in the current module.
          May be empty for e.g. \cs{importmodule}.
      \end{arguments}
      The provided arguments are stored in 
      |\c_stex_module_|\meta{uri}|_dependencies_prop|
      with key |#1| (if non-empty) or |[#2]| (if |#1| is empty)
      and value |{#1}{#2}{#3}{#4}|
    \end{sfunction}
  \end{sfragment}

\end{sfragment}

\begin{sfragment}{Symbols}

  \begin{sfragment}{Adding Symbols to a Module}
  \end{sfragment}

  \begin{sfragment}{Iterating Over Symbols}
  \end{sfragment}

\end{sfragment}

\begin{sfragment}{Notations}

  \begin{sfragment}{Adding Notations to a Module}
  \end{sfragment}

  \begin{sfragment}{Iterating Over Notations}
  \end{sfragment}

\end{sfragment}


\begin{sfragment}{Optional (Key-Value) Argument Handling}
  \LaTeX3 is surprisingly weak when it comes to handling
  optional (key-val) arguments in such a manner that
  \emph{only} the freshly set macros are defined, and to modularly
  build up sets of argument keys. The following macros attempt
  to fix that:

  \begin{sfunction}{stex_keys_define:nnnn,stex_keys_set:nn}{\stex_keys_define:nnnn,\stex_keys_set:nn}
    \begin{syntax}
      \dcs\marg{id}\marg{setup code}
        \marg{keyval setup code}\marg{parents}
    \end{syntax}
    Defines a set of keys and their allowed values with 
    identifier |stex/|\meta{id}, that inherits from
    the sets with identifiers in \meta{parents}.

    \dcs[stex_keys_set:nn]\marg{id}\marg{CSL} first executes
    \meta{setup code} (e.g. to empty the macros holding the values) 
    and then sets the keys in
    set \meta{id} with the values provided in \meta{CSL}.
  \end{sfunction}

  \stexvarmacro{l_stex_key_id_str}

  \begin{sfunction}{_stex_do_id:}{\_stex_do_id:}
    should be called whenever a macro or environment has a label id,
    i.e. calls \cs{stex_keys_set:nn}|{id}{...}|, after
    the title has been typeset. Sets a \cs{label} by calling
    \cs{stex_ref_new_doc_target:n}\marg{id}.
  \end{sfunction}

  \begin{sexample}
    If we define a set of keys with:
    \stexvarmacro{l_stex_key_archive_str}
    \stexvarmacro{l_stex_key_file_str}
    \begin{stexcode}[gobble=6]
      |\cs{stex_keys_define:nnnn}|{archive file}{
        \str_clear:N |\cs{l_stex_key_archive_str}|
        \str_clear:N |\cs{l_stex_key_file_str}|
      }{
        archive .str_set_x:N = |\cs{l_stex_key_archive_str}| ,
        file    .str_set_x:N = |\cs{l_stex_key_file_str}|
      }{id}
    \end{stexcode}
    then calling \cs{stex_keys_set:nn}|{archive file}{id=foo,file=bar}|
    sets \cs{l_stex_key_file_str}|={bar}|, assures that
    \cs{l_stex_key_archive_str} is empty, and executes the
    code associated with |id|, i.e. it sets
    \cs{l_stex_key_id_str}|={foo}|.
  \end{sexample}

\end{sfragment}

\begin{sfragment}{Stylable Commands and Environments}

  \stexmacro{stex_style_apply:}

  \begin{sfunction}{stex_new_stylable_cmd:nnnn,l_stex_key_style_clist}{\stex_new_stylable_cmd:nnnn}
    \begin{syntax}
      \dcs\marg{name}\marg{arity}\marg{code}
        \marg{default}
    \end{syntax}
    Creates a new macro \cs{}\meta{name} with expansion \meta{code} taking 
    \meta{arity} many arguments, that is customizable in presentation 
    by a user by calling \cs{stexstyle}\meta{name}.
    On calling
    \cs{stex_style_apply:} executes the presentation code provided
    by a user.

    \meta{code} should:
    \begin{itemize}
      \item Call \cs{stex_keys_set:nn}|{style}{...}| (or a keyset inheriting
        from |style|),
      \item set macros with prefix |\this...| that a user might want
        to use for presentation (e.g. \cs{thistitle}),
      \item call \cs{stex_style_apply:} at some point.
    \end{itemize}
  \end{sfunction}

  \begin{sfunction}{stex_new_stylable_env:nnnnnnn}{\stex_new_stylable_env:nnnnnnn}
    \begin{syntax}
      \dcs\marg{name}\marg{arity}\marg{begincode}
        \marg{endcode}\marg{default begin}\marg{default end}\marg{prefix}
    \end{syntax}

    Like \cs{stex_new_stylable_cmd:nnnn}, but defines a new environment
    |{|\meta{prefix}\meta{name}|}| stylable via
    \cs{stexstyle}\meta{name}. Should call \cs{stex_style_apply:} twice;
    once in the \meta{begincode} and once in \meta{endcode}.
  \end{sfunction}

  \begin{sfunction}{stex_style_apply:}{\stex_style_apply:}
    Sets \cs{thisstyle} to be the head of the CSL
    \cs{l_stex_key_style_clist} and checks whether a style
    for the current stylable macro/environment has been defined;
    if not, executes the code for the default style.
  \end{sfunction}

  \begin{sexample}
    \cs{importmodule} is defined something like the following:
    \begin{stexcode}[gobble=6]
      |\cs{stex_new_stylable_cmd:nnnn}|{importmodule}{O{} m}{
        ... 
        \def|\cs{thismoduleuri}|{...}
        \def|\cs{thismodulename}|{...}
        |\cs{stex_style_apply:}|
        ...
      }{}
    \end{stexcode}
    A user can then customize the output generated by \cs{importmodule}
    (by default none) via 
    \cs{stexstyleimportmodule}|{...|\cs{thismodulename}|...}|.
  \end{sexample}

  \begin{sexample}
    \env{smodule} does something like
    \begin{stexcode}[gobble=6]
      |\cs{stex_new_stylable_env:nnnnnnn}|{module}{O{} m}{
        ... 
        \def|\cs{thismoduleuri}|{...}
        \def|\cs{thismodulename}|{...}
        |\cs{stex_style_apply:}|
        ...
      }{
        ...
        |\cs{stex_style_apply:}|
        ...
      }{}{}{s}
    \end{stexcode}
    which defines the environment name to be \env{smodule} and
    generates \cs{stexstylemodule}.
  \end{sexample}

\end{sfragment}

\begin{sfragment}{Math Archives}
  Math archives are represented as \LaTeX3 property lists,
  the keys/values of which correspond to the entries in the
  archive's manifest file. The most important fields are
  \begin{itemize}
    \item |id|,
    \item |narr| the document namespace,
    \item |ns| the content namespace, and
    \item |docurl| the document URL base.
  \end{itemize}

  \stexvarmacro{target}
  \begin{sfunction}{stex_resolve_path_pair:Nnn}{\stex_resolve_path_pair:Nnn,\stex_resolve_path_pair:Nxx}
      \begin{syntax}\dcs\marg{\cs{target}}\marg{archive-id}\marg{pathstring}
      \end{syntax}
      computes the absolute file path of
      \meta{pathstring} relative
      to the |source|-folder of \meta{archive-id} (if non-empty), 
      or the current archive (if existent) or the parent working 
      directory (otherwise), and stores the result in \cs{target}.
  \end{sfunction}

  \begin{svariable}{l_stex_current_archive_prop}{\l_stex_current_archive_prop}
    \dcs always points to the current math archive or is \cs{undefined},
    if the current file is not part of a math archive.
  \end{svariable}

  \begin{svariable}{c_stex_main_archive_prop}{\c_stex_main_archive_prop}
    \dcs represents the math archive in which the main file
    resides (if existent).
  \end{svariable}

  \begin{sfunction}{stex_require_archive:n}{\stex_require_archive:n,\stex_require_archive:o}
    \begin{syntax}\dcs\marg{id}
    \end{syntax}
    looks for a math archive \meta{id} in the MathHub directory,
    parses its manifest file, creates the corresponding property
    list |\c_stex_mathhub_|\meta{id}|_manifest_prop|,
    and throws a fatal error if the archive is not found.

    If the archive has been found and parsed before, does nothing,
    so it is cheap and safe to call repeatedly for the same id.
  \end{sfunction}

  \begin{sfunction}{stex_set_current_archive:n}{\stex_set_current_archive:n}
    \begin{syntax}\dcs\marg{id}
    \end{syntax}
    Calls \cs{stex_require_archive:n}\marg{id} and sets
    \cs{l_stex_current_archive_prop}.
  \end{sfunction}

  \begin{sfunction}{stex_in_archive:nn}{\stex_in_archive:nn}
    \begin{syntax}\dcs\marg{opt-id}\marg{code}
    \end{syntax}
    Executes \meta{code} in the context of math archive \meta{opt-id}
    (using \cs{stex_require_archive:n}), i.e.
    iff \meta{opt-id} is non-empty, changes the current archive
    to the one with id \meta{opt-id},
    call \meta{code} with \meta{opt-id} as argument (in |#1|) and changes
    it back afterwards.

    If \meta{opt-id} is empty, \meta{code} is called with the id
    of the \emph{current} math archive as |#1|, or with |#1| empty
    if there is no current math archive.
  \end{sfunction}

\end{sfragment}

\begin{sfragment}{SMS-Mode}
  \stex has to extract formal content (i.e. modules and their symbols)
  from \LaTeX-files, that may otherwise contain arbitrary
  code, including macros that may not be defined unless
  the file is fully processed by \TeX. Those
  modules and symbols also may depend on other modules that have not yet
  been loaded. The naive way to achieve this, which would
  be to just suppress output (e.g. by storing it in a box register)
  and then \cs{input} the required file, does not work thanks to
  \TeX's limited \emph{file stack}, which would overflow quickly
  for modules that have a deeply nested list of dependencies.

  To solve those problems, \sTeX reads dependencies in what we call
  \emph{sms mode}, which can be summarized thusly:
  \begin{itemize}
    \item In a first pass, we parse the file token by token, ignoring everything
      other than a select list of macros and environments that
      introduce dependencies (such as \cs{importmodule} and
      \cs{begin}|{|\env{smodule}|}[sig=...]|). Instead of loading
      those, we remember them for later.
    \item After the file as been fully parsed thusly, the
      dependencies found are loaded, again in sms-mode.
    \item In a second pass, we parse the file \emph{again} in the same way, but
      this time execute all macros that are explicitly allowed
      in sms mode, such as \cs{importmodule}, \cs{symdecl},
      \cs{notation}, \cs{symdef}, etc.
    \item all this parsing happens additionally in a
      \cs{setbox}\cs{throwaway}\cs{vbox}|{...}|-block to
      suppress any accidental output.
  \end{itemize}
  This means that \TeX's input stack never grows by more
  than $+1$, but still behaves \emph{as if} the dependencies
  were loaded recursively, at the detriment of being somewhat slow.

  \begin{sfunction}{stex_if_smsmode:}[pTF]{\stex_if_smsmode:}
    tests for whether we are currently in sms-mode.
  \end{sfunction}

  \begin{sfunction}{stex_file_in_smsmode:nn}{\stex_file_in_smsmode:nn,\stex_file_in_smsmode:on}
    \begin{syntax}\dcs\marg{filestring}\marg{setup-code}\end{syntax}
    sets up sms-mode and internal grouping, calls 
    \meta{setup-code} and subsequently processes the file
    \meta{filestring} in sms-mode as described above.
  \end{sfunction}

  \begin{sfragment}{Second Pass}

  \stexvarmacro{macro}

  \begin{sfunction}{stex_sms_allow:N}{\stex_sms_allow:N}
    \begin{syntax}\dcs\marg{\cs{macro}}\end{syntax}
    registers the \cs{macro}-command to be allowed in sms mode.

    This only works, if \cs{macro} takes no arguments and/or
    does not touch the subsequent tokens.
  \end{sfunction}

  For macros taking arguments, we can use

  \stexmacro{stex_smsmode_do:}

  \begin{sfunction}{stex_sms_allow_escape:N}{\stex_sms_allow_escape:N}
    \begin{syntax}\dcs\marg{\cs{macro}}\end{syntax}
    registers the \cs{macro}-command to be allowed in sms mode.

    If \cs{macro} is subsequently encountered in sms-mode,
    parsing is halted and \cs{macro} can process arguments as desired.
    It then needs to continue parsing manually though, by calling
    \cs{stex_smsmode_do:} as (usually) its last token.
  \end{sfunction}

  \begin{sfunction}{stex_sms_allow_env:n}{\stex_sms_allow_env:n}
    \begin{syntax}\dcs\marg{envname}\end{syntax}
    registers the environment \meta{envname} to be allowed in sms mode.

    As with \cs{stex_sms_allow_escape:N}, the \cs{begin}|{|\meta{envname}|}|
    is escaped, hence the begin-code of the environment needs to call
    \cs{stex_smsmode_do:}. Since 
    \cs{end}|{|\meta{envname}|}| never takes arguments, it does not
    need to be escaped.
  \end{sfunction}

  \begin{sfunction}{stex_smsmode_do:}{\stex_smsmode_do:}
    continues with sms-mode-style parsing. Does nothing if not in
    sms-mode, and is therefore safe to be called ``just in case''.
  \end{sfunction}

  \end{sfragment}
  \begin{sfragment}{First Pass}

  \stexmacro{g_stex_sms_import_code}
  \begin{sfunction}{stex_sms_allow_import:Nn,stex_sms_allow_import_env:nn}{\stex_sms_allow_import:Nn,\stex_sms_allow_import_env:nn}
    behave like \cs{stex_sms_allow_escape:N} and
    \cs{stex_sms_allow_env:n} respectively, but the macro or environment
    provided is now allowed in the \emph{first} pass of sms-mode.

    This macro should process arguments, add content to
    \cs{g_stex_sms_import_code}, and finally call \cs{stex_smsmode_do:}.

    The code provided in the \emph{second} argument is called
    before the first pass of sms-mode, as to set up functionality
    for these macros. For example, \cs{importmodule}
    provides code that redefines \cs{importmodule} to
    store the identified dependency in 
    \cs{g_stex_sms_import_code} instead of activating it directly.
  \end{sfunction}

  \begin{svariable}{g_stex_sms_import_code}{\g_stex_sms_import_code}
    is built up in the first pass of sms mode and called subsequently;
    before the second pass.

    Code in this token list should load and activate dependencies
    found in the first pass.
  \end{svariable}

  \end{sfragment}

\end{sfragment}

\begin{sfragment}{Strings, File Paths, URIs}

  \begin{sfunction}{stex_str_if_starts_with:nn}[pTF]{\stex_str_if_starts_with:nn}
    \begin{syntax}\dcs\marg{first}\marg{second}
    \end{syntax}
      Checks whether the string \meta{first} starts with the string
      \meta{second} (i.e. \meta{second} is a prefix of \meta{first}).
  \end{sfunction}

  \begin{sfunction}{stex_str_if_ends_with:nn}[pTF]{\stex_str_if_ends_with:nn}
    \begin{syntax}\dcs\marg{first}\marg{second}
    \end{syntax}
      Checks whether the string \meta{first} ends with the string
      \meta{second} (i.e. \meta{second} is a suffix of \meta{first}).
  \end{sfunction}

  \begin{sfragment}{File Paths}

  \emph{File paths} are represented as \LaTeX3 sequences. The following
  methods make sure to
  \begin{itemize}
    \item canonicalize paths, i.e. resolve |..| and |.| segments,
    \item set all category codes to 12 (other), and
    \item tranform windows file paths containing |\| uniformly to |/|.
  \end{itemize}

  \stexvarmacro{macro}
  \begin{sfunction}{stex_file_resolve:Nn}{\stex_file_resolve:Nn, \stex_file_resolve:No, \stex_file_resolve:Nx}
    \begin{syntax}\dcs\marg{\cs{macro}}\marg{string}
    \end{syntax}
    resolves and canonicalizes the file path string \meta{string} and
    stores the result in \cs{macro}. 
  \end{sfunction}

  \begin{sfunction}{stex_file_set:Nn}{\stex_file_set:Nn, \stex_file_set:No, \stex_file_set:Nx}
    \begin{syntax}\dcs\marg{\cs{macro}}\marg{string}
    \end{syntax}
    represents an already canonicalized file path string as a
    \LaTeX3 sequence and stores it in \cs{macro}.
  \end{sfunction}

  \begin{sfunction}{stex_if_file_absolute:N}[pTF]{\stex_if_file_absolute:N}
    \dcs tests whether the given file path (represented as a canonicalized
    \LaTeX3 sequence) is an absolute file path.
  \end{sfunction}

  \begin{sfunction}{stex_file_use:N}[EXP]{\stex_file_use:N}
    \dcs expands to a string representation of the given file path.
  \end{sfunction}

  \stexvarmacro{first}
  \stexvarmacro{second}
  \begin{sfunction}{stex_if_file_starts_with:NN}[TF]{\stex_if_file_starts_with:NN}
    \begin{syntax}\dcs\marg{\cs{first}}\marg{\cs{second}}
    \end{syntax}
    tests whether the file path \cs{first} is a child of \cs{second}.
    \emph{(Not expandable)}
  \end{sfunction}

  \stexvarmacro{source}
  \stexvarmacro{target}
  \begin{sfunction}{stex_file_split_off_ext:NN}{\stex_file_split_off_ext:NN}
    \begin{syntax}\dcs\marg{\cs{target}}\marg{\cs{source}}
    \end{syntax}
    splits off the file extension of \cs{source} and stores the resulting
    file path in \cs{target}
  \end{sfunction}

  \begin{sfunction}{stex_file_split_off_lang:NN}{\stex_file_split_off_lang:NN}
    \begin{syntax}\dcs\marg{\cs{target}}\marg{\cs{source}}
    \end{syntax}
    checks whether the file path \cs{source} ends with a language
    abbreviation (e.g. |.en|), if so removes it, and stores the result
    in \cs{target}.
  \end{sfunction}

  The following are primarily used in file hooks,
  but might occasionally be useful to call manually:

  \stexmacro{g_stex_current_file}
  \stexmacro{c_stex_main_file}

  \begin{sfunction}{stex_filestack_push:n}{\stex_filestack_push:n}
    pushes the given file to the file stack, recomputing
    \cs{g_stex_current_file}, the current language,
    document URI and namespace.
  \end{sfunction}

  \begin{sfunction}{stex_filestack_pop:}{\stex_filestack_pop:}
    pops the current top entry of the file stack. If the file stack
    is empty, resets to \cs{c_stex_main_file}.
  \end{sfunction}

  \begin{sfragment}{File Path Constants and Variables}

    \begin{svariable}{c_stex_pwd_file,c_stex_main_file}{\c_stex_pwd_file,\c_stex_main_file}
      store the parent working directory and
      the absolute path of the main file being processed
      (with guessed file extension |.tex|).
    \end{svariable}
  
    \begin{svariable}{c_stex_home_file}{\c_stex_home_file}
      stores the user's home directory.
    \end{svariable}
  
    \begin{svariable}{c_stex_mathhub_file}{\c_stex_mathhub_file}
      stores the user's MathHub directory;
      its string representation is stored in \cs{mathhub}.
    \end{svariable}
  
    \begin{svariable}{g_stex_current_file}{\g_stex_current_file}
      always points to the \emph{current} file.
    \end{svariable}

  \end{sfragment}

  \end{sfragment}

  \begin{sfragment}{URIs}

    \stexmacro{__stex_path_auth:n}
    \stexmacro{__stex_path_path:n}
    \stexmacro{__stex_path_module:n}
    \stexmacro{__stex_path_name:n}
    \stexmacro{stex_uri_resolve:Nn}
    \begin{sparagraph}[style=symdoc,for={__stex_path_auth:n,%
      __stex_path_path:n,__stex_path_module:n,__stex_path_name:n}]
      \mmt URIs are represented
      as token lists of the form

      |{|\cs{__stex_path_auth:n}\marg{authority}
      \cs{__stex_path_path:n}\marg{path}
      \cs{__stex_path_module:n}\marg{modulename}
      \cs{__stex_path_name:n}\marg{declname}|}|,

      all of which may be empty. Largely, URIs are used as strings only,
      but the above representation is used in \cs{stex_uri_resolve:Nn}
      to canonicalize URIs when they are computed the first time.

    \end{sparagraph}

    \stexvarmacro{uri}
    \begin{sfunction}{stex_map_uri:Nnnnn}{\stex_map_uri:Nnnnn}
      \begin{syntax}
        \dcs\marg{\cs{uri}}\marg{authority code}
        \marg{path code}\marg{modulename code}\marg{declname code}
      \end{syntax}
      executes the provided \meta{code}s with the components
      of the \cs{uri} as arguments.
    \end{sfunction}

    \begin{sfunction}{stex_uri_resolve:Nn}{\stex_uri_resolve:Nn, \stex_uri_resolve:No, \stex_uri_resolve:Nx}
      behaves analogously to \cs{stex_file_resolve:Nn}.
    \end{sfunction}

    \begin{sfunction}{stex_uri_set:Nn}{\stex_uri_set:Nn, \stex_uri_set:No, \stex_uri_set:Nx}
      behaves analogously to \cs{stex_file_set:Nn}.
    \end{sfunction}

    \begin{sfunction}{stex_uri_use:N}[EXP]{\stex_uri_use:N}
      behaves analogously to \cs{stex_file_use:N}.
    \end{sfunction}

    A common usage of URIs is computing the namespace of content
    elements (modules or documents) from the namespace of a math
    archive and some relative file path within that archive.

    \stexvarmacro{target}
    \stexvarmacro{repo_prop}
    \stexvarmacro{filepath}
    \begin{sfunction}{stex_uri_from_repo_file:NNNn}{\stex_uri_from_repo_file:NNNn}
      \begin{syntax}
        \dcs\marg{\cs{target}}\marg{\cs{repo_prop}}\marg{\cs{filepath}}
        \marg{ns\_field}
      \end{syntax}
      computes the namespace URI from the property list
      \cs{repo_prop} of some math archive, the file path
      \cs{filepath} and the archive field \marg{ns\_field}
      (|narr| or |ns|), and stores the result in \cs{target}.
    \end{sfunction}

    \begin{sfunction}{stex_uri_from_repo_file_nolang:NNNn}{\stex_uri_from_repo_file_nolang:NNNn}
      behaves like \cs{stex_uri_from_repo_file:NNNn}, but makes 
      sure
      to split off language abbreviations from the file name
      (e.g. |.en|).
    \end{sfunction}

    \begin{sfunction}{stex_uri_from_current_file:Nn, stex_uri_from_current_file_nolang:Nn}{\stex_uri_from_current_file:Nn, \stex_uri_from_current_file_nolang:Nn}
      Special cases for \cs{stex_uri_from_repo_file}|[_nolang]:NNNn|,
      for \cs{repo_prop}|=|\cs{l_stex_current_archive_prop} and
      \cs{filepath}|=|\cs{g_stex_current_file}.
    \end{sfunction}

    \stexmacro{l_stex_current_doc_uri}
    \begin{sfunction}{stex_set_document_uri:}{\stex_set_document_uri:}
      sets the current value of \cs{l_stex_current_doc_uri} based
      on the current file and archive.
    \end{sfunction}

    \stexmacro{l_stex_current_ns_uri}
    \begin{sfunction}{stex_set_current_namespace:}{\stex_set_current_namespace:}
      sets the current value of \cs{l_stex_current_ns_uri} based
      on the current file and archive.
    \end{sfunction}

    \begin{sfunction}{stex_uri_add_module:NNn}{\stex_uri_add_module:NNn, \stex_uri_add_module:NNo}
      \begin{syntax}
        \dcs\marg{\cs{target}}\marg{\cs{uri}}
          \marg{name}
      \end{syntax}
      Checks that URI \cs{uri} has no module name, adds the provided
      \meta{name} and stores the result in \cs{target}.
    \end{sfunction}

  \begin{sfragment}{URI Constants and Variables}

    \begin{svariable}{l_stex_current_doc_uri}{\l_stex_current_doc_uri}
      always points to the current document URI.
    \end{svariable}

    \begin{svariable}{l_stex_current_ns_uri}{\l_stex_current_ns_uri}
      always points to the current content namespace.
    \end{svariable}

  \end{sfragment}
    
  \end{sfragment}

\end{sfragment}

\begin{sfragment}{Language Handling}
  \begin{svariable}{c_stex_languages_prop,c_stex_language_abbrevs_prop}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
    Property lists converting babel languages to/from their abreviations;
    e.g.
    \begin{itemize}
      \item |\prop_item:Nn |\cs{c_stex_languages_prop}| {de}| yields |ngerman|, and 
      \item \cs{c_stex_language_abbrevs_prop}| {ngerman}| yields |de|.
    \end{itemize}  
  \end{svariable}

  \begin{svariable}{l_stex_current_language_str}{\l_stex_current_language_str}
    always stores the current language.
  \end{svariable}

  \begin{sfunction}{stex_set_language:n}{\stex_set_language:n, \stex_set_language:x, \stex_set_language:o}
    \begin{syntax}\dcs\marg{abbrev}\end{syntax}
    Sets \cs{l_stex_current_language_str}, and, if the \pkg{babel}
    package is loaded, calls \cs{selectlangage} on the
    language corresponding to \marg{abbrev}.

    Note that the package option |lang=| automatically loads the
    \pkg{babel} package.

    If \meta{abbrev}|=tr|, additionally call \cs{selectlanguage}
    with the option |shorthands=:!|.

    Throws |error/unknownlanguage| if no language with abbreviation
    \marg{abbrev} is known.
  \end{sfunction}

  \begin{sfunction}{stex_language_from_file:}{\stex_language_from_file:}
    infers the current language from file ending (e.g. |.en.tex|)
    and sets it appropriately.

    Is called in a file hook, i.e. always switches language when inputting
    a file |.<lang>.<ext>|.
  \end{sfunction}

\end{sfragment}

\begin{sfragment}{Inserting Annotations}
  \stex can be used to produce either \HTML or \PDF. In \HTML-mode,
  multiple macros exist to insert annotations. The same macros
  are also valid in \PDF mode but implemented as null operations.

  \begin{sfunction}{stex_suppress_html:n}{\stex_suppress_html:n}
    \begin{syntax}\dcs\marg{code}\end{syntax}
    turns annotations off temporarily in \meta{code} (e.g. as to not 
    generate additional annotations for elaborated declarations, 
    or in sms-mode).
  \end{sfunction}

  For that to work, code that inserts annotations should use
  \begin{sfunction}{stex_if_do_html:}[pTF]{\stex_if_do_html:}
    tests whether to generate \HTML annotations.
  \end{sfunction}

  \begin{sfunction}{stex@backend}{\stex@backend}
    should be set by a backend engine, such that a file
    |stex-backend-|\dcs{}|.cfg| exists.
  \end{sfunction}

  \begin{sfragment}{Backend macros}

  Such a backend config file should provide the following:

  \begin{sfunction}{stex_if_html_backend:}[pTF]{\stex_if_html_backend:}
    can be used to determine whether the backend produces \HTML (e.g.
    \rustex or \LaTeXML) or not (e.g. |pdflatex|).
    
    \cs{ifstexhtml} is set accordingly.
  \end{sfunction}

  \begin{sfunction}{stex_annotate:nnn}{\stex_annotate:nnn}
    \begin{syntax} \dcs\marg{attr}\marg{value}\marg{code}
    \end{syntax}
    In \HTML mode, annotates the output of \meta{code} with the 
    \XML-attribute \meta{attr}|="|\meta{value}|"|. In \PDF mode, just
    calls \meta{code}.
  \end{sfunction}

  \begin{sfunction}{stex_annotate_invisible:nnn,stex_annotate_invisible:n}{\stex_annotate_invisible:nnn,\stex_annotate_invisible:n}
    \begin{syntax} \dcs[stex_annotate_invisible:n]\marg{code}
    \end{syntax}

    Should annotate \meta{code} with
    |shtml:visible="false" style="display:none;"|. In \PDF mode, does 
    nothing.

    \dcs combines \cs{stex_annotate_invisible:n}
    and \cs{stex_annotate:nnn}.
  \end{sfunction}


  \begin{senv}{stex_annotate_env}
    \cs{begin}|{|\denv|}|\marg{attr}\marg{value}
    \meta{code}
    \cs{end}|{|\denv|}| should behave
    like \cs{stex_annotate:nnn}\marg{attr}\marg{value}\marg{code}
  \end{senv}

  \begin{sfunction}{stex_mathml_intent:nn,stex_mathml_arg:nn}{\stex_mathml_intent:nn,\stex_mathml_arg:nn}
    MathML Intent (TODO)
  \end{sfunction}

  \end{sfragment}

\end{sfragment}

\begin{sfragment}{Persisting Content from Math Archives in sms-Files}

  \begin{sfunction}{stex_persist:n}{\stex_persist:n,\stex_persist:o,\stex_persist:x}
    \begin{syntax}\dcs\marg{code}\end{syntax}
    writes \meta{code} to the \cs{jobname}|.sms|-file iff
    the package option |writesms| or the environment variable
    |STEX_WRITESMS| is set (the latter overrides the former).
  \end{sfunction}

\end{sfragment}


\begin{sfragment}{Utility Methods}

  \stexvarmacro{foo}
  \begin{sfunction}{stex_macro_body:N}[EXP]{\stex_macro_body:N}
    expands to the \emph{expansion} of the provided macro,
    including parameter tokens, with the original category codes intact; 
    e.g. if \cs{def}\cs{foo}|#1{First #1}|,
    then \dcs\cs{foo} expands to
    |First #1|.
  \end{sfunction}

  \begin{sfunction}{stex_macro_definition:N}[EXP]{\stex_macro_definition:N}
    expands to the token list \emph{defining} the provided macro,
    including parameters, command attributes (i.e. \cs{long}, 
    \cs{protected}), with the original category codes intact; 
    e.g. if \cs{protected}\cs{def}\cs{foo}|#1{First #1}|,
    then \dcs\cs{foo} expands to
    \cs{protected}\cs{def}\cs{foo}|#1{First #1}|.

    \begin{texnote} Does not work with ``higher'' parameter
    tokens, i.e. |##1|, |####1| etc.\end{texnote}
  \end{sfunction}

  \stexvarmacro{macro}
  \begin{sfunction}{stex_deactivate_macro:Nn, stex_reactivate_macro:N}{\stex_deactivate_macro:Nn, \stex_reactivate_macro:N}
    \begin{syntax}\dcs \marg{\cs{macro}} \marg{msg}
    \end{syntax}
    Makes \cs{macro} throw an error message |error/deactivated-macro|\marg{msg},
    notifying an author that the macro is only allowed in certain environments.

    \dcs[stex_reactivate_macro:N] restores the functionality of the macro.
  \end{sfunction}

  \begin{sfunction}{stex_kpsewhich:Nn}{\stex_kpsewhich:Nn}
    \begin{syntax}
      \dcs \marg{\cs{macro}} \marg{args}
    \end{syntax}
    Calls ``|kpsewhich| \meta{args}'' and stores the result
    in \cs{macro},
%^^A     Foo
    \begin{texnote} 
      Does not require |shell-escape|
    \end{texnote}
%^^A
%^^A
%^^A     \begin{arguments}
%^^A       \item Narf?
%^^A     \end{arguments}
%^^A
  \end{sfunction}

  \begin{sfunction}{stex_get_env:Nn}{\stex_get_env:Nn}
    \begin{syntax}
      \dcs \marg{\cs{macro}} \marg{envvar}
    \end{syntax}
    Stores the value of the environment variable \meta{envvar}
    in \cs{macro}.
  \end{sfunction}

  \begin{sfunction}{stex_fatal_error:n}{\stex_fatal_error:n,\stex_fatal_error:nnn,\stex_fatal_error:nxx}
    Mimic the \cs{msg_error:}-macros, but make sure that \TeX\ stops
    processing.
    \begin{texnote} 
      Calls |\input{non-existent file}|.
    \end{texnote}
  \end{sfunction}

  \begin{sfunction}{stex_ignore_spaces_and_pars:}{\stex_ignore_spaces_and_pars:}
    As the name suggests, ignores all subsequent spaces and \cs{par}s
    until the first non-expandable macro is encountered.

    Useful for e.g. ending \cs{symdecl} and related macros with,
    so that formatting sources with empty lines does not cause 
    paragraph breaks.
  \end{sfunction}

  \begin{sfragment}{Group-like Behaviours}

    \begin{sfunction}{stex_pseudogroup_with:nn}{\stex_pseudogroup_with:nn}
      \begin{syntax}\dcs\marg{macros}\marg{code}
      \end{syntax}
      Calls \meta{code} and subsequently restores the values of the
      \meta{macros} given.
      \begin{texnote}
        Does \emph{not} work recursively!
      \end{texnote} 
    \end{sfunction}

    \stexmacro{stex_pseudogroup_restore:N}

    \begin{sfunction}{stex_pseudogroup:nn}{\stex_pseudogroup:nn}
      \begin{syntax}\dcs\marg{code1}\marg{code2}
      \end{syntax}
      Expands \meta{code2}, and inserts the result after \meta{code1}. 
      Works recursively and
      allows for restoring the values of macros in combination with
      \cs{stex_pseudogroup_restore:N}, but \emph{only for macros
      that take no arguments}:
    \end{sfunction}

    \begin{sfunction}{stex_pseudogroup_restore:N}[EXP]{\stex_pseudogroup_restore:N}
      \begin{syntax}\dcs\marg{\cs{macro}}
      \end{syntax}
    \end{sfunction}

    \begin{sexample}
      \stexvarmacro{foo}
      \stexvarmacro{num}
      \begin{stexcode}[gobble=8]
        |\cs{stex_pseudogroup:nn}|{
          something changing |\cs{foo}|
          something changing |\cs{num}|
        }{
          |\cs{stex_pseudogroup_restore:N}\cs{foo}|
          \int_set:Nn |\cs{num}| {\int_use:N |\cs{num}|}
        }
      \end{stexcode}
      restores the values of macro \cs{foo} and register \cs{num}
      after calling the first block.
    \end{sexample}

    Commands like \cs{symdecl} and \cs{importmodule} that generate
    (semantic) macros should be local \emph{to the current module},
    e.g. \env{smodule}. For that purpose, we open a new ``metagroup''
    with some identifier (e.g. \cs{l_stex_current_module_str})
    and then execute the relevant code \emph{in the metagroup with that
    identifier}:
    
    \begin{sfunction}{stex_metagroup_new:n}{\stex_metagroup_new:n, \stex_metagroup_new:o}
      \begin{syntax}\dcs \marg{id}\end{syntax}
      Opens a new metagroup at the current \TeX\ group level with
      identifier \meta{id}.
    \end{sfunction}

    \begin{sfunction}{stex_metagroup_do_in:nn}{\stex_metagroup_do_in:nn, \stex_metagroup_do_in:nx}
      \begin{syntax}\dcs \marg{id}\marg{code}\end{syntax}
      Executes \meta{code} and adds its content to \cs{aftergroup} up
      until the \TeX\ group level of the metagroup with identifier 
      \meta{id}.
    \end{sfunction}

  \end{sfragment}

\end{sfragment}

\end{smodule}

%^^A^^A   \begin{TemplateInterfaceDescription}{foo}
%^^A^^A     \TemplateArgument{1}{Something Here}
%^^A^^A     \TemplateSemantics{Some Narf Here}
%^^A^^A   \end{TemplateInterfaceDescription}
%^^A^^A   \begin{TemplateDescription}{foo}{bar}
%^^A^^A     \TemplateKey{narf}{Something Here}
%^^A^^A     \TemplateSemantics{Some Narf Here}
%^^A^^A   \end{TemplateDescription}
%^^A^^A   \begin{InstanceDescription}{foo}{newinst}{bar}
%^^A^^A     \InstanceKey{narf}{Something Here}
%^^A^^A     \InstanceSemantics{Some Narf Here}
%^^A^^A   \end{InstanceDescription}
%^^A^^A   \cs{stex_kpsewhich:Nn}
%^^A   \begin{function}{\stex_kpsewhich:Nn}
%^^A     Foo
%^^A     \begin{texnote} Foo! \end{texnote}
%^^A
%^^A     \begin{syntax} \cs{stex_kpsewhich:Nn} \meta{something} \Arg{argh}
%^^A     \end{syntax}
%^^A
%^^A     \begin{arguments}
%^^A       \item Narf?
%^^A     \end{arguments}
%^^A
%^^A   \end{function}