\documentclass{stex}
\libinput{docpreamble}
\begin{document}
  \begin{smodule}[title=Argument Modes]{ArgumentMode}
    \usemodule{concepts?Symbol}
    \usemodule{concepts?Notation}
    \usemodule{concepts?SemanticMacro}
    \importmodule{macros?comp}

    \symdecl{sequence argument}
    \symdecl{simple argument}
    \symdecl{binding argument}
    \symdecl{binding sequence argument}

    \begin{sparagraph}[style={defibox,symdoc},name=argument mode]
      The optional |args|-argument of \cs{symdecl} expects
      a string of characters indicating the \sn{semantic macro}'s
      \definame[post=s]{argument mode}. There are four such 
      \sr{argument mode}{modes}:
      \begin{itemize}
        \item[|i|] a \definame{simple argument},
        \item[|a|] a (\emph{(left or right) associative}) 
          \definame{sequence argument}, represented as a single
          \TeX-argument |{a,b,...}|,
        \item[|b|] A \definame{binding argument} that expects a variable
          that is bound by the \sn{symbol} in its application, and
        \item[|B|] A \definame{binding sequence argument} of arbitrarily
          many bound variables by the \sn{symbol} (|{x,y,z,...}|).
      \end{itemize}

      If |args| is given as a number $n$ instead, the \sn{semantic macro}
      takes $n$ arguments of \sr{argument mode}{mode} |i|.
    \end{sparagraph}

    \begin{sexample}[for={argument mode, simple argument,sequence argument,
      binding sequence argument}]
      \begin{itemize}
        \item For |\plus{a,b,c}| yielding $a + b + c$, we do
          \cs{symdecl}|{plus}[args=a]|,
        \item for |\inset{a,b,c}{A}| yielding $a,b,c\in A$, we do
          \cs{symdecl}|{inset}[args=ai]|,
        \item in |\add{i}{1}{n}{f(i)}| yielding $\sum_{i=1}^nf(i)$,
          the variable $i$ is \sr{binding argument}{bound} in the expression,
          we hence do \cs{symdecl}|{add}[args=biii]|,
        \item in |\foral{x,y,z}{P(x,y,z)}| yielding $\forall x,y,z.\;P(x,y,z)$, 
        the variables $x,y,z$ are all \sr{binding argument}{bound} by the
        $\forall$, we hence do \cs{symdecl}|{foral}[args=Bii]|.
      \end{itemize}
    \end{sexample}

    \begin{sparagraph}[style=defibox]
      The \cs{notation} and \cs{symdef} commands take one additional
      argument for each \sn{sequence argument} or \sn{binding sequence argument}
      that specifies how to aggregate a sequence of comma-separated arguments
      into a single argument, using |##1| and |##2| to represent subsequent
      arguments.
    \end{sparagraph}

    \begin{sexample}
      \begin{itemize}
        \item \vardef{plus}[args=a]{#1}{##1 \mathbin{\comp{+}} ##2}
          Assume we want |$\plus{a,b,c}$| to yield $\plus{a,b,c}$.
          Then we declare ``plus'' as \cs{symdecl}|{plus}[args=a]| and provide
          the notation as\\ 
          \cs{notation}|{plus}{#1}{##1 \mathbin{\comp{+}} ##2}|.\\
          Meaning: {\itshape fold the function |{##1 \mathbin{\comp{+}} ##2}|
          to every pair of arguments. Insert the result as
          |#1| into the main notation |{#1}|.}
        \item \vardef{vsum}[args=Biii]{\mathop{\comp{\sum}}_{#1=#2}^{#3}#4}{##1\mathpunct{\comp{,}}##2} 
        Assume we want |$\vsum{i,j,k}{0}{n}{f(i,j,k)}$|
          to yield $\vsum{i,j,k}{0}{n}{f(i,j,k)}$. The we declare
          ``vsum'' as \cs{symdecl}|{vsum}[args=Biii]|
          and the notation as\\
          \cs{notation}|{vsum}{\mathop{\comp{\sum}}_{#1=#2}^{#3}#4}|\\
          |  {##1\mathpunct{\comp{,}}##2}|\\
          Meaning: {\itshape fold the function |{##1 \mathpunct{\comp{,}} ##2}|
          to every pair of elements of the first argument. Insert the result as
          |#1| into the main notation |{\mathop{\comp{\sum}}_{#1=#2}^{#3}#4}|.}
      \end{itemize}
    \end{sexample}
    
  \end{smodule}
\end{document}