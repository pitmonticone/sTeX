\documentclass[lang={en,de}]{stex}
\libinput{docpreamble}
\setsectionlevel{section}
\begin{document}

    \begin{sfragment}{Semantic Macros and Notation}

    \usemodule{concepts?Notation}
    \usemodule{concepts?SemanticMacro}
    \usemodule{macros?symrefs}

    Obviously, ``monoid'' is not the only \sn{symbol} introduced in this
    fragment: There are also $M$, $\circ$ and $e$.
    There are two differences between ``monoid'' and the other \sns{symbol},
    though:
    \begin{enumerate}
        \item ``monoid'' is a well-defined concept on its own,
        whereas $M$, $\circ$ and $e$ are not -- rather, they are 
        ``components'' of \emph{a} monoid, and their precise definition
        and behaviour depends on the specific monoid under consideration.

        We will ignore this aspect for now and return to it 
        \textcolor{red}{TODO: link} later.
        \item $M$, $\circ$ and $e$ have symbolic \sns{notation}
        which are used to refer to the \sns{symbol}, rather than their
        (natural language) names. Indeed, the definition above does
        not even mention their names.
    \end{enumerate}

    For that purpose, we can use \sns{semantic macro} for the remaining
    three \sns{symbol}:

    \inputref{concepts/SemanticMacro.en}

    \stexvarmacro{universe}
    \stexvarmacro{unit}
    \stexvarmacro{op}
    \stexvarmacro{operation}

    We can now declare $M$ \emph{and} generate a \sn{semantic macro} 
    for it by choosing an
    appropriate name (e.g. ``universe'') and doing
    \cs{symdecl}|{universe}|, giving us the semantic macro
    \cs{universe}. Similarly, we can do
    \cs{symdecl}|{unit}| for $e$, giving us \cs{unit}. 
    
    In the case of $\circ$,
    we want to additionally specify that $\circ$ represents
    a \emph{function} taking two arguments by doing
    \cs{symdecl}|{operation}[args=2]|, which gives us
    \cs{operation}.

    
    \usemodule{ex/monoid_3_symdef?Monoid}

    The latter is a lot to write, so we might want the
    \sn{semantic macro} to be shorter, e.g. \cs{op}.
    We can do so by saying \cs{symdecl}|{op}[name=operation]|,
    in which case \cs{symname}|{op}| or \cs{symname}|{operation}|
    still yield ``\symname{op}'' rather than ``\symref{op}{op}''.

    Next, we supply our \sns{symbol} with \sns{notation}:

    \inputref{concepts/Notation.en}
    \usemodule{macros?notation}

    So for \sn{universe} and \sn{unit}, we can now do
    \cs{notation}|{universe}{M}| and
    \cs{notation}|{unit}{e}|. In which case 
    |$\universe$| will yield $\universe$ and |$\unit$| will yield
    $\unit$.

    For \sn{op}, the \sn{notation}
    takes two arguments, as does its \sn{semantic macro}, so we can do
    \cs{notation}|{op}{#1 \circ #2}|, so that |$\op{a}{b}$|
    will yield $\op ab$. We can additionally supply the
    \sn{operator notation} |\circ| by doing\\
    \cs{notation}|{op}[op=\circ]{#1 \circ #2}|, which allows us
    to write |$\op!$| to produce $\op!$.

    In the vast majority of cases, if we declare a new \sn{symbol}
    that has a \sn{notation}, we want to supply it immediately.
    The \cs{symdef}-macro therefore combines the functionalities
    of \cs{symdecl} and \cs{notation}. Putting all of this
    together, we can now do:

    \stexexamplefile{ex/monoid_3_symdef.en.tex}[gobble=2,firstline=5,lastline=20,classoffset=1,morekeywords={
    \\mathstruct,\\monoid,\\universe,\\op,\\unit
    }]

    \usemodule{concepts?Comp}

    Two things deserve commenting on here:
    \begin{enumerate}
        \item The symbol \sr{mathstruct}{mathstruct}
            with semantic macro \cs{mathstruct} comes directly
            with \sTeX. Its actual name is ``\sn{mathstruct}''.
        \item We are using the macros \cs{comp} and \cs{mathbin}
            in the notation for \sn{op}. That is because we lied earlier:
            if we were to leave both of them out, then
            \cs{op}|{a}{b}| would leave the suspiciously not-highlighted
            expression ``$a\circ b$'' instead.
    \end{enumerate}

    \inputref{concepts/Comp.en}

    Regarding \cs{mathbin}, if we were to leave that out, we would
    get ``$a \compemph{\circ} b$'', where the spacing is off --
    our usage of \cs{mathbin} fixes that.

    \begin{dangerbox} \TeX\ determines spacing/kerning in math mode 
        by assigning a \emph{class} to every character. Both individual
        characters and whole subexpressions can be assigned one
        of these classes using dedicated macros. These are:
        \begin{center}\begin{tabular}{lll}
            \textbf{class} & \textbf{\TeX-macro} & \textbf{examples} \\\hline
            ordinary (default class) & \cs{mathord} & $\alpha$ $i$ $\Diamond$ \\
            large operator & \cs{mathop} & $\sum$ $\prod$ $\int$ \\
            opening & \cs{mathopen} & $($ $[$ $\langle$ \\
            closing & \cs{mathclose} & $)$ $]$ $\rangle$ \\
            binary relation & \cs{mathrel} & $\leq$ $>$ $=$ \\
            binary operator & \cs{mathbin} & $+$ $\cdot$ $\circ$ \\
            punctuation & \cs{mathpunct} & $,$ $;$
        \end{tabular}\end{center}

        \TeX\ ``forgets'' the class of an expression if it
        is wrapped in a \cs{comp}-macro. It is therefore a good idea
        to wrap any occurence of a \cs{comp} in the corresponding
        \TeX-macro for the desired class (e.g. |\mathrel{|\cs{comp}|{\leq}}|).
    \end{dangerbox}

    \end{sfragment}
\end{document}