\documentclass[lang={en,de}]{stex}
\libinput{docpreamble}
\setsectionlevel{section}
\begin{document}
  \begin{sfragment}{Sequence Arguments and Argument Modes}

    \usemodule{ex/monoid_5_vardef?Monoid}
    \usemodule{concepts?SemanticMacro}
    \usemodule[sTeX/MathBase/Relations]{mod?Equal}
    \usemodule[sTeX/MathBase/Functions]{mod?Function}

    We have specified \sn{op} to be a binary function, with a
    \sn{semantic macro} taking two arguments -- but with \cs{eq}
    (i.e. \sr{eq}{equality})
    and \cs{fun} (a \sr{fun}{function specification})
    we have already seen \sns{semantic macro} that take
    comma-separated lists in a single braced argument. The advantage
    of that is that the \sns{semantic macro} can also take arbitrarily
    many arguments -- e.g. |$\eq{a,b,c,d,e}$| yields $\eq{a,b,c,d,e}$,
    and |$\fun{f,g,h}{A,B,C,D,E}{Z}$| yields $\fun{f,g,h}{A,B,C,D,E}{Z}$.

    \usemodule{concepts?ArgumentMode}

    If we want the same to work for \cs{op}, we have to tell \cs{symdecl}
    the \sn{argument mode} of its arguments, rather than just declaring 
    the \emph{arity}
    of the \sn{symbol}.

    \inputref{concepts/ArgumentMode.en}

    So if we want to have the 
    \sr{semantic macro}{macro} \cs{op} to accept e.g. |$\op{a,b,c,d}$|
    and yield $\op a{\op b{\op cd}}$, we have to give it a single 
    \sn{sequence argument}
    of \sr{argument mode}{mode} |a|.

    \stexexamplefile{ex/monoid_6_assoc.en.tex}[gobble=2,firstline=5,lastline=23,classoffset=1,morekeywords={
    \\mathstruct,\\monoid,\\universe,\\op,\\unit,\\fun,\\eq,\\inset
    },classoffset=9,morekeywords={
      \\vx
    }]
  
  \end{sfragment}
\end{document}