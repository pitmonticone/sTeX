\makeatletter
\ifcsname if@infulldoc\endcsname\else
    \expandafter\newif\csname if@infulldoc\endcsname\@infulldocfalse
\fi
\makeatother

\csname if@infulldoc\endcsname\else

\def\bibfolder{../lib/bib}

\input{stex-docheader}

\infulldoctrue

\begin{document}
  \csname if@infulldoc\endcsname\else
	\title{
		The {\stex{3}} Manual
		\thanks{Version {\fileversion} (last revised {\filedate})}
 	}
	\author{Michael Kohlhase, Dennis Müller\\
		FAU Erlangen-Nürnberg\\
		\url{http://kwarc.info/}
	}
	\pagenumbering{roman}
	\maketitle
	
	\input{stex-abstract}\bigskip

  This is the user manual for the \sTeX package and 
  associated software. It is primarily directed at end-users 
  who want to use \sTeX to author semantically
  enriched documents. For the full documentation, see
  \href{\basedocurl/stex.pdf}{the \sTeX documentation}
	
	\makeatletter
		\renewcommand\part{%
    		\clearpage
  			\thispagestyle{plain}%
  			\@tempswafalse
  			\null\vfil
  			\secdef\@part\@spart%
  		}
		\newcounter{chapter}
		\numberwithin{section}{chapter}
		\renewcommand\thechapter{\@arabic\c@chapter}
		\renewcommand\thesection{\thechapter.\@arabic\c@section}
		\newcommand*\chaptermark[1]{}
		\setcounter{secnumdepth}{2}
		\newcommand\@chapapp{\chaptername}
		%\newcommand\chaptername{Chapter}
  		\def\ps@headings{%
    		\let\@oddfoot\@empty
    		\def\@oddhead{{\slshape\rightmark}\hfil\thepage}%
    		\let\@mkboth\markboth
    		\def\chaptermark##1{%
      			\markright{\MakeUppercase{%
        			\ifnum \c@secnumdepth >\m@ne
            			\@chapapp\ \thechapter. \ %
        			\fi
        		##1}}%
        	}%
        }
		\newcommand\chapter{\clearpage
			\thispagestyle{plain}%
			\global\@topnum\z@
			\@afterindentfalse
			\secdef\@chapter\@schapter%
		}
		\def\@chapter[#1]#2{\refstepcounter{chapter}%
			\typeout{\@chapapp\space\thechapter.}%
			\addcontentsline{toc}{chapter}%
				{\protect\numberline{\thechapter}#1}%
			\chaptermark{#1}%
			\addtocontents{lof}{\protect\addvspace{10\p@}}%
			\addtocontents{lot}{\protect\addvspace{10\p@}}%
			\@makechapterhead{#2}%
			\@afterheading%
		}
		\def\@makechapterhead#1{%
			\vspace*{50\p@}%
			{\parindent \z@ \raggedright \normalfont
				\huge\bfseries \@chapapp\space \thechapter
				\par\nobreak
				\vskip 20\p@
				\interlinepenalty\@M
				\Huge \bfseries #1\par\nobreak
				\vskip 40\p@
			}%
		}
\newcommand*\l@chapter[2]{%
  \ifnum \c@tocdepth >\m@ne
    \addpenalty{-\@highpenalty}%
    \vskip 1.0em \@plus\p@
    \setlength\@tempdima{1.5em}%
    \begingroup
      \parindent \z@ \rightskip \@pnumwidth
      \parfillskip -\@pnumwidth
      \leavevmode \bfseries
      \advance\leftskip\@tempdima
      \hskip -\leftskip
      #1\nobreak\hfil
      \nobreak\hb@xt@\@pnumwidth{\hss #2%
                                 \kern-\p@\kern\p@}\par
      \penalty\@highpenalty
    \endgroup
  \fi}
\renewcommand*\l@section{\@dottedtocline{1}{1.5em}{2.8em}}
\renewcommand*\l@subsection{\@dottedtocline{2}{3.8em}{3.2em}}
\renewcommand*\l@subsubsection{\@dottedtocline{3}{7.0em}{4.1em}}
\def\partname{Part}
\def\toclevel@part{-1}
\def\maketitle{\chapter{\@title}}
\let\thanks\@gobble
\let\DelayPrintIndex\PrintIndex
\let\PrintIndex\@empty
\providecommand*{\hexnum}[1]{\text{\texttt{\char`\"}#1}}
\makeatother

\ExplSyntaxOn
\int_set:Nn \l_document_structure_section_level_int {1}
\ExplSyntaxOff

\clearpage

{%
  \def\\{:}% fix "newlines" in the ToC
  \tableofcontents
}

\clearpage
\pagenumbering{arabic}
	
\fi

\long\def\ignore#1{}


\begin{dangerbox}
  Boxes like this one contain implementation details that are
  mostly relevant for more advanced use cases, might be useful 
  to know when debugging, or might be good to know to better understand
  how something works. They can easiyl be skipped on a first read.
\end{dangerbox}

\begin{mmtbox}
  Boxes like this one explain how some \sTeX concept
  relates to the \mmt/\omdoc system, philosophy or language.
\end{mmtbox}


\begin{sfragment}{What is \sTeX?}
  
Formal systems for mathematics (such as interactive theorem provers)
have the potential to significantly increase both the accessibility
of published knowledge, as well as the confidence in its veracity,
by rendering the precise semantics of statements machine actionable.
This allows for a plurality of added-value services, from semantic
search up to verification and automated theorem proving.
Unfortunately, their usefulness is hidden behind severe barriers
to accessibility; primarily related to their surface languages
reminiscent of programming languages and very unlike informal
standards of presentation.

\sTeX minimizes this gap between informal and formal 
mathematics by integrating formal methods into established
and widespread authoring workflows, primarily \LaTeX, via 
non-intrusive semantic
annotations of arbitrary informal document fragments. That way
formal knowledge management services become available for informal
documents, accessible via an IDE for authors and via generated
\emph{active} documents for readers, while remaining fully compatible
with existing authoring workflows and publishing systems.

Additionally, an extensible library of reusable
document fragments is being developed, that serve as reference targets
for global disambiguation, intermediaries for content exchange
between systems and other services.

Every component of the system is designed modularly and extensibly,
and thus lay the groundwork for a potential full integration of
interactive theorem proving systems into established informal document
authoring workflows.

\paragraph{} The general \sTeX workflow combines functionalities
provided by several pieces of software:
\begin{itemize}
  \item The \sTeX package to use semantic annotations in
    {\LaTeX} documents,
  \item \RusTeX to convert |tex| sources to (semantically enriched)
    |xhtml|,
  \item The \mmt software, that extracts semantic information
    from the thus generated |xhtml| and provides semantically informed
    added value services.
\end{itemize}


% ----------------------------

\ignore{The objectives of this project will be achieved by developing a 
language and system 
that uses non-intrusive annotations
to augment informal documents with semantic information
(ranging from \textbf{fully formal} to \textbf{purely informal})
 without
impacting linguistic presentation or document layout. 
That way, the system
remains compatible with established publishing
pipelines and practices, while additionally providing flexiformal 
information that
enables formal knowledge management services, and hence produces 
\emph{rich active documents}, satisfying \textbf{R3}, \textbf{R4} and 
\textbf{R5}.
In particular, it will avoid commitment to a fixed logical foundation.
Instead, it will be designed as a modular pipeline of consecutive
and compositional
annotations, semantics extraction and translation steps, extensible
via new structuring mechanisms (\textbf{R1}), library content 
(\textbf{R2}),
NLP techniques, foundations, translation methods and 
end-user services.

Naturally, the benefits of formal knowledge management services scale 
with the amount of mathematics involved. Consequently I will primarily 
focus on those 
STEM fields in which mathematical methods are most prominently
used (e.g. mathematics, physics, computer science). Since in those fields
\LaTeX~is the most commonly used scientific writing tool, I will also
primarily focus on \LaTeX~as a development and evaluation target, but 
the system will be designed such that all components apart from
the surface language will be integrable with other writing tools 
(e.g. WYSIWYG word processors).

\paragraph{} The basic architecture of the proposed system is sketched in
\autoref{fig:architecture}.
\begin{figure}\centering
  \resizebox{0.95\textwidth}{!}{\tikzinput[]{diagram}}
  {\small (Note, that the syntax used
    in the box on the top right is prototypical and subject to change during the project.
    Details and open questions regarding the syntax are discussed here:
    \url{https://github.com/KWARC/FoMID/issues/1})}
  \caption{Basic Architecture of the Proposed System}\label{fig:architecture}
\end{figure}
A user can write their content using standard \LaTeX\ in an IDE;
ideally using semantic annotations provided by \sTeX
%and the library developed in \OBJref{smglom}
(as in the upper right of 
\autoref{fig:architecture}), but not necessarily so.

The document is converted to xhtml with \omdoc annotations
using \LaTeX ML in the background,
thus becoming actionable by the \mmt system. Both the source document
as well as the generated xhtml/\omdoc are accessible to a natural language
processing pripeline that can supply additional inferred semantic 
information or suggest annotations to the user, in the latter case 
augmenting the source document directly. This pipeline can use both 
classical NLP techniques using the GLIF system, as well as machine 
learning models such as \cite{own:fifom}.

A semiformal fragment is converted 
into an appropriate syntax tree (possibly containing opaque
informal nodes), 
thus becoming amenable
to flexiformal knowledge management services. In a consecutive step
-- if sufficiently annotated --, these are
additionally translated
to a fully formal foundation, e.g. using the techniques from 
\cite{DMueller:phd:19,own:translations}, allowing
more powerful services and conversion to established formal
systems. All three representations
are thus available from within the \mmt system for various
knowledge management services, interfaces for which can be
implemented in the IDE.

Importantly, every non-trivial arrow in the figure is 
composable and extensible -- 
translations to a foundation can be provided
by supplying an appropriate formalization and alignment-based
translations (or entirely new methods),
services can be implemented generically using the \mmt API,
NLP techniques can be implemented both inside and alongside of
GLIF, and the concrete syntax within \sTeX can be extended
by convenience macros in \LaTeX\ (enabling new
structuring mechanisms as in \textbf{R1} via 
\mmt extensions, see
\cite{MueRabRot:rslffml20}) as well as via additions to
the library, which will be extensible both from within the IDE
as well as on MathHub,
remaining backwards compatible with existing content in a surface 
language. Additionally, sufficiently disambiguated
statements can be translated to the syntax of 
external systems (such as interactive theorem prover systems
or computer algebra systems),
which can thus be integrated as additional services into the system.
}

\end{sfragment}

\begin{sfragment}{Quickstart}

	\begin{sfragment}{Setup}
		\begin{sfragment}{The \sTeX IDE}
      TODO: VSCode Plugin
    \end{sfragment}
    \begin{sfragment}{Manual Setup}
      Foregoing on the \sTeX IDE, we will need several
      pieces of software; namely:
      \begin{itemize}
        \item \textbf{The \sTeX-Package} available 
          \href{https://github.com/slatex/sTeX/blob/latex3/doc/stex.pdf}{here}.

          \sTeX is also available on CTAN and in \TeX Live.

        \item To make sure that \sTeX too knows where to find its
          archives, we need to set a global system variable |MATHHUB|,
          that points to your local |MathHub|-directory 
          (see \sref{sec.stexarchives}).
          %If you are only interested in using semantic macros in (ultimately)
          %|pdf|s generated by |pdflatex|, this is all you need.

        \item \textbf{The \mmt System} available
          \href{https://github.com/uniformal/MMT/tree/sTeX}{here}%
          \ednote{For now, we require the \texttt{sTeX}-branch, requiring manually
          compiling the MMT sources}. We recommend following
          the setup routine documented 
          \href{https://uniformal.github.io//doc/setup/}{here}.

          Following the setup routine (Step 3) will entail designating
          a |MathHub|-directory on your local file system, where
          the \mmt system will look for \sTeX/\mmt content archives.

        \item \textbf{\sTeX Archives} If we only care about {\LaTeX} and generating |pdf|s, we do not
          technically need \mmt at all; however, we still need the |MATHHUB|
          system variable to be set. Furthermore, \mmt can make downloading
          content archives we might want to use significantly easier, since
          it makes sure that all dependencies of (often highly interrelated)
          \sTeX archives are cloned as well.

          Once set up, we can run |mmt| in a shell and download an archive along with
          all of its dependencies like this: |lmh install <name-of-repository>|,
          or a whole \emph{group} of archives; for example,
          |lmh install smglom| will download all smglom archives.
        \item \textbf{\RusTeX} The \mmt system will also set up \RusTeX for you,
          which is used to generate (semantically annotated)
          |xhtml| from tex sources. In lieu of using \mmt, you
          can also download and use \RusTeX directly
          \href{https://github.com/slatex/RusTeX}{here}.

      \end{itemize}
    \end{sfragment}
	\end{sfragment}

  \input{stex-tutorial}

\end{sfragment}

\begin{sfragment}{Creating \sTeX Content}

  \input{packages/stex-basics}

  \begin{sfragment}{How Knowledge is Organized in \sTeX}

    \sTeX content is organized on multiple levels:
    \begin{itemize}
      \item \sTeX \textbf{archives} (see \sref{sec.stexarchives})
        contain individual |.tex|-files.
      \item These may contain \sTeX \textbf{modules}, introduced via 
      \stexcode"\begin{smodule}{ModuleName}".\iffalse\end{smodule}\fi
      \item Modules contain \sTeX \textbf{symbol declarations}, introduced via
        \stexcode"\symdecl{symbolname}", \stexcode"\symdef{symbolname}" and some other
        constructions. Most symbols have a \emph{notation} that can
        be used via a \emph{semantic macro} \stexcode"\symbolname" generated
        by symbol declarations.
      \item \sTeX \textbf{expressions} finally are built up from
        usages of semantic macros.
    \end{itemize}

    \begin{mmtbox}
      \begin{itemize}
        \item \sTeX archives are simultaneously \mmt archives, and the same
          directory structure is consequently used.
        \item \sTeX modules correspond to \omdoc/\mmt \emph{theories}.
          \stexcode"\importmodule"s (and similar constructions) induce 
          \mmt |include|s and other \emph{theory morphisms},
          thus giving rise to a \emph{theory graph} in the \omdoc sense.
        \item Symbol declarations induce \omdoc/\mmt \emph{constants},
          with optional (formal) \emph{type} and \emph{definiens} components.
        \item Finally, \sTeX expressions are converted to \omdoc/\mmt terms,
          which use the syntax of \openmath.
      \end{itemize}
    \end{mmtbox}

	\end{sfragment}

  \begin{sfragment}[id=sec.stexarchives]{\sTeX Archives}
    \input{packages/stex-mathhub}
  \end{sfragment}

  \begin{sfragment}[id=sec.decls]{Module, Symbol and Notation Declarations}
    \input{packages/stex-modules}

    \input{packages/stex-symbols}
  \end{sfragment}

  \begin{sfragment}{Module Inheritance and Structures}

    \begin{sfragment}{Multilinguality and Translations}

      If we load the \sTeX document class or package with the option
      |lang=<lang>|, \sTeX will load the appropriate \pkg{babel}
      language for you -- e.g. |lang=de| will load the babel
      language |ngerman|. Additionally, it makes \sTeX aware
      of the current document being set in (in this example)
      \emph{german}. This matters for reasons other than mere
      \pkg{babel}-purposes, though:

      Every \emph{module} is assigned a language. If no \sTeX
      package option is set that allows for inferring a language,
      \sTeX will check whether the current file name ends in
      e.g. |.en.tex| (or |.de.tex| or |.fr.tex|, or...) and
      set the language accordingly. Alternatively, a language
      can be explicitly assigned via 
      \stexcode"\begin{smodule}[lang=<language>]{Foo}".
      \iffalse\end{smodule}\fi

      \begin{mmtbox}
        Technically, each |smodule|-environment induces \emph{two}
        \omdoc/\mmt theories:
        \stexcode"\begin{smodule}[lang=<lang>]{Foo}"
        \iffalse\end{smodule}\fi
        generates a theory |some/namespace?Foo| that only contains
        the ``formal'' part of the module -- i.e. exactly the
        content that is exported when using \stexcode"\importmodule".

        Additionally, \mmt generates a \emph{language theory} 
        |some/namespace/Foo?<lang>| that includes |some/namespace?Foo|
        and contains all the other document content -- variable
        declarations, includes for each \stexcode"\usemodule", etc.
      \end{mmtbox}

      Notably, the language suffix in a filename is ignored
      for \stexcode"\usemodule", \stexcode"\importmodule"
      and in generating/computing URIs for modules. This however
      allows for providing \emph{translations} for modules
      between languages without needing to duplicate content:

      If a module |Foo| exists in e.g. english in a file |Foo.en.tex|,
      we can provide a file |Foo.de.tex| right next to it, and write
      \stexcode"\begin{smodule}[sig=en]{Foo}".
      \iffalse\end{smodule}\fi
      The |sig|-key then signifies, that the ``signature'' of the
      module is contained in the \emph{english} version of the module,
      which is immediately imported from there, just like
      \stexcode"\importmodule" would.

      Additionally to translating the informal content of a module
      file to different languages, it also allows for customizing
      notations between languages. For example,
      the \emph{least common multiple} of two numbers is often
      denoted as $\mathtt{lcm}(a,b)$ in english, but is
      called \emph{kleinstes gemeinsames Vielfaches} in german
      and consequently denoted as $\mathtt{kgV}(a,b)$ there.

      We can therefore imagine a german version of an lcm-module
      looking something like this:

      \begin{latexcode}[gobble=8]
        \begin{smodule}[sig=en]{lcm}
          \notation*{lcm}[de]{\comp{\mathtt{kgV}}(#1,#2)}

          Das \symref{lcm}{kleinste gemeinsame Vielfache}
          $\lcm{a,b}$ von zwei Zahlen $a,b$ ist... 
        \end{smodule}
      \end{latexcode}

      If we now do \stexcode"\importmodule{lcm}"
      (or \stexcode"\usemodule{lcm}") within a \emph{german} document,
      it will also load the content of the german translation,
      including the |de|-notation for \stexcode"\lcm".

    \end{sfragment}

    \input{packages/stex-inheritance}
    \input{packages/stex-features}
  \end{sfragment}

  \begin{sfragment}{Primitive Symbols (The \sTeX Metatheory)}
    \input{packages/stex-metatheory}
  \end{sfragment}
  
\end{sfragment}

\begin{sfragment}[id=sec.textsymbols]{Using \sTeX Symbols}
  \input{packages/stex-terms}

  \input{packages/stex-references}
\end{sfragment}

\begin{sfragment}{\sTeX Statements (Definitions, Theorems, Examples, ...)}
  \input{packages/stex-statements}

  \input{packages/stex-proofs}
\end{sfragment}

\begin{sfragment}{Additional Packages}
  \input{packages/stex-tikzinput}
  \begin{sfragment}{Modular Document Structuring}
    \input{packages/stex-document-structure}
  \end{sfragment}
  \begin{sfragment}{Slides and Course Notes}
    \input{packages/stex-slides}
  \end{sfragment}
  \begin{sfragment}{Homework, Problems and Exams}
    \input{packages/stex-problem}
    
    \input{packages/stex-hwexam}
  \end{sfragment}

\end{sfragment}

\chapter{Stuff}

\begin{function}{\sTeX , \stex}
  Both print this \stex logo.
\end{function}

 \subsection{Semantic Macros and Notations}

 Semantic macros invoke a formally declared symbol.

 To declare a symbol (in a module), we use \cs{symdecl},
 which takes as argument the name of the corresponding
 semantic macro, e.g. |\symdecl{foo}| introduces the macro
 \cs{foo}. Additionally, \cs{symdecl} takes several options,
 the most important one being its arity. |foo| as declared above
 yields a \emph{constant} symbol. To introduce an \emph{operator}
 which takes arguments, we have to specify which arguments it takes.

 \begin{smodule}{SemanticMacrosExample}
   For example, to introduce binary multiplication,
   we can do |\symdecl{mult}[args=2]|. We can then supply
   the semantic macro with arbitrarily many notations, such as
   |\notation{mult}{#1 #2}|.
   
   \stexexample{
 \symdecl{mult}[args=2]
 \notation{mult}{#1 #2}
 $\mult{a}{b}$
}

 Since usually, a freshly introduced symbol also comes with a
 notation from the start, the \cs{symdef} command combines
 \cs{symdecl} and \cs{notation}. So instead of the above,
 we could have also written
 \begin{center} |\symdef{mult}[args=2]{#1 #2}| \end{center}

 \symdecl{mult}[args=2]
 \notation{mult}{#1 #2}

   \notation{mult}[cdot]{#1 \comp{\cdot} #2}
   \notation{mult}[times]{#1 \comp{\times} #2}
   Adding more notations like
   |\notation{mult}[cdot]{#1 \comp{\cdot} #2}| or 
   |\notation{mult}[times]{#1 \comp{\times} #2}|
   allows us to write |$\mult[cdot]{a}{b}$| and
   |$\mult[times]{a}{b}$|:
   \stexexample{
   \notation{mult}[cdot]{#1 \comp{\cdot} #2}
   \notation{mult}[times]{#1 \comp{\times} #2}
 $\mult[cdot]{a}{b}$ and $\mult[times]{a}{b}$
}
   \notation{mult}[cdot]{#1 \comp{\cdot} #2}
   \notation{mult}[times]{#1 \comp{\times} #2}

   Not using an explicit option with a semantic macro yields
   the first declared notation, unless changed\ednote{TODO}.

   Outside of math mode, or by using the starred variant
   |\foo*|, allows to provide a custom notation, where
   notational (or textual) components can be given
   explicitly in square brackets.
   \stexexample{
 $\mult*{\arg{a}\comp{\ast}\arg{b}}$ is the 
 \mult{\comp{product of} \arg{$a$} \comp{and} \arg{$b$}}
}

   In custom mode, prefixing an argument with a star will not
   print that argument, but still export it to \omdoc:
   \stexexample{
 \mult{\comp{Multiplying} \arg*{$\mult{a}{b}$} again by \arg{$b$}} yields...
}
   The syntax |*[|\meta{int}|]| allows switching
   the order of arguments. For example, given a 2-ary semantic
   macro |\forevery| with exemplary notation
   |\forall #1. #2|, we can write
   \stexexample{
     \symdecl{forevery}[args=2]
     \forevery{\arg[2]{The proposition $P$} \comp{holds for every} \arg[1]{$x\in A$}}
}

 When using |*[|$n$|]|, after reading the provided ($n$th) argument,
  the ``argument counter'' automatically 
 continues where we left off, so the |*[1]| in the above example
 can be omitted.

   For a macro with arity $>0$, we can refer to the operator
   \emph{itself} semantically by suffixing the semantic macro
   with an exclamation point |!| in either text or math mode.
   For that reason \cs{notation} (and thus \cs{symdef}) take an
   additional optional argument |op=|, which allows to assign
   a notation for the operator itself. e.g.
   \stexexample{
     \symdef{add}[args=2,op={+}]{#1 \comp+ #2}
     The operator $\add!$ adds two elements, as in $\add ab$.
   }

  |*| is composable with |!| for custom notations, as in:

   \stexexample{
 \mult!{\comp{Multiplication}} (denoted by $\mult!*{\comp\cdot}$) is defined by...
}

 The macro \cs{comp} as used everywhere above is responsible
 for highlighting, linking, and tooltips, and should be wrapped
 around the notation (or text) components that should be treated
 accordingly. While it is attractive to just wrap a whole notation,
 this would also wrap around e.g. the arguments themselves, so
 instead, the user is tasked with marking the notation components
 themself.

 The precise behaviour of \cs{comp} is governed by
 the macro \cs{@comp}, which takes two arguments: The tex code
 of the text
 (unexpanded) to highlight, and the URI of the current symbol.
 \cs{@comp} can be safely redefined to customize the behaviour.


 The starred variant |\symdecl*{foo}| does not introduce a semantic
 macro, but still declares a corresponding symbol. |foo| (like
 any other symbol, for that matter) can
 then be accessed via \cs{STEXsymbol}|{foo}| or (if |foo| was declared
 in a module |Foo|) via \cs{STEXModule}|{Foo}?{foo}|.

 both \cs{STEXsymbol} and \cs{STEXModule} take any
 arbitrary ending segment of a full URI to determine
 which symbol or module is meant. e.g.
 \cs{STEXsymbol}|{Foo?foo}| is also valid, as are e.g.
 \cs{STEXModule}|{path?Foo}?{foo}| or
 \cs{STEXsymbol}|{path?Foo?foo}|

 There's also a convient shortcut \cs{symref}|{?foo}{some text}| for
 \cs{STEXsymbol}|{?foo}![some text]|.

 \end{smodule}

 \subsubsection{Other Argument Types}

 So far, we have stated the arity of a semantic macro directly.
 This works if we only have ``normal'' (or more precisely: |i|-type) arguments.
  To make use of other argument types, instead of providing the arity
 numerically, we can provide it as a sequence of characters representing
 the argument types -- e.g. instead of writing |args=2|, we
 can equivalently write |args=ii|, indicating that the macro
 takes two |i|-type arguments.

 Besides |i|-type arguments, \sTeX has two other types, which we will
 discuss now.

 The first are \emph{binding} (|b|-type) arguments, representing
 variables that are \emph{bound} by the operator. This is the
 case for example in the above \cs{forevery}-macro:
 The first argument is not actually an argument that the
 |forevery| ``function'' is ``applied'' to; rather, the first argument
 is a new variable (e.g. $x$) that is \emph{bound} in the subsequent
 argument. More accurately, the macro should therefore have been
 implemented thusly:
   \begin{center}|\symdef{forevery}[args=bi]{\forall #1.\; #2}|\end{center}

 \begin{smodule}{OtherArgs}
 |b|-type arguments are indistinguishable from |i|-type arguments
 within \sTeX, but are treated very differently in \omdoc and by \mmt.
 More interesting \emph{within} \sTeX are |a|-type arguments,
 which represent (associative) arguments of flexible arity, which are
 provided as comma-separated lists.
 This allows e.g. better representing the \cs{mult}-macro above:
 
   \stexexample{
 \symdef{mult}[args=a]{#1}{##1 \comp\cdot ##2}
 $\mult{a,b,c,{d^e},f}$
}
 As the example above shows, notations get a little more complicated
 for associative arguments. For every |a|-type argument, the
 \cs{notation}-macro takes an additional argument that declares
 how individual entries in an |a|-type argument list are aggregated.
 The first notation argument then describes how the aggregated
 expression is combined into the full representation.

 For a more interesting example, consider a flexary operator
 for ordered sequences in ordered set, that taking 
 arguments |{a,b,c}| and |\mathbb{R}| prints
 $a \leq b \leq c\in \mathbb R$. This operator takes
 two arguments (an |a|-type argument and an |i|-type argument),
 aggregates the individuals of the associative argument using |\leq|,
 and combines the result with |\in| and the second argument thusly:

   \stexexample{
 \symdef{numseq}[args=ai]{#1 \comp\in #2}{##1 \comp\leq ##2}
 $\numseq{a,b,c}{\mathbb R}$
}

 Finally, |B|-type arguments combine the functionalities of |a|
 and |b|, i.e. they represent flexary binding operator arguments.

\ednote{what about e.g. \detokenize{\int_x\int_y\int_z f dx dy dz}?}
\ednote{``decompose'' a-type arguments into fixed-arity operators?}

 \end{smodule}

 \subsubsection{Precedences}

 Every notation has an (upwards) \emph{operator precedence} and
 for each argument a (downwards) \emph{argument precedence}
 used for automated bracketing. For example, a notation
 for a binary operator \cs{foo} could be declared like this:
 \begin{center} |\notation{foo}[prec=200;500x600]{#1 \comp{+} #2}| \end{center}
 assigning an operator precedence of 200, an argument precedence
 of 500 for the first argument, and an argument precedence of 600
 for the second argument.

 \sTeX insert brackets thusly: Upon encountering a semantic
 macro (such as \cs{foo}), its operator precedence (e.g. 200)
 is compared to the current downwards precedence (initially 
 \cs{neginfprec}). If the operator precedence is \emph{larger}
 than the current downwards precedence, parentheses are inserted
 around the semantic macro.

 Notations for symbols of arity 0 have a default precedence of \cs{infprec},
 i.e. by default, parentheses are never inserted around constants.
 Notations for symbols with arity $>0$ have a default operator
 precedence of $0$.
 If no argument precedences are explicitly provided, then by
 default they are equal to the operator precedence.

 Consequently, if some operator $A$ should bind stronger than
 some operator $B$, then $A$s operator precedence should be
 smaller than $B$s argument precedences.

 For example:
 \begin{smodule}{NotationsEx}
 \symdecl{plus}[args=2]
 \symdecl{times}[args=2]
 \stexexample{
\notation{plus}[prec=100]{#1 \comp{+} #2}
\notation{times}[prec=50]{#1 \comp{\cdot} #2}
$\plus{a}{\times{b}{c}}$ and $\times{a}{\plus{b}{c}}$
}


 \end{smodule}

 \subsection{Archives and Imports}

 \subsubsection{Namespaces}
   

 \subsubsection{Paths in Import-Statements}

 

	
	
\csname if@infulldoc\endcsname\else\end{document}\fi
