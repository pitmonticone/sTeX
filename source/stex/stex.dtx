%^^A meta-comment
%^^A  An Infrastructure for Semantic Macros and Module Scoping
%^^A  Copyright (c) 2022 Michael Kohlhase, all rights reserved
%^^A                 this file is released under the
%^^A                 LaTeX Project Public License (LPPL)
%^^A  
%^^A  The original of this file is in the public repository at 
%^^A  http://github.com/sLaTeX/sTeX/
%^^A 
% \iffalse
%<*driver>
\def\stexdocpath{../../doc}
\input{\stexdocpath/stex-docheader}
\stexdoctitle{\sTeX-Basics}{stex-basics}

\docmodule
%</driver>
% \fi
% \stexmaketitle
% \begin{stexmanual}
%   
% \end{stexmanual}
% \begin{documentation}
%^^A   \begin{TemplateInterfaceDescription}{foo}
%^^A     \TemplateArgument{1}{Something Here}
%^^A     \TemplateSemantics{Some Narf Here}
%^^A   \end{TemplateInterfaceDescription}
%^^A   \begin{TemplateDescription}{foo}{bar}
%^^A     \TemplateKey{narf}{Something Here}
%^^A     \TemplateSemantics{Some Narf Here}
%^^A   \end{TemplateDescription}
%^^A   \begin{InstanceDescription}{foo}{newinst}{bar}
%^^A     \InstanceKey{narf}{Something Here}
%^^A     \InstanceSemantics{Some Narf Here}
%^^A   \end{InstanceDescription}
%^^A   \cs{stex_kpsewhich:Nn}
%   \begin{function}{\stex_kpsewhich:Nn}
%     Foo
%     \begin{texnote} Foo! \end{texnote}
%
%     \begin{syntax} \cs{stex_kpsewhich:Nn} \meta{something} \Arg{argh}
%     \end{syntax}
%
%     \begin{arguments}
%       \item Narf?
%     \end{arguments}
%
%   \end{function}
%   \begin{function}{\stex_get_env:Nn, \stex_get_env:Nnn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_debug:nn}
%     Foo
%   \end{function}
%   \begin{variable}{\c_stex_pwd_file,\c_stex_main_file}
%     Foo
%   \end{variable}
%   \begin{variable}{\c_stex_languages_prop, \c_stex_language_abbrevs_prop}
%     Foo
%   \end{variable}
%   \begin{variable}{\l_stex_current_language_str}
%     Foo
%   \end{variable}
%   \begin{function}{\stex_set_language:n, \stex_set_language:x, \stex_set_language:o}
%     Foo
%   \end{function}
%   \begin{function}{\stex_pseudogroup:nn,\stex_pseudogroup_restore:N}
%     Foo
%   \end{function}
%   \begin{function}{\stex_pseudogroup_with:nn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_metagroup_new:n, \stex_metagroup_new:o}
%     Foo
%   \end{function}
%   \begin{function}{\stex_metagroup_do_in:nn, \stex_metagroup_do_in:nx}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_if_do_html:}
%     Whether to currently produce any HTML annotations (can be false
%     in some advanced structuring environments, for example)
%   \end{function}
%   \begin{function}{\stex_suppress_html:n}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_html_backend:}
%     Foo
%   \end{function}
%   \begin{function}[EXP]{\ifstexhtml}
%     Foo
%   \end{function}
%   \begin{function}{\stex_keys_define:nnnn, \stex_keys_set:nn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_new_stylable_env:nnnnnnn, \stex_new_stylable_cmd:nnnnn, \stex_style_apply:}
%     Foo
%   \end{function}
%   \begin{function}{\stex_deactivate_macro:Nn, \stex_reactivate_macro:N}
%     Foo
%   \end{function}
%   \begin{function}{\ignorespacesandpars}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_str_if_ends_with:nn}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_str_if_starts_with:nn}
%     Foo
%   \end{function}
%   \begin{function}[EXP]{\stex_macro_body:N}
%     Foo
%   \end{function}
%   \begin{function}[EXP]{\stex_macro_definition:N}
%     Foo
%   \end{function}
%   \begin{function}{\stex_persist:n,\stex_persist:o,\stex_persist:x}
%     Foo
%   \end{function}
%   \begin{function}{\stex_file_set:Nn, \stex_file_set:No, \stex_file_set:Nx}
%     Foo
%   \end{function}
%   \begin{function}{\stex_file_resolve:Nn, \stex_file_resolve:No, \stex_file_resolve:Nx}
%     Foo
%   \end{function}
%   \begin{function}{\stex_map_uri:Nnnnn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_uri_set:Nn, \stex_uri_set:No, \stex_uri_set:Nx}
%     Foo
%   \end{function}
%   \begin{function}{\stex_uri_resolve:Nn, \stex_uri_resolve:No, \stex_uri_resolve:Nx}
%     Foo
%   \end{function}
%   \begin{function}[EXP]{\stex_file_use:N}
%     Foo
%   \end{function}
%   \begin{function}[EXP]{\stex_uri_use:N}
%     Foo
%   \end{function}
%   \begin{function}{\stex_uri_from_repo_file:NNNn, \stex_uri_from_repo_file_nolang:NNNn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_uri_from_current_file:Nn, \stex_uri_from_current_file_nolang:Nn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_uri_add_module:NNn, \stex_uri_add_module:NNo}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_file_absolute:N}
%     Foo
%   \end{function}
%   \begin{function}{\stex_filestack_push:n, \stex_filestack_pop:}
%     Foo
%   \end{function}
%   \begin{function}[TF]{\stex_file_starts_with:N}
%     Foo
%   \end{function}
%   \begin{function}{\stex_file_split_off_ext:NN,\stex_file_split_off_lang:NN}
%     Foo
%   \end{function}
%   \begin{variable}{\mathhub,\c_stex_mathhub_file}
%     Foo
%   \end{variable}
%   \begin{function}{\stex_require_repository:n, \stex_require_repository:o}
%     Foo
%   \end{function}
%   \begin{function}{\stex_set_current_repository:n}
%     Foo
%   \end{function}
%   \begin{variable}{\c_stex_mathhub_main_manifest_prop, \l_stex_current_repository_prop}
%     Foo
%   \end{variable}
%   \begin{variable}{\l_stex_current_doc_uri}
%     Foo
%   \end{variable}
%   \begin{function}{\stex_get_document_uri:}
%     Foo
%   \end{function}
%   \begin{function}{\STEXtitle,\stex_document_title:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_ref_new_doc_target:n,\sreflabel}
%     Foo
%   \end{function}
%   \begin{function}{\stex_ref_new_sym_target:n}
%     Foo
%   \end{function}
%   \begin{function}{\sref,\extref}
%     Foo
%   \end{function}
%   \begin{function}{\stex_sms_allow:N,\stex_sms_allow_escape:N,\stex_sms_allow_env:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_sms_allow_import:Nn, \stex_sms_allow_import_env:nn}
%     Foo
%   \end{function}
%   \begin{variable}{\g_stex_sms_import_code}
%     Foo
%   \end{variable}
%   \begin{function}[pTF]{\stex_if_smsmode:}
%     Foo
%   \end{function}
%   \begin{function}{\stex_file_in_smsmode:nn,\stex_file_in_smsmode:on}
%     Foo
%   \end{function}
%   \begin{function}{\stex_smsmode_do:}
%     Foo
%   \end{function}
%   \begin{variable}{\l_stex_current_module_str}
%     Foo
%   \end{variable}
%   \begin{function}[EXP]{\stex_current_module_prop:}
%     Foo
%   \end{function}
%   \begin{variable}{\l_stex_all_modules_seq}
%     Foo
%   \end{variable}
%   \begin{function}[pTF]{\stex_if_in_module:}
%     Foo
%   \end{function}
%   \begin{function}[pTF]{\stex_if_module_exists:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_do_up_to_module:n, \stex_do_up_to_module:x}
%     Foo
%   \end{function}
%   \begin{function}{\stex_add_to_current_module:n,\stex_add_to_current_module:x}
%     Foo
%   \end{function}
%   \begin{function}{\stex_add_module_dependency:nnnn,\stex_add_module_dependency:oonn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_iterate_modules:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_iterate_modules:nn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_add_module_decl:nnnnnnnN}
%     Foo
%   \end{function}
%   \begin{function}{\stex_iterate_decls:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_iterate_decls:nn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_add_module_notation:nnnnn,\stex_add_module_notation:eoexo}
%     Foo
%   \end{function}
%   \begin{function}{\stex_execute_in_module:n,\stex_execute_in_module:x,\STEXexport}
%     Foo
%   \end{function}
%   \begin{function}{\stex_every_module:n}
%     Foo
%   \end{function}
%   \begin{variable}{\l_stex_metatheory_uri}
%     Foo
%   \end{variable}
%   \DescribeEnv{smodule}
%     Foo
%
%   \begin{function}{\setmetatheory}
%     Foo
%   \end{function}
%   \begin{variable}{\l_stex_current_ns_uri}
%     Foo
%   \end{variable}
%   \begin{function}{\stex_get_current_namespace:}
%     Foo
%   \end{function}
%   \begin{function}{\stex_module_setup:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_close_module:}
%     Foo
%   \end{function}
%   \begin{function}{\stex_activate_module:n,\stex_activate_module:o,\stex_activate_module:x}
%     Foo
%   \end{function}
%   \DescribeEnv{mmtinterface}
%     Foo
%
%   \DescribeEnv{structural_feature_module}
%     Foo
%
%   \begin{function}{\stex_import_module_uri:nn}
%     Destructs a relative \verb|[some/archive]{some/path?Name}|-pair into
%     absolute values \cs{l_stex_import_archive_str},
%     \cs{l_stex_import_path_str}, \cs{l_stex_import_name_str}:
%   \end{function}
%   \begin{function}{\stex_import_require_module:nnn}
%     Foo
%   \end{function}
%   \begin{function}{\usemodule}
%     Foo
%   \end{function}
%   \begin{function}{\importmodule}
%     Foo
%   \end{function}
%   \begin{function}{\MMTinclude}
%     Foo
%   \end{function}
%   \begin{function}{\stex_decl_parse_arity:}
%     Foo
%   \end{function}
%   \begin{function}{\stex_symdecl_top:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_symdecl_do:}
%     Foo
%   \end{function}
%   \begin{function}{\symdecl}
%     Foo
%   \end{function}
%   \begin{function}{\textsymdecl}
%     Foo
%   \end{function}
%   \begin{function}{\stex_get_symbol:n}
%     Foo
%   \end{function}
%   \begin{function}{\stex_notation_top:nnn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_notation_do:nn}
%     Foo
%   \end{function}
%   \begin{function}{\notation}
%     Foo
%   \end{function}
%   \begin{function}{\symdef}
%     Foo
%   \end{function}
%   \begin{function}{\vardef}
%     Foo
%   \end{function}
%   \begin{function}{\_stex_invoke_symbol:nnnnnnnN}
%     Foo
%   \end{function}
%   \begin{function}{\_stex_invoke_variable:nnnnnn}
%     Foo
%   \end{function}
%   \begin{function}{\stex_invoke_symbol:}
%     Foo
%   \end{function}
%   \begin{function}{\infprec,\neginfprec}
%     Foo
%   \end{function}
%   \begin{function}{\STEXInternalTermMathArgiii,\STEXInternalTermMathOMSiii,\STEXInternalTermMathOMAiii,\STEXInternalTermMathOMBiii}
%     Foo
%   \end{function}
%   \begin{function}{\dobrackets,\withbrackets,\dowithbrackets}
%     Foo
%   \end{function}
%   \begin{function}{\STEXinvisible}
%     Foo
%   \end{function}
%   \begin{function}{\symname,\sn,\sns,\Symname,\Sn,\Sns,\symref,\sr}
%     Foo
%   \end{function}
%   \begin{function}{\comp}
%     Foo
%   \end{function}
%   \begin{function}{\compemph,\compemph@uri}
%     Foo
%   \end{function}
%   \begin{function}{\defemph,\defemph@uri}
%     Foo
%   \end{function}
%   \begin{function}{\symrefemph,\symrefemph@uri}
%     Foo
%   \end{function}
%   \begin{function}{\varemph,\varemph@uri}
%     Foo
%   \end{function}
%
%   \DescribeEnv{mathstructure}
%     Foo
%
% \end{documentation}
%
% \begin{implementation}
%
%   \begin{sfragment}{Setting up}
% Setup code for the document class
%    \begin{macrocode}
%<*cls>
%%%%%%%%%%%%%   stex.dtx   %%%%%%%%%%%%%

\RequirePackage{expl3,l3keys2e}
\ProvidesExplClass{stex}{2022/09/14}{3.3.0}{sTeX document class}

\DeclareOption*{\PassOptionsToPackage{\CurrentOption}{stex}}
\ProcessOptions

\RequirePackage{stex}

\LoadClass{article}
%</cls>
%    \end{macrocode}
%
% Setup code for the package
%
%    \begin{macrocode}
%<*package>
\RequirePackage{expl3,l3keys2e,ltxcmds}
\ProvidesExplPackage{stex}{2022/09/14}{3.3.0}{sTeX package}
\RequirePackage{stex-logo} % externalized for backwards-compatibility reasons
\RequirePackage{standalone}

\message{^^J*~This~is~sTeX~version~3.3.0~*^^J}
%    \end{macrocode}
%
% Package options:
%
%    \begin{macrocode}
\keys_define:nn { stex } {
  debug      .str_set_x:N  = \c_stex_debug_clist ,
  lang       .clist_set:N  = \c_stex_languages_clist ,
  mathhub    .tl_set_x:N   = \mathhub ,
  usesms     .bool_set:N   = \c_stex_persist_mode_bool ,
  writesms   .bool_set:N   = \c_stex_persist_write_mode_bool ,
  checkterms .bool_set:N   = \c_stex_check_terms_bool ,
  image      .bool_set:N   = \c_tikzinput_image_bool,
  unknown    .code:n       = {}
}
\exp_args:NNo \clist_set:Nn \c_stex_debug_clist \c_stex_debug_clist
\ProcessKeysOptions { stex }
%    \end{macrocode}
%
% Error messages:
%    \begin{macrocode}
\input{stex-en.ldf}
%    \end{macrocode}
%
% \end{sfragment}
%
% \begin{sfragment}{Utilities}
%
% \begin{sfragment}{Calling kpsewhich and Environment Variables}
%
%    \begin{macrocode}
%<@@=stex_envs>
%    \end{macrocode}
%
% \begin{macro}{\stex_kpsewhich:Nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_kpsewhich:Nn {\group_begin:
  \catcode`\ =12
  \sys_get_shell:nnN { kpsewhich ~ #2 } { } \l_tmpa_tl
  \tl_gset_eq:NN \l_tmpa_tl \l_tmpa_tl
  \group_end:
  \exp_args:NNo\str_set:Nn #1 {\l_tmpa_tl}
  \tl_trim_spaces:N #1
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_env:Nn,\stex_get_env:Nnn}
%    \begin{macrocode}
\sys_if_platform_windows:TF{
  \cs_new_protected:Nn \stex_get_env:Nnn {\group_begin:
    \escapechar=-1\catcode`\\=12
    \stex_kpsewhich:Nn-1{-expand-var~\c_percent_str#3\c_percent_str}
    \exp_args:NNx\use:nn\group_end:{
      \str_set:Nn\exp_not:N#1{#1}
    }
  }
}{
  \cs_new_protected:Nn \stex_get_env:Nnn {
    \stex_kpsewhich:Nn #1 {-var-value~#2}
  }
}
\cs_new_protected:Nn \stex_get_env:Nn {
  \stex_get_env:Nnn #1{#2}{#2}
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Logging}
%    \begin{macrocode}
%<@@=stex_debug>
%    \end{macrocode}
%
% \begin{macro}{\stex_debug:nn}
%   Logging:
%    \begin{macrocode}
\cs_new_protected:Nn \stex_debug:nn {
  \clist_if_in:NnTF \c_stex_debug_clist { all }{
    \_@@_:nn{#1}{#2}
  }{
    \clist_if_in:NnT \c_stex_debug_clist { #1 }{}{
      \_@@_:nn{#1}{#2}
    }
  }
}

\cs_new_protected:Nn \_@@_:nn {
  \msg_set:nnn{stex}{debug / #1}{
    \\Debug~#1:~#2\\
  }
  \msg_none:nn{stex}{debug / #1}
}
%    \end{macrocode}
% \end{macro}

% \begin{macro}{\_stex_fatal_error:n,\_stex_fatal_error:nnn,\_stex_fatal_error:nxx}
%   To avoid dead locks etc., we throw errors and make tex stop
%   entirely:
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_fatal_error:n {
  \msg_error:nn{stex}{#1}\input{Fatal~Error!!}
}
\cs_new_protected:Nn \_stex_fatal_error:nnn {
  \msg_error:nnn{stex}{#1}{#2}{#3}\input{Fatal~Error!!}
}
\cs_generate_variant:Nn \_stex_fatal_error:nnn {nxx}
%    \end{macrocode}
% \end{macro}
%
% We check an environment variable:
%
%    \begin{macrocode}
\stex_get_env:Nn\_@@_env_str{STEX_DEBUG}
\str_if_empty:NF\_@@_env_str {
  \clist_set:No \c_stex_debug_clist {\_@@_env_str}
}
\cs_undefine:N\_@@_env_str

\exp_args:NNo \clist_if_in:NnTF \c_stex_debug_clist {\tl_to_str:n{all}} {
    \msg_redirect_module:nnn{ stex }{ none }{ term }
    \stex_debug:nn{all}{Logging~everything!}
}{
  \clist_map_inline:Nn \c_stex_debug_clist {
    \msg_redirect_name:nnn{ stex }{ debug / #1 }{ term }
    \stex_debug:nn{#1}{Logging~#1}
  }
}
%    \end{macrocode}
%
% \end{sfragment}
%
% \begin{sfragment}{Languages}
%    \begin{macrocode}
%<@@=stex_lang>
%    \end{macrocode}
%   \begin{variable}{\c_stex_languages_prop,\c_stex_language_abbrevs_prop}
%
% We store language abbreviations in two (mutually inverse) 
% property lists:
%    \begin{macrocode}
\exp_args:NNx \prop_const_from_keyval:Nn \c_stex_languages_prop { \tl_to_str:n {
  en = english ,
  de = ngerman ,
  ar = arabic ,
  bg = bulgarian ,
  ru = russian ,
  fi = finnish ,
  ro = romanian ,
  tr = turkish ,
  fr = french
}}

\exp_args:NNx \prop_const_from_keyval:Nn \c_stex_language_abbrevs_prop { \tl_to_str:n {
  english   = en ,
  ngerman   = de ,
  arabic    = ar ,
  bulgarian = bg ,
  russian   = ru ,
  finnish   = fi ,
  romanian  = ro ,
  turkish   = tr ,
  french    = fr
}}
% todo: chinese simplified (zhs)
%       chinese traditional (zht)
%    \end{macrocode}
% \end{variable}
%
% \begin{variable}{\l_stex_current_language_str}
%    \begin{macrocode}
\str_new:N \l_stex_current_language_str
%    \end{macrocode}
% \end{variable}
%
% we use the |lang|-package option to load the corresponding
% babel languages:
% \begin{macro}{\stex_set_language:n, \stex_set_language:x, \stex_set_language:o}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_set_language:n {
  \str_set:Nn \l_stex_current_language_str { #1 }
  \prop_if_in:NnTF \c_stex_languages_prop {#1} {
    \cs_if_eq:NNTF\@onlypreamble\@notprerr{ 
      \ltx@ifpackageloaded{babel}{
        \exp_args:Nx\selectlanguage{
          \prop_item:Nn \c_stex_languages_prop {#1}
        }
      }{}
    }{
      \str_if_eq:nnTF {#1} {tr} {
        \RequirePackage[turkish,shorthands=:!]{babel}
      }{
        \RequirePackage[\prop_item:Nn \c_stex_languages_prop {#1}]{babel}
      }
    }
  }{
    \msg_error:nnx{stex}{error/unknownlanguage}{#1}
  }
}
\cs_generate_variant:Nn \stex_set_language:n {x,o}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_current_language:}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_current_language: {
  \seq_get_right:NN \g_stex_current_file \l_tmpa_str
  \seq_set_split:NnV \l_tmpa_seq . \l_tmpa_str
  \seq_pop_right:NN \l_tmpa_seq \l_tmpa_str % = ".tex"
  \exp_args:No \str_if_eq:nnF \l_tmpa_str {tex} {
    \exp_args:No \str_if_eq:nnF \l_tmpa_str {dtx} {
      \exp_args:No \str_if_eq:nnF \l_tmpa_str {ltx} {
        \exp_args:NNo \seq_put_right:Nn \l_tmpa_seq \l_tmpa_str
      }
    }
  }
  \seq_pop_left:NN \l_tmpa_seq \l_tmpa_str % <filename>
  \seq_if_empty:NF \l_tmpa_seq { %remaining element should be [<something>.]language
    \seq_pop_right:NN \l_tmpa_seq \l_@@_str
    \str_if_eq:NNF \l_@@_str \l_stex_current_language_str {
      \stex_set_language:o \l_@@_str
    }
    \stex_debug:nn{lang} {Language~\l_stex_current_language_str~
      inferred~from~file~name}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Group-like Behaviours}
%    \begin{macrocode}
%<@@=stex_groups>
%    \end{macrocode}
%
%   \begin{macro}{\stex_pseudogroup:nn,\stex_pseudogroup_restore:N}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_pseudogroup:nn {
  \exp_args:Nnx \use:nn {#1}{#2}
}
\cs_new:Nn \stex_pseudogroup_restore:N {
  \tl_if_exist:NTF #1 {
    \tl_set:Nn \exp_not:N #1 { \exp_args:No \exp_not:n #1 }
  }{
    \cs_undefine:N \exp_not:N #1
  }
}
%    \end{macrocode}
%   \end{macro}
%
%   \begin{macro}{\stex_pseudogroup_with:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_pseudogroup_with:nn {
  \tl_map_inline:nn{#1}{
    \cs_set_eq:cN{_@@_\tl_to_str:n{##1}}##1
  }
  #2
  \tl_map_inline:nn{#1}{
    \cs_set_eq:Nc##1{_@@_\tl_to_str:n{##1}}
    \cs_undefine:c{_@@_\tl_to_str:n{##1}}
  }
}
%    \end{macrocode}
%   \end{macro}
%
%   \begin{macro}{\stex_metagroup_new:n, \stex_metagroup_new:o}
% List of all currently existing metagroup identifiers
%    \begin{macrocode}
\seq_new:N \l_@@_ids_seq
%    \end{macrocode}
% start a new metagroup at the current group level with id \#1
%    \begin{macrocode}
\cs_new_protected:Nn \stex_metagroup_new:n {
    \str_set:cx{l_@@_#1_int} {\int_use:N\currentgrouplevel}
    \seq_put_right:Nn \l_@@_ids_seq {#1}
}
\cs_generate_variant:Nn \stex_metagroup_new:n {o}
%    \end{macrocode}
%   \end{macro}
%
%   \begin{macro}{\stex_metagroup_do_in:nn, \stex_metagroup_do_in:nx}
%    \begin{macrocode}
\prg_new_conditional:Nnn \_@@_exists:n {TF} {
    \str_if_exist:cTF{l_@@_#1_int}
        \prg_return_true: \prg_return_false:
}

\cs_new_protected:Nn \stex_metagroup_do_in:nn {
    \_@@_exists:nTF{#1}{
        \_@@_do_in:nn{#1}{#2}
    }{
      \msg_error:nnn{stex}{error/metagroup/missing}{#1}
    }
}
\cs_generate_variant:Nn \stex_metagroup_do_in:nn {nx}

\cs_new_protected:Nn \_@@_do_in:nn {
  \exp_args:Nnx\stex_debug:nn{metagroup}{adding~to~\detokenize{#1}}
  \tl_set:Nn\_@@_tmp{#2}
  \exp_args:Nx \int_compare:nNnF {\use:c{l_@@_#1_int}}
      = \currentgrouplevel {
      \tl_if_exist:cTF{g_@@_#1_\the\currentgrouplevel _content}{
        \exp_args:Nno \tl_gput_right:cn{g_@@_#1_\the\currentgrouplevel _content}
      }{
        \exp_args:Nno \tl_gset:cn{g_@@_#1_\the\currentgrouplevel _content}
      }\_@@_tmp
      \bool_if_exist:cF {l_@@_\the\currentgrouplevel _bool} {
          \group_insert_after:N \_@@_do:
          \bool_set_true:c {l_@@_\the\currentgrouplevel _bool}
      }
  }
  \_@@_tmp
}

\cs_new_protected:Nn \_@@_do: {
    \seq_map_inline:Nn \l_@@_ids_seq {
        \tl_if_exist:cT{g_@@_##1_\int_eval:n{\currentgrouplevel+1}_content}{
            \exp_args:NNno \exp_args:Nno \_@@_do_in:nn{##1}{
                \csname g_@@_##1_\int_eval:n{\currentgrouplevel+1}_content\endcsname
            }
            \cs_undefine:c{g_@@_##1_\int_eval:n{\currentgrouplevel+1}_content}
        }
        \bool_if_exist:cF {l_@@_\int_eval:n\currentgrouplevel _bool} {
            \group_insert_after:N \_@@_do:
            \bool_set_true:c {l_@@_\int_eval:n\currentgrouplevel _bool}
        }
    }
}
%    \end{macrocode}
%   \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{HTML Annotations}
%    \begin{macrocode}
%<@@=stex_annotate>
%    \end{macrocode}
%
% \begin{macro}[TF]{\stex_if_do_html:}
%  Whether to (locally) produce HTML output
%    \begin{macrocode}
\bool_new:N \_stex_html_do_output_bool
\bool_set_true:N \_stex_html_do_output_bool

\prg_new_conditional:Nnn \stex_if_do_html: {p,T,F,TF} {
  \bool_if:nTF \_stex_html_do_output_bool
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_suppress_html:n}
%  Temporarily disable HTML output
%    \begin{macrocode}
\cs_new_protected:Nn \stex_suppress_html:n {
  \stex_pseudogroup:nn{
    \bool_set_false:N \_stex_html_do_output_bool
    #1
  }{
    \stex_if_do_html:T {
      \bool_set_true:N \_stex_html_do_output_bool
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% We determine the backend:
% \begin{macro}[pTF]{\stex_html_backend:}
% \begin{macro}{\ifstexhtml}
%    \begin{macrocode}
\ifcsname if@rustex\endcsname\else
  \expandafter\newif\csname if@rustex\endcsname
  \@rustexfalse
\fi
\ifcsname if@latexml\endcsname\else
  \expandafter\newif\csname if@latexml\endcsname
  \@latexmlfalse
\fi
\tl_if_exist:NF\stex@backend{
  \if@rustex
    \def\stex@backend{rustex}
  \else
    \if@latexml
      \def\stex@backend{latexml}
    \else
      \cs_if_exist:NTF\HCode{
        \def\stex@backend{tex4ht}
      }{
        \def\stex@backend{pdflatex}
      }
    \fi
  \fi
}
\input{stex-backend-\stex@backend.cfg}

\newif\ifstexhtml
\stex_html_backend:TF\stexhtmltrue\stexhtmlfalse
%    \end{macrocode}
% \end{macro}
% \end{macro}
%
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_html_checkempty:n {
  \tl_set:Nn \l_stex_html_arg_tl { #1 }
  \tl_if_empty:NT \l_stex_html_arg_tl {
    \tl_set_eq:NN \l_stex_html_arg_tl \c_stex_html_emptyarg_tl
  }
}
%    \end{macrocode}
%
% \end{sfragment}
%
% \begin{sfragment}{Auxiliary Methods}
%    \begin{macrocode}
%<@@=stex_aux>
%    \end{macrocode}

% \begin{macro}{\stex_deactivate_macro:Nn, \stex_reactivate_macro:N}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_deactivate_macro:Nn {
  \tl_set_eq:cN{\tl_to_str:n{#1}~-~orig}#1
  \tl_set:Nn#1{
    \msg_error:nnnn{stex}{error/deactivated-macro}{\detokenize{#1}}{#2}
  }
}
\cs_new_protected:Nn \stex_reactivate_macro:N {
  \exp_after:wN\let\exp_after:wN#1\csname \detokenize{#1}~-~orig\endcsname
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\ignorespacesandpars}
%    \begin{macrocode}
\protected\def\ignorespacesandpars{
  \begingroup\catcode13=10\relax
  \@ifnextchar\par{
    \endgroup\expandafter\ignorespacesandpars\@gobble
  }{
    \endgroup
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_keys_define:nnnn}
%    \begin{macrocode}
\cs_new_nopar:Nn \stex_keys_define:nnnn {
  \tl_gset:cn {_@@_keys_#1_pre_tl}{#2}
  \tl_gset:cn {_@@_keys_#1_def_tl}{#3}
  \tl_if_empty:nF{#4}{
    \clist_map_inline:nn{#4}{
      \tl_set_eq:Nc \l_@@_tl {_@@_keys_##1_pre_tl}
      \tl_gput_left:co{_@@_keys_#1_pre_tl} \l_@@_tl
      \tl_set_eq:Nc \l_@@_tl {_@@_keys_##1_def_tl}
      \tl_gput_left:cn{_@@_keys_#1_def_tl} ,
      \tl_gput_left:co{_@@_keys_#1_def_tl} \l_@@_tl
    }
  }
  \tl_set_eq:Nc \l_@@_tl {_@@_keys_#1_def_tl}
  %\exp_args:Nnx \stex_debug:nn{keys}{
  %  Setting~keys~for~#1:^^J
  %  \meaning \l_@@_tl
  %}
  \exp_args:Nno \keys_define:nn {stex / #1} {\l_@@_tl}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_keys_set:nn}
%    \begin{macrocode}
\cs_new_nopar:Nn \stex_keys_set:nn {
  \use:c{_@@_keys_#1_pre_tl}
  \keys_set:nn {stex / #1} { #2 }
}
%    \end{macrocode}
% \end{macro}
%
% Some ubiquitous key sets:
%    \begin{macrocode}
\stex_keys_define:nnnn{archive file}{
  \str_clear:N \l_stex_key_archive_str
  \str_clear:N \l_stex_key_file_str
}{
  archive .str_set_x:N = \l_stex_key_archive_str ,
  file    .str_set_x:N = \l_stex_key_file_str
}{}

\stex_keys_define:nnnn{id}{
  \str_clear:N \l_stex_key_id_str
}{
  id .str_set_x:N = \l_stex_key_id_str
}{}

\stex_keys_define:nnnn{title}{
  \tl_clear:N \l_stex_key_title_tl
}{
  title .tl_set:N = \l_stex_key_title_tl
}{}

\stex_keys_define:nnnn{style}{
  \str_clear:N \l_stex_key_style_str
}{
  style .str_set_x:N = \l_stex_key_style_str
}{}

\stex_keys_define:nnnn{deprecate}{
  \str_clear:N \l_stex_key_deprecate_str
}{
  deprecate     .str_set_x:N  = \l_stex_key_deprecate_str
}{}

\cs_new_protected:Nn \_stex_do_deprecation:n {
  \str_if_empty:NF \l_stex_key_deprecate_str {
    \msg_warning:nnxx{stex}{warning/deprecated}{#1}{\l_stex_key_deprecate_str}
  }
}
%    \end{macrocode}
%
% \begin{macro}{\stex_new_stylable_env:nnnnnnn,\stex_new_stylable_cmd:nnnnn,\stex_style_apply:}
%    \begin{macrocode}
\tl_clear:N \thisstyle

\cs_new_protected:Nn \stex_new_stylable_cmd:nnnnn {
  \exp_after:wN \newcommand \cs:w stexstyle#1 \cs_end:[2][]{
    \_@@_patch:nnn{#1}{##1}{##2}
  }
  \exp_after:wN \NewDocumentCommand\cs:w #1\cs_end:{#2}{
    \cs_set:Npn \stex_style_apply: {
      \_@@_apply_patch:n{#1}
    }
    #3
  }
  \tl_set:cn {_@@_style_#1:} { #4 }
  \tl_set:cn {_@@_style_#1:} { #5 }
}

\cs_new_protected:Nn \_@@_apply_patch:n {
  \tl_if_empty:NTF \thisstyle {
    \use:c{_@@_style_#1:}
  }{
    \tl_if_exist:cTF{_@@_style_#1_\thisstyle :}{
      \use:c{_@@_style_#1_\thisstyle :}
    }{
      \use:c{_@@_style_#1:}
    }
  }
}

\cs_new_protected:Nn \_@@_patch:nnn {
  \str_if_empty:nTF {#2}{
    \tl_set:cn{_@@_style_#1:}{#3}
  }{
    \tl_set:cn{_@@_style_#1_#2:}{#3}
  }
}

\cs_new_protected:Nn \stex_new_stylable_env:nnnnnnn {
  \exp_after:wN \newcommand \cs:w stexstyle#1 \cs_end:[3][]{
    \_@@_patch:nnnn{#1}{##1}{##2}{##3}
  }
  \NewDocumentEnvironment{#7#1}{#2}{
    \cs_set:Npn \stex_style_apply: {
      \_@@_apply_patch_begin:n{#1}
    }
    #3
  }{
    \cs_set:Npn \stex_style_apply: {
      \_@@_apply_patch_end:n{#1}
    }
    #4
  }
  \tl_set:cn {_@@_style_#1_start:} { #5 }
  \tl_set:cn {_@@_style_#1_end:} { #6 }
}

\cs_new_protected:Nn \_@@_patch:nnnn {
  \str_if_empty:nTF {#2}{
    \tl_set:cn{_@@_style_#1_start:}{#3}
    \tl_set:cn{_@@_style_#1_end:}{#4}
  }{
    \tl_set:cn{_@@_style_#1_#2_start:}{#3}
    \tl_set:cn{_@@_style_#1_#2_end:}{#4}
  }
}

\cs_new_protected:Nn \_@@_apply_patch_begin:n {
  \tl_set_eq:NN \thistitle \l_stex_key_title_tl
  \tl_set_eq:NN \thisstyle \l_stex_key_style_str
  \tl_set_eq:NN \thisid \l_stex_key_id_str
  \tl_if_empty:NTF \thisstyle {
    \use:c{_@@_style_#1_start:}
  }{
    \tl_if_exist:cTF{_@@_style_#1_\thisstyle _start:}{
      \use:c{_@@_style_#1_\thisstyle _start:}
    }{
      \use:c{_@@_style_#1_start:}
    }
  }
}

\cs_new_protected:Nn \_@@_apply_patch_end:n {
  \tl_if_empty:NTF \thisstyle {
    \use:c{_@@_style_#1_end:}
  }{
    \tl_if_exist:cTF{_@@_style_#1_\thisstyle _end:}{
      \use:c{_@@_style_#1_\thisstyle _end:}
    }{
      \use:c{_@@_style_#1_end:}
    }
  }
}
%    \end{macrocode}
%
% \end{macro}
%
% \begin{macro}[pTF]{\stex_str_if_ends_with:nn}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_str_if_ends_with:nn {p,T,F,TF} {
  \exp_args:Ne \str_if_eq:nnTF {
    \str_range:nnn{#1}{- \str_count:n{#2}}{-1}
  }{#2}\prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\stex_str_if_starts_with:nn}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_str_if_starts_with:nn {p,T,F,TF} {
  \exp_args:Ne \str_if_eq:nnTF {
    \str_range:nnn{#1}{1}{\str_count:n{#2}}
  }{#2}\prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\stex_macro_body:N}
%    \begin{macrocode}
\cs_new:Npn \_@@_start:#1\_@@_end: {\exp_not:n{#1}}
\cs_new_protected:Nn \_@@_end: {}
\cs_new:Nn \stex_macro_body:N {
  \exp_args:Nne\use:nn{\exp_after:wN \_@@_start: #1}{
    \_@@_args:e {\cs_parameter_spec:N #1}\_@@_end:
  }
}

\cs_new:Nn \_@@_args:n {
  \tl_if_empty:nF{#1}{
      {##\exp_args:Ne \tl_head:n {\tl_tail:n {#1}}}
      \_@@_args:e {\exp_args:Ne\tl_tail:n{\tl_tail:n{#1}}}
  }
}
\cs_generate_variant:Nn \_@@_args:n {e}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\stex_macro_definition:N}
%    \begin{macrocode}
\cs_new:Nn \stex_macro_definition:N {
  \_@@_prefix:e {\cs_prefix_spec:N #1}
  \def\exp_not:N #1
  \_@@_params:e {\cs_parameter_spec:N #1} 
  {
    \stex_macro_body:N #1
  }
}

\cs_new:Nn \_@@_prefix:n {
  \tl_if_empty:nF{#1}{
    \str_if_eq:eeTF {
      \tl_range:nnn{#1}{1}{10}~
    }{\tl_to_str:n{\protected}}{
      \protected
      \_@@_prefix_long:e {
          \str_range:nnn{#1}{11}{-1}
      }
    }{
      \_@@_prefix_long:n {#1}
    }
  }
}
\cs_generate_variant:Nn \_@@_prefix:n {e}

\cs_new:Nn \_@@_prefix_long:n {
  \tl_if_empty:nF{#1}{
    \str_if_eq:eeT {
      \tl_range:nnn{#1}{1}{10}~
    }{\tl_to_str:n{\long}}{\long}
  }
}
\cs_generate_variant:Nn \_@@_prefix_long:n {e}

\cs_new:Nn \_@@_params:n {
  \tl_if_empty:nF{#1}{
    \exp_args:NNe \str_if_eq:VnTF \c_hash_str {\tl_head:n{#1}}{
      ####
    }{
      \tl_head:n{#1}
    }
    \_@@_params:e {\tl_tail:n{#1}}
  }
}
\cs_generate_variant:Nn \_@@_params:n {e}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Persistence}
%    \begin{macrocode}
%<@@=stex_persist>
%    \end{macrocode}
%
% \begin{macro}{\stex_persist:n,\stex_persist:o,\stex_persist:x}
%    \begin{macrocode}
\stex_get_env:Nn\_@@_env_str{STEX_USESMS}
\str_if_empty:NF\_@@_env_str{
  \exp_args:No \str_if_eq:nnF \_@@_env_str{false}{
    \bool_set_true:N \c_stex_persist_mode_bool
  }
}
\stex_get_env:Nn\_@@_env_str{STEX_WRITESMS}
\str_if_empty:NF\_@@_env_str{
  \exp_args:No \str_if_eq:nnF \_@@_env_str{false}{
    \stex_html_backend:F {
      \bool_set_true:N \c_stex_persist_write_mode_bool
      \bool_set_false:N \c_stex_persist_mode_bool
    }
  }
}
\cs_undefine:N \_@@_env_str


\bool_if:NTF \c_stex_persist_write_mode_bool {
  \iow_new:N \c_@@_iow
  \iow_open:Nn \c_@@_iow{\jobname.sms}
  \AtEndDocument{
    \iow_close:N \c_@@_iow
  }
  \cs_set_protected:Nn \stex_persist:n {
    \tl_set:Nn \l_tmpa_tl { #1 }
    %\stex_debug:nn{sms}{Exporting~\l_tmpa_tl}
    \regex_replace_all:nnN { \cP\# } { \cO\# } \l_tmpa_tl
    \regex_replace_all:nnN { \cS\  } { \cO\~ } \l_tmpa_tl
    \regex_replace_all:nnN { \cD_ } { \c{c_math_subscript_token} } \l_tmpa_tl
    %\regex_replace_all:nnN { \cO : } { \c{c_colon_str} } \l_tmpa_tl
    \exp_args:NNo \iow_now:Nn \c_@@_iow \l_tmpa_tl
  }
  \cs_generate_variant:Nn \stex_persist:n {x,o}
}{
  \cs_set:Npn \stex_persist:n #1 {}
  \cs_set:Npn \stex_persist:x #1 {}
  \cs_set:Npn \stex_persist:o #1 {}
}

\cs_set_protected:Nn \stex_read_persist: {
  \bool_if:NT \c_stex_persist_mode_bool {
    % TODO
      \input{\jobname.sms}
    % TODO
  }
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Files, Paths and URIs}
%    \begin{macrocode}
%<@@=stex_path>
%    \end{macrocode}
%
% \begin{macro}{\stex_file_set:Nn, \stex_file_set:No, \stex_file_set:Nx}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_file_set:Nn {
  \str_if_empty:nTF {#2} { \seq_clear:N #1 }{
    \exp_args:NNno \seq_set_split:Nnn #1 / { \tl_to_str:n{#2} }
  }
}
\cs_generate_variant:Nn \stex_file_set:Nn {No, Nx}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_file_resolve:Nn, \stex_file_resolve:No, \stex_file_resolve:Nx}
%    \begin{macrocode}
\sys_if_platform_windows:TF{
  \cs_new_protected:Npn \_@@_win_take:nnw #1#2#3 \_@@_: {
    \str_set:Nn \l_@@_win_drive {#1#2}
    \str_set:Nn \l_@@_str{#3}
  }
  \cs_new_protected:Nn \stex_file_resolve:Nn {
    \str_set:Nn \l_@@_str {#2}
    \str_clear:N \l_@@_win_drive
    \exp_args:NNo \str_replace_all:Nnn \l_@@_str \c_backslash_str /
    \exp_args:Nx \tl_if_eq:nnT {\str_item:Nn \l_@@_str 2} : {
      \exp_after:wN \_@@_win_take:w \l_@@_str \_@@_:
    }
    \stex_file_set:No #1 \l_@@_str
    \_@@_canonicalize:N #1
    \str_if_empty:NF \l_@@_win_drive {
      \seq_put_left:No #1 \l_@@_win_drive
    }
    %\stex_debug:nn{files}{Set~\tl_to_str:n{#1}~to~\stex_file_use:N #1}
  }
}{
  \cs_new_protected:Nn \stex_file_resolve:Nn {
    \str_set:Nn \l_@@_str {#2}
    \stex_file_set:No #1 \l_@@_str
    \_@@_canonicalize:N #1
   % \stex_debug:nn{files}{Set~\tl_to_str:n{#1}~to~\stex_file_use:N #1}
  }
}
\cs_generate_variant:Nn \stex_file_resolve:Nn {No, Nx}

\cs_new_protected:Nn \_@@_canonicalize:N {
  \seq_if_empty:NF #1 {
    \seq_pop:NN #1 \l_@@_str
    \seq_clear:N \l_@@_seq
    \str_if_empty:NTF \l_@@_str {
      \seq_map_function:NN #1 \_@@_dodots:n
      \seq_put_left:Nn \l_@@_seq {}
    }{
      \seq_push:No #1 \l_@@_str
      \seq_map_function:NN #1 \_@@_dodots:n
    }
    \seq_set_eq:NN #1 \l_@@_seq
  }
}

\cs_new_protected:Nn \_@@_dodots:n {
  \str_if_empty:nF{#1}{
    \str_if_eq:nnF {#1} {.} {
      \str_if_eq:nnTF {#1} {..} {
        \seq_if_empty:NF \l_@@_seq {
          \seq_pop_right:NN \l_@@_seq \l_@@_str
        }
      }{
        \seq_put_right:Nn \l_@@_seq {#1}
      }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\stex_file_absolute:N}
%    \begin{macrocode}

\sys_if_platform_windows:TF {
  \prg_new_conditional:Nnn \stex_file_absolute:N {p, T, F, TF} {
    \seq_if_empty:NTF \prg_return_false: {
      \tl_set:Nx \l_@@_maybewin_str {\seq_item:Nn #1 1}
      \exp_args:No \tl_if_empty:nTF \l_@@_maybewin \prg_return_true: {
        \exp_args:Nx \tl_if_eq:nnTF {\str_item:Nn \l_@@_maybewin 2} :
          \prg_return_true: \prg_return_false:
      }
    }
  }
}{
  \prg_new_conditional:Nnn \stex_file_absolute:N {p, T, F, TF} {
    \seq_if_empty:NTF \prg_return_false: {
      \exp_args:Nx \tl_if_empty:nTF {\seq_item:Nn #1 1}
        \prg_return_true: \prg_return_false:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_file_use:N}
%    \begin{macrocode}
\cs_new:Nn \stex_file_use:N {
  \seq_use:Nn #1 /
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[TF]{\stex_file_starts_with:N}
%    \begin{macrocode}
\prg_new_protected_conditional:Nnn \stex_file_starts_with:NN {T,F,TF} {
  \seq_set_eq:NN \l_@@_a_seq #1
  \seq_set_eq:NN \l_@@_b_seq #2
  \tl_clear:N \l_@@_return_tl
  \bool_while_do:nn{
    \bool_not_p:n{
      \bool_lazy_any_p:n{
        {\seq_if_empty_p:N \l_@@_a_seq}
        {\seq_if_empty_p:N \l_@@_b_seq}
        {\bool_not_p:n{\tl_if_empty_p:N \l_@@_return_tl}}
      }
    }
  }{
    \seq_pop_left:NN \l_@@_a_seq \l_@@_a_tl
    \seq_pop_left:NN \l_@@_b_seq \l_@@_b_tl
    \tl_if_eq:NNF \l_@@_a_seq \l_@@_b_seq {
      \tl_set:Nn \l_@@_return_tl {\prg_return_false:}
    }
  }
  \tl_if_empty:NTF \l_@@_return_tl {
    \seq_if_empty:NTF \l_@@_b_seq \prg_return_true: \prg_return_false:
  } \l_@@_return_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_file_split_off_ext:NN,\stex_file_split_off_lang:NN}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_file_split_off_ext:NN {
  \seq_set_eq:NN #1 #2
  \seq_pop_right:NN #1 \l_@@_str
  \seq_set_split:NnV \l_@@_seq . \l_@@_str
  \seq_pop_right:NN \l_@@_seq \l_@@_str
  \seq_put_right:Nx #1 {\seq_use:Nn \l_@@_seq .}
}
\cs_new_protected:Nn \stex_file_split_off_lang:NN {
  \seq_set_eq:NN #1 #2
  \seq_pop_right:NN #1 \l_@@_str
  \seq_set_split:NnV \l_@@_seq . \l_@@_str
  \seq_pop_right:NN \l_@@_seq \l_@@_str

  \seq_pop_right:NN \l_@@_seq \l_@@_str
  \exp_args:NNo \prop_if_in:NnF \c_stex_languages_prop \l_@@_str {
    \seq_put_right:No \l_@@_seq \l_@@_str
  }

  \seq_put_right:Nx #1 {\seq_use:Nn \l_@@_seq .}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_map_uri:Nnnnn}
%    \begin{macrocode}
\cs_set_protected:Nn \_@@_auth:n {
  \msg_error:nnx{stex}{error/misused-uri}{\tl_to_str:n{#1}}
}
\cs_set_eq:NN \_@@_path:n \_@@_auth:n
\cs_set_eq:NN \_@@_module:n \_@@_auth:n
\cs_set_eq:NN \_@@_name:n \_@@_auth:n

\cs_set_protected:Nn \stex_map_uri:Nnnnn{
  \stex_pseudogroup_with:nn{\_@@_auth:n\_@@_path:n\_@@_module:n\_@@_name:n}{
    \cs_set:Npn \_@@_auth:n ##1 {#2}
    \cs_set:Npn \_@@_path:n ##1 {#3}
    \cs_set:Npn \_@@_module:n ##1 {#4}
    \cs_set:Npn \_@@_name:n ##1 {#5}
    #1
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_uri_set:Nn, \stex_uri_set:No, \stex_uri_set:Nx}
%    \begin{macrocode}
\str_set:Nx\_@@_colonslash{\c_colon_str/}
\cs_new_protected:Nn \_@@_uri_set:NnN {
  \str_if_empty:nTF {#2} {
    \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{empty}
  }{
    \exp_args:NNNo \exp_args:NNno \seq_set_split:Nnn #1 \_@@_colonslash { \tl_to_str:n{#2} }
    \seq_pop_left:NN #1 \l_@@_auth_str
    \seq_if_empty:NTF #1 {
      \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{missing~authority}
    }{
      \exp_args:NNnx \seq_set_split:Nnn #1 ? {\exp_args:NNo \seq_use:Nn #1 \_@@_colonslash }
      \seq_pop_left:NN #1 \l_@@_path
      #3 \l_@@_path \l_@@_path
      \seq_if_empty:NTF #1 {
        \exp_args:NNo \_@@_uri_set:Nnxnn #1 \l_@@_auth_str 
          {\stex_file_use:N \l_@@_path} {} {}
      }{
        \seq_pop_left:NN #1 \l_@@_mod
        \seq_if_empty:NTF #1 {
          \exp_args:NNo \_@@_uri_set:Nnxon #1 \l_@@_auth_str 
            {\stex_file_use:N \l_@@_path} \l_@@_mod {}
        }{
          \seq_pop_left:NN #1 \l_@@_name
          \seq_if_empty:NTF #1 {
            \exp_args:NNo \_@@_uri_set:Nnxon #2 \l_@@_auth_str 
              {\stex_file_use:N \l_@@_path} \l_@@_mod \l_@@_name
          }{
            \msg_error:nnxx{stex}{error/invalid-uri}{\tl_to_str:n{#2}}{too~many~?s}
          }
        }
      }
    }
  }
  \stex_debug:nn{uris}{Set~\tl_to_str:n{#1}~to~\stex_uri_use:N #1}
}

\cs_new_protected:Nn \_@@_uri_set:Nnnnn{
  \tl_set:Nn #1 {
    \_@@_auth:n{ #2 }
    \_@@_path:n{ #3 }
    \_@@_module:n{ #4 }
    \_@@_name:n{ #5 }
  }
}
\cs_generate_variant:Nn\_@@_uri_set:Nnnnn {Nnxnn,Nnxon,Nnxoo}

\cs_new_protected:Nn \stex_uri_set:Nn {
  \_@@_uri_set:NnN #1 {#2} \stex_file_set:No
}
\cs_generate_variant:Nn \stex_uri_set:Nn {No, Nx}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_uri_resolve:Nn, \stex_uri_resolve:No, \stex_uri_resolve:Nx}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_uri_resolve:Nn {
  \_@@_uri_set:NnN #1 {#2} \stex_file_resolve:No
}
\cs_generate_variant:Nn \stex_uri_resolve:Nn {No, Nx}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[EXP]{\stex_uri_use:N}
%    \begin{macrocode}
\cs_new:Npn \_@@_uri_use:w \_@@_auth:n #1 \_@@_path:n #2 \_@@_module:n #3 \_@@_name:n #4 {
  #1\c_colon_str/ #2 \tl_if_empty:nF { #3 }{ ? #3 
    \tl_if_empty:nF { #4 }{ ? #4 } }
}
\cs_new:Nn \stex_uri_use:N {
  \exp_args:Ne \cs_if_eq:NNTF { \tl_head:N #1 } \_@@_auth:n {
    \exp_after:wN \_@@_uri_use:w #1
  }{
    \msg_error:nnnn{stex}{error/invalid-uri}{#1}{Not~a~URI}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_uri_from_repo_file:NNNn, \stex_uri_from_repo_file_nolang:NNNn}
%    \begin{macrocode}
\cs_new_protected:Npn \stex_uri_from_repo_file_nolang:NNNn {
  \_@@_from_repo_file:NNNNn \stex_file_split_off_lang:NN
}
\cs_new_protected:Npn \stex_uri_from_repo_file:NNNn {
  \_@@_from_repo_file:NNNNn \stex_file_split_off_ext:NN
}

\cs_new_protected:Nn \_@@_from_repo_file:NNNNn {
  #1 \l_@@_file #4
  \prop_if_exist:NTF #3 {
    \str_clear:N \l_@@_uri
    \prop_get:NnNF #3 {#5} \l_@@_uri {
      \prop_get:NnNF #3 {ns} \l_@@_uri {
        \_@@_uri_set:Nnxnn #2 {file} 
          {\stex_file_use:N \l_@@_file} {} {}
      }
    }
    \str_if_empty:NF \l_@@_uri {\_@@_relativize:N #2}
  }{
    \exp_args:NNx \_@@_uri_set:Nnxnn #2 {\tl_to_str:n{file}} 
      {\stex_file_use:N \l_@@_file} {} {}
  }
}

\cs_new_protected:Nn \_@@_relativize:N {
  \seq_set_eq:NN \l_@@_seq \l_@@_file 
  \seq_map_inline:Nn \c_stex_mathhub_file { % mathhub path
    \seq_pop_left:NN \l_@@_seq \l_@@_tl
  }
  \stex_file_set:Nx \l_@@_path {\prop_item:Nn \l_stex_current_repository_prop {id} }
  \seq_map_inline:Nn \l_@@_path { % id
    \seq_pop_left:NN \l_@@_seq \l_@@_tl
  }
  \seq_pop_left:NN \l_@@_seq \l_@@_tl % source

  \stex_uri_set:Nx #1 { \l_@@_uri / \stex_file_use:N \l_@@_seq }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_uri_from_current_file:Nn, \stex_uri_from_current_file_nolang:Nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_uri_from_current_file:Nn {
  \stex_uri_from_repo_file:NNNn #1 \l_stex_current_repository_prop
    \g_stex_current_file {#2}
}
\cs_new_protected:Nn \stex_uri_from_current_file_nolang:Nn {
  \stex_uri_from_repo_file_nolang:NNNn #1 \l_stex_current_repository_prop
    \g_stex_current_file {#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_uri_add_module:NNn, \stex_uri_add_module:NNo}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_uri_add_module:NNn {
  \exp_args:Ne \cs_if_eq:NNTF { \tl_head:N #2 } \_@@_auth:n {
    \stex_pseudogroup_with:nn
      {\_@@_auth:n\_@@_path:n\_@@_module:n\_@@_name:n}
      {
        \cs_set:Npn \_@@_module:n ##1 {
          \tl_if_empty:nTF{##1}{
            \exp_not:N \_@@_module:n {#3}
          }{
            \msg_error:nnn{stex}{error/invalid-dpath}{#2}
          }
        }
        \cs_set:Npn \_@@_name:n ##1 {
          \tl_if_empty:nTF{##1}{
            \exp_not:N \_@@_name:n {}
          }{
            \msg_error:nnn{stex}{error/invalid-dpath}{#2}
          }
        }
        \tl_set:Nx #1 {#2}
      }
  }{
    \msg_error:nnnn{stex}{error/invalid-uri}{#2}{Not~a~URI}
  }
}
\cs_generate_variant:Nn \stex_uri_add_module:NNn {NNo}
%    \end{macrocode}
% \end{macro}
%
% We determine the PWD
%
% \begin{variable}{\c_stex_pwd_file,\c_stex_main_file}
%    \begin{macrocode}
\stex_get_env:Nnn\l_@@_str{PWD}{CD}
\stex_file_resolve:No \c_stex_pwd_file \l_@@_str
\seq_set_eq:NN \c_stex_main_file \c_stex_pwd_file
\seq_put_right:Nx \c_stex_main_file {\jobname\tl_to_str:n{.tex}}

%\stex_path_from_string:Nn\c_stex_pwd_seq\l_stex_kpsewhich_return_str
%\stex_path_to_string:NN\c_stex_pwd_seq\c_stex_pwd_str
\stex_debug:nn {files} {PWD:~\stex_file_use:N \c_stex_pwd_file}
%    \end{macrocode}
% \end{variable}
%
% \end{sfragment}
%
% \begin{sfragment}{File Hooks}
%
% keeps track of file changes:
%    \begin{macrocode}
\seq_gclear_new:N\g_@@_stack
\seq_gclear_new:N\g_stex_current_file
%    \end{macrocode}
%
% \begin{macro}{\stex_filestack_push:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_filestack_push:n {
  \exp_args:Nx \tl_if_eq:nnTF {\str_head:n{#1}} / {
    \str_set:Nn \l_@@_str {#1}
  }{
    \str_set:Nx \l_@@_str {\stex_file_use:N \c_stex_pwd_file / #1}
  }
  \stex_file_resolve:No \g_stex_current_file \l_@@_str
  \seq_gset_eq:NN \g_stex_current_file \g_stex_current_file
  \exp_args:NNx \seq_gpush:Nn \g_@@_stack {\stex_file_use:N \g_stex_current_file}
  \stex_get_document_uri:
  \stex_get_current_namespace:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_filestack_pop:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_filestack_pop: {
  \seq_if_empty:NF \g_@@_stack {
    \seq_gpop:NN \g_@@_stack \l_@@_str
  }
  \seq_if_empty:NTF \g_@@_stack {
    \seq_gset_eq:NN \g_stex_current_file \c_stex_main_file
  }{
    \seq_get:NN \g_@@_stack \l_@@_str
    \exp_args:NNo \stex_file_set:Nn \g_stex_current_file \l_@@_str
    \seq_gset_eq:NN \g_stex_current_file \g_stex_current_file
  }
  \stex_get_document_uri:
  \stex_get_current_namespace:
}
%    \end{macrocode}
% \end{macro}

% Hooks for the current file:
%
%    \begin{macrocode}
\AddToHook{file/before}{
  \tl_if_empty:NTF\CurrentFilePath{
    \exp_args:No \stex_filestack_push:n \CurrentFile
  }{
    \exp_args:Nx \stex_filestack_push:n { \CurrentFilePath / \CurrentFile }
  }
}
\AddToHook{file/after}{ \stex_filestack_pop: }
%    \end{macrocode}
%
% \end{sfragment}
%
% \end{sfragment}
%
% \begin{sfragment}{Math Archives}
%    \begin{macrocode}
%<@@=stex_mathhub>
%    \end{macrocode}
%
% \begin{variable}{\mathhub, \c_stex_mathhub_file}
% The path to the mathhub directory. If the \cs{mathhub}-macro is not set,
% we query |kpsewhich| for the |MATHHUB| system variable.
%    \begin{macrocode}
\str_if_empty:NTF\mathhub{
  \stex_get_env:Nn \l_@@_str {MATHHUB}
  \str_if_empty:NTF \l_@@_str {
    \sys_if_platform_windows:TF{
      \stex_get_env:Nn \l_@@_str {homedrive\c_percent_str\c_percent_str homepath}
    }{
      \stex_get_env:Nn \l_@@_str {HOME}
    }
    \ior_open:NnTF \g_tmpa_ior{\l_@@_str/.stex/mathhub.path}{
      \group_begin:
        \escapechar=-1\catcode`\\=12
        \ior_str_get:NN \g_tmpa_ior \l_@@_str
        \str_gset_eq:NN \l_@@_str \l_@@_str
      \group_end:
      \ior_close:N \g_tmpa_ior
      \stex_debug:nn{mathhub}{MathHub~directory~determined~from~home~directory}
    }{
      \str_clear:N \l_@@_str
    }
  }{
    \stex_debug:nn{mathhub}{MathHub~directory~determined~from~environment~variable}
  }
}{
  \str_set_eq:NN \l_@@_str \mathhub
}

\str_if_empty:NTF \l_@@_str {
  \msg_warning:nn{stex}{warning/nomathhub}
  \seq_clear:N \c_stex_mathhub_file
  \str_clearn:N \mathhub
}{
  \stex_file_resolve:No \c_stex_mathhub_file \l_@@_str
  \str_set:Nx \mathhub {\stex_file_use:N \c_stex_mathhub_file}
  \stex_debug:nn{mathhub}{MATHHUB:~\mathhub}
}
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_set_current_repository:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_set_current_repository:n {
  \stex_require_repository:n { #1 }
  \stex_debug:nn{mathhub}{switching~to~archive~#1}
  \prop_set_eq:Nc \l_stex_current_repository_prop { 
    c_stex_mathhub_#1_manifest_prop 
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_require_repository:n,\stex_require_repository:o}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_require_repository:n {
  \prop_if_exist:cF { c_stex_mathhub_#1_manifest_prop } {
    \seq_if_empty:NTF \c_stex_mathhub_file {
      \_stex_fatal_error:n{warning/nomathhub}
    }{
      \stex_debug:nn{mathhub}{Opening~archive:~#1}
      \_@@_do_manifest:n { #1 }
    }
  }
}
\cs_generate_variant:Nn \stex_require_repository:n {o}

\cs_new_protected:Nn \_@@_do_manifest:n {
  \_@@_find_manifest:n {#1}
  \str_if_empty:NT \l_@@_manifest_str {
    \_stex_fatal_error:nxx{error/norepository}
      {#1}{\stex_file_use:N \c_stex_mathhub_file}
  }
  \_@@_parse_manifest:n {#1}
}

\cs_new_protected:Nn \_@@_find_manifest:n {
  \str_clear:N \l_@@_manifest_str 
  \exp_args:NNnx \seq_set_split:Nnn \l_@@_seq /
    {\stex_file_use:N \c_stex_mathhub_file / #1}
  \bool_set_true:N \l_@@_bool
  \bool_while_do:Nn \l_@@_bool {
    \tl_if_eq:NNTF \l_@@_seq \c_stex_mathhub_file {
      \bool_set_false:N \l_@@_bool
    }{
      \_@@_check_manifest:
      \bool_if:NT \l_@@_bool {
        \seq_pop_right:NN \l_@@_seq \l_@@_tl
      }
    }
  }
}
\cs_generate_variant:Nn \_@@_find_manifest:n {x}

\cs_new_protected:Nn \_@@_check_manifest: {
  \_@@_check_manifest:n {MANIFEST.MF}
  \bool_if:NT \l_@@_bool {
    \_@@_check_manifest:n {META-INF/MANIFEST.MF}
    \bool_if:NT \l_@@_bool {
      \_@@_check_manifest:n {meta-inf/MANIFEST.MF}
    }
  }
}

\cs_new_protected:Nn \_@@_check_manifest:n {
  \stex_debug:nn{mathhub}{Checking~\stex_file_use:N \l_@@_seq / #1}
  \file_if_exist:nT {\stex_file_use:N \l_@@_seq / #1} {
    \bool_set_false:N \l_@@_bool
    \str_set:Nx \l_@@_manifest_str {\stex_file_use:N \l_@@_seq / #1}
  }
}

\ior_new:N \c_@@_manifest_ior
\cs_new_protected:Nn \_@@_parse_manifest:n {
  \ior_open:Nn \c_@@_manifest_ior \l_@@_manifest_str
  \prop_clear:N \l_@@_prop
  \ior_map_inline:Nn \c_@@_manifest_ior {
    \exp_args:NNo \seq_set_split:Nnn \l_@@_seq \c_colon_str {##1}
    \seq_pop_left:NNT \l_@@_seq \l_@@_key {
      \exp_args:NNo \str_set:Nn \l_@@_key \l_@@_key
      \str_set:Nx \l_@@_val {\seq_use:Nn \l_@@_seq :}
      \str_set:Nx \l_@@_val {\exp_args:No \tl_to_str:n \l_@@_val}
      \str_case:Nn \l_@@_key {
        {id}              {\prop_put:Nno \l_@@_prop { id }      \l_@@_val }
        {narration-base}  {\prop_put:Nno \l_@@_prop { narr }    \l_@@_val }
        {url-base}        {\prop_put:Nno \l_@@_prop { docurl }  \l_@@_val }
        {source-base}     {\prop_put:Nno \l_@@_prop { ns }      \l_@@_val }
        {ns}              {\prop_put:Nno \l_@@_prop { ns }      \l_@@_val }
      }
    }
  }
  \ior_close:N \c_@@_manifest_ior
  \prop_gset_eq:cN { c_stex_mathhub_#1_manifest_prop } \l_@@_prop
  \stex_debug:nn{mathhub}{Result: \prop_to_keyval:N \l_@@_prop}
  \stex_persist:x {
    \prop_set_from_keyval:cn { c_stex_mathhub_#1_manifest_prop }{
      \exp_after:wN \prop_to_keyval:N 
      \cs:w c_stex_mathhub_#1_manifest_prop \cs_end:
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% Current MathHub repository
% \begin{variable}{\c_stex_mathhub_main_manifest_prop, \l_stex_current_repository_prop}
%    \begin{macrocode}
\bool_if:NF \c_stex_persist_mode_bool {
  \seq_if_empty:NF \c_stex_mathhub_file {
    \stex_file_starts_with:NNTF \c_stex_pwd_file \c_stex_mathhub_file {
      \_@@_find_manifest:x { \stex_file_use:N \c_stex_pwd_file }
      \str_if_empty:NTF \l_@@_manifest_str {
        \stex_debug:nn{mathhub}{Not~currently~in~a~MathHub~repository}
      }{
        \_@@_parse_manifest:n { main }
        \prop_get:NnN \c_stex_mathhub_main_manifest_prop {id} 
          \l_@@_str
        \prop_set_eq:cN { c_stex_mathhub_\l_@@_str _manifest_prop }
          \c_stex_mathhub_main_manifest_prop
        \exp_args:No \stex_set_current_repository:n { \l_@@_str }
        \stex_debug:nn{mathhub}{Current~repository:~
          \prop_item:Nn \l_stex_current_repository_prop {id}
        }
      }
    }{
      \stex_debug:nn{mathhub}{Not~currently~in~the~MathHub~directory}
    }
  }
}
%    \end{macrocode}
% \end{variable}
%
% \end{sfragment}
%
% \begin{sfragment}{Documents}
%
% \begin{sfragment}{Title}
%
%    \begin{macrocode}
%<@@=stex_doc>
\tl_new:N \g_stex_document_title
%    \end{macrocode}
%
% \begin{macro}{\STEXtitle,\stex_document_title:n}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXtitle #1 {
  \tl_if_empty:NT \g_stex_document_title {
    \tl_gset:Nn \g_stex_document_title { #1 }
  }
}
\cs_new_protected:Nn \stex_document_title:n {
  \tl_if_empty:NT \g_stex_document_title {
    \tl_gset:Nn \g_stex_document_title { #1 }
    \stex_annotate_invisible:n{\noindent
      \stex_annotate:nnn{stex:doctitle}{}{ #1 }
    \par}
  }
}

\AtBeginDocument {
  \let \STEXtitle \stex_document_title:n
  \tl_if_empty:NF \g_stex_document_title {
    \stex_annotate_invisible:n{\noindent
      \stex_annotate:nnn{stex:doctitle}{}{ \g_stex_document_title }
    \par}
  }
  \let\_stex_maketitle:\maketitle
  \def\maketitle{
    \tl_if_empty:NF \@title {
      \exp_args:No \stex_document_title:n \@title
    }
    \_stex_maketitle:
  }
}

%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
%
% \begin{sfragment}{References}
%    \begin{macrocode}
%<@@=stex_refs>
%    \end{macrocode}
%
% References are stored in the file |\jobname.sref|, to enable
% cross-referencing external documents.
%    \begin{macrocode}
\iow_new:N \c_@@_iow
\AtBeginDocument{\iow_open:Nn \c_@@_iow {\jobname.sref}}
\AtEndDocument{\iow_close:N \c_@@_iow}
%    \end{macrocode}
%
% \begin{variable}{\l_stex_current_doc_uri}
%    \begin{macrocode}
\tl_new:N \l_stex_current_doc_uri
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_get_document_uri:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_get_document_uri: {
  \stex_uri_from_current_file:Nn \l_stex_current_doc_uri {narr}
  %\stex_debug:nn{sref}{Document~URI:~\stex_uri_use:N \l_stex_current_doc_uri}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_ref_new_doc_target:n,\sreflabel}
%    \begin{macrocode}
\seq_new:N \g_@@_files_seq
\int_new:N \l_@@_unnamed_counter_int

\cs_new_protected:Nn \_@@_add_doc_ref:nn {
  \seq_if_in:NnTF \g_@@_files_seq {#1} {
    \seq_if_in:cnF {g_@@_#1_seq}{#2}{
      \seq_gput_left:cn{g_@@_#1_seq}{#2}
    }
  }{
    \seq_gput_right:Nn \g_@@_files_seq {#1}
    \seq_new:c{g_@@_#1_seq}
    \seq_gput_left:cn{g_@@_#1_seq}{#2}
  }
}
\cs_generate_variant:Nn \_@@_add_doc_ref:nn {xo,xx}

\cs_new_protected:Npn \STEXInternalAuxAddDocRef #1 #2 {
  \_@@_add_doc_ref:xx{\tl_to_str:n{#1}}{\tl_to_str:n{#2}}
}
\AtEndDocument{
  \cs_set:Npn \STEXInternalAuxAddDocRef #1 #2 {}
}
\cs_new_protected:Npn \STEXInternalSrefRestoreTarget #1#2#3#4#5 {}

\cs_new_protected:Nn \stex_ref_new_doc_target:n {
  \str_if_empty:nTF {#1}{
    \int_gincr:N \l_@@_unnamed_counter_int
    \str_set:Nx \l_@@_str {REF\int_use:N \l_@@_unnamed_counter_int}
  }{
    \str_set:Nn \l_@@_str {#1}
  }
  \stex_uri_add_module:NNo \l_@@_uri \l_stex_current_doc_uri \l_@@_str
  \stex_debug:nn{sref}{New~document~target:~\stex_uri_use:N \l_@@_uri}
  \_@@_add_doc_ref:xo {\stex_uri_use:N \l_stex_current_doc_uri} \l_@@_str
  \stex_if_smsmode:F {
    \iow_now:Nx \c_@@_iow {
      \STEXInternalSrefRestoreTarget
      {\stex_uri_use:N \l_stex_current_doc_uri}
      {\l_@@_str}
      {\@currentcounter}
      {\@currentlabel}
      {
        \tl_if_exist:NT\@currentlabelname{
          \exp_args:No\exp_not:n\@currentlabelname
        }
      }
    }
    \exp_args:Nx\label{sref_ \stex_uri_use:N \l_@@_uri}
    \iow_now:Nx\@auxout{
      \STEXInternalAuxAddDocRef
      {\stex_uri_use:N \l_stex_current_doc_uri}
      {\l_@@_str}
    }
  }
}
\NewDocumentCommand \sreflabel {m} {\stex_ref_new_doc_target:n {#1}}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\sref,\extref}
% Optional arguments:
%    \begin{macrocode}
\stex_keys_define:nnnn{sref / 1}{}{
  % TODO get rid of this
  fallback  .code:n = {},
  pre       .code:n = {},
  post      .code:n = {}
}{archive file}
\stex_keys_define:nnnn{sref / 2}{}{}{archive file, title}
%    \end{macrocode}
% Determining the document URI:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_find_uri:n {
  \str_clear:N \l_@@_uri_str
  \stex_debug:nn{sref}{
    File:~\l_stex_key_file_str^^J
    Repo:\l_stex_key_archive_str
  }
  \str_if_empty:NTF \l_stex_key_file_str {
    \stex_debug:nn{sref}{Empty.~Checking~current~file~for~#1}
    \seq_if_exist:cT{g_@@_\stex_uri_use:N \l_stex_current_doc_uri _seq}{
      \exp_args:Nnx \_@@_find_uri_in_file:nnn{#1}
        {\stex_uri_use:N \l_stex_current_doc_uri}\seq_map_break:
    }
    \str_if_empty:NT \l_@@_uri_str {
      \seq_map_inline:Nn \g_@@_files_seq {
        \_@@_find_uri_in_file:nnn{#1}{##1}{\seq_map_break:n{\seq_map_break:}}
      }
    }
  }{
    \str_if_empty:NTF \l_stex_key_archive_str {
      \prop_if_exist:NTF \l_stex_current_repository_prop {
        \_@@_find_uri_in_prop_file:N \l_stex_current_repository_prop
      }{
        \stex_file_resolve:Nx \l_@@_file 
          { \stex_file_use:N \g_stex_current_file / .. / \l_stex_key_file_str }
        \str_set:Nx \l_@@_uri_str { file:/ \stex_file_use:N \l_@@_file }
      }
    }{
      \stex_require_repository:o \l_stex_key_archive_str
      \prop_set_eq:Nc \l_@@_prop { c_stex_mathhub_\l_stex_key_archive_str _manifest_prop }
      \_@@_find_uri_in_prop_file:N \l_@@_prop
    }
  }
}

\cs_new_protected:Nn \_@@_find_uri_in_prop_file:N {
  \str_set:Nx \l_@@_uri_str {
    \stex_file_use:N \c_stex_mathhub_file / 
    \prop_item:Nn #1 {id} /
      source / \l_stex_key_file_str
  }
  \stex_file_resolve:No \l_@@_file \l_@@_uri_str
  \stex_uri_from_repo_file:NNNn \l_@@_uri #1
    \l_@@_file {narr}
  \str_set:Nx \l_@@_uri_str {\stex_uri_use:N \l_@@_uri}
}

\cs_new_protected:Nn \_@@_find_uri_in_file:nnn {
  \stex_debug:nn{sref}{Checking~file~#2}
  \seq_map_inline:cn{g_@@_#2_seq}{
    \str_if_eq:nnT{#1}{##1}{
      \str_set:Nx \l_@@_uri_str {\stex_uri_use:N \l_stex_current_doc_uri}
      \stex_debug:nn{sref}{Found.}
      #3
    }
  }
}
%    \end{macrocode}
% Doing the actual referencing:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_do_autoref:n {
  \cs_if_exist:cTF{autoref}{
     \exp_args:Nx\autoref{sref_#1}
   }{
     \exp_args:Nx\ref{sref_#1}
   }
}

\cs_new_protected:Nn \_@@_do_sref:nn {
  \str_if_empty:NTF \l_@@_uri_str {
    \str_if_empty:NTF \l_stex_key_file_str {
      \stex_debug:nn{sref}{autoref~on~#1}
      \_@@_do_autoref:n{#1}
    }{
      \stex_debug:nn{sref}{srefin~on~#1}
      \stex_keys_set:nn { sref / 2 }{ #2 }
      \_@@_do_sref_in:n{#1}
    }
  }{
    \exp_args:NNo \seq_if_in:NnTF \g_@@_files_seq \l_@@_uri_str {
      \stex_debug:nn{sref}{Using~ref~file~\l_@@_uri_str}
      \exp_args:Nnx \seq_if_in:cnTF{g_stex_ref_\l_@@_uri_str _seq}{\detokenize{#1}}{
        \stex_debug:nn{sref}{Reference~found~in~ref~files;~autoref~on~\l_@@_uri_str?#1}
        \_@@_do_autoref:n{\l_@@_uri_str?#1}
      }{
        \str_if_empty:NTF \l_stex_key_file_str {
          \stex_debug:nn{sref}{in~empty;~autoref~on~\l_@@_uri_str?#1}
          \_@@_do_autoref:n{\l_@@_uri_str?#1}
        }{
          \stex_debug:nn{sref}{in~non-empty;~srefin~on~\l_@@_uri_str?#1}
          \stex_keys_set:nn { sref / 2 }{ #2 }
          \_@@_do_sref_in:n{#1}
        }
      }
    }{
      \stex_debug:nn{sref}{No~ref~file~found~for~\l_@@_uri_str}
      \str_if_empty:NTF \l_stex_key_file_str {
        \stex_debug:nn{sref}{in~empty;~autoref~on~\l_@@_uri_str?#1}
        \_@@_do_autoref:n{\l_@@_uri_str?#1}
      }{
        \stex_debug:nn{sref}{in~non-empty;~srefin~on~\l_@@_uri_str?#1}
        \stex_keys_set:nn { sref / 2 }{ #2 }
        \_@@_do_sref_in:n{#1}
      }
    }
  }
}

\cs_new_protected:Nn \_@@_do_sref_in:n {
  \stex_debug:nn{sref}{In: \l_stex_key_file_str^^JRepo:\l_stex_key_archive_str}
  \stex_debug:nn{sref}{URI: \l_@@_uri_str?#1}
  %\msg_warning:nnn{stex}{warning/smsmissing}{<filename>}
  \begingroup\catcode13=9\relax\catcode10=9\relax
    \str_if_empty:NTF \l_stex_key_archive_str {
      \prop_if_exist:NTF \l_stex_current_repository_prop {
        \str_set:Nx \l_@@_file_str {
          \stex_file_use:N \c_stex_mathhub_file /
          \prop_item:Nn \l_stex_current_repository_prop { id }
          / source / \l_stex_key_file_str .sref
        }
      }{
        \str_set:Nx \l_@@_file_str {
          \stex_file_use:N \g_stex_current_file / .. / \l_stex_key_file_str . sref
        }
      }
    }{
      \str_set:Nx \l_@@_file_str {
        \stex_file_use:N \c_stex_mathhub_file / \l_stex_key_archive_str
        / source / \l_stex_key_file_str . sref
      }
    }
    \stex_file_resolve:No \l_@@_file \l_@@_file_str
    \str_set:Nx \l_@@_file_str {\stex_file_use:N \l_@@_file }
    \stex_debug:nn{sref}{File: \l_@@_file_str }

    \exp_args:No \IfFileExists \l_@@_file_str {
      \tl_clear:N \l_@@_return_tl
      \str_set:Nn \l_@@_id_str {#1}
      \let\STEXInternalSrefRestoreTarget\_@@_restore_target:nnnnn
      \use:c{@ @ input}{\l_@@_file_str}
      \exp_args:No \tl_if_empty:nTF \l_@@_return_tl {
        \exp_args:Nnno \msg_warning:nnnn{stex}{warning/smslabelmissing}\l_@@_file_str{#1}
        \_@@_do_autoref:n{
          \str_if_empty:NF\l_@@_uri_str{\l_@@_uri_str?}#1
        }
      }{
        \l_@@_return_tl
      }
    }{
      \exp_args:Nnno \msg_warning:nnn{stex}{warning/smsmissing}\l_@@_file_str
      \_@@_do_autoref:n{
        \str_if_empty:NF\l_@@_uri_str{\l_@@_uri_str?}#1
      }
    }
  \endgroup
}

\cs_new_protected:Nn \_@@_restore_target:nnnnn {
  \str_if_empty:NTF \l_@@_uri_str {
    \exp_args:No \str_if_eq:nnT \l_@@_id_str {#2}{
      \tl_set:Nn \l_@@_return_tl {
        \use:c{#3autorefname}~#4\tl_if_empty:nF{#5}{~(#5)}~in~
        \tl_if_empty:NTF\l_stex_key_title_tl{
          ???
        }\l_stex_key_title_tl
      }
    }
  }{
    \stex_debug:nn{sref}{\l_@@_uri_str{}~ == ~ #1 ~ ?}
    \exp_args:No \str_if_eq:nnT \l_@@_uri_str {#1}{
      \stex_debug:nn{sref}{\l_@@_id_str~ == ~ #2 ~ ?}
      \exp_args:No \str_if_eq:nnT \l_@@_id_str {#2}{
        \stex_debug:nn{sref}{success!}
        \tl_set:Nn \l_@@_return_tl {
          \use:c{#3autorefname}~#4\tl_if_empty:nF{#5}{~(#5)}~in~
          \tl_if_empty:nTF\l_stex_key_title_tl{
            ???
          }\l_stex_key_title_tl
        }
        \endinput
      }
    }
  }
}
%    \end{macrocode}
% The actual macros:
%    \begin{macrocode}
\NewDocumentCommand \sref { O{} m O{}}{
  \stex_keys_set:nn { sref / 1 }{ #1 }
  \_@@_find_uri:n { #2 }
  \_@@_do_sref:nn{#2}{#3}
}
\NewDocumentCommand \extref { O{} m m}{
  \stex_keys_set:nn { sref / 1 }{ #1 }
  \_@@_find_uri:n { #2 }
  \stex_keys_set:nn { sref / 2 }{ #3 }
  \str_if_empty:NT \l_stex_key_file_str {
    \msg_error:nn{stex}{error/extrefmissing}
  }
  \_@@_do_sref_in:n{#2}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_ref_new_sym_target:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_ref_new_sym_target:n {
  % TODO
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\srefsym}
%    \begin{macrocode}
\NewDocumentCommand \srefsym { O{} m}{
  \stex_get_symbol:n { #2 }
  \_@@_sym_aux:nn{#1}{\l_stex_get_symbol_uri_str}
}

\cs_new_protected:Nn \_@@_sym_aux:nn {} % TODO
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\srefsymuri}
%    \begin{macrocode}
\cs_new_protected:Npn \srefsymuri #1 #2 { % TODO
  #2%\_@@_sym_aux:nn{linktext={#2}}{#1}
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \end{sfragment}
%
% \begin{sfragment}{SMS Mode}
%    \begin{macrocode}
%<@@=stex_smsmode>
%    \end{macrocode}
%
% Macros and environments allowed in sms mode:
%    \begin{macrocode}
\tl_new:N \g_@@_allowed_tl
\tl_new:N \g_@@_allowed_escape_tl
\seq_new:N \g_@@_allowedenvs_seq
%    \end{macrocode}
%
% \begin{macro}{\stex_sms_allow:N,\stex_sms_allow_escape:N,\stex_sms_allow_env:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_sms_allow:N {
  \tl_gput_right:Nn \g_@@_allowed_tl {#1}
}
\cs_new_protected:Nn \stex_sms_allow_escape:N {
  \tl_gput_right:Nn \g_@@_allowed_escape_tl {#1}
}
\cs_new_protected:Nn \stex_sms_allow_env:n {
  \exp_args:NNx \seq_gput_right:Nn \g_@@_allowedenvs_seq {\tl_to_str:n{#1}}
}
%    \end{macrocode}
% \end{macro}
% Some initial allowed macros:
%    \begin{macrocode}
\stex_sms_allow:N \makeatletter
\stex_sms_allow:N \makeatother
\stex_sms_allow:N \ExplSyntaxOn
\stex_sms_allow:N \ExplSyntaxOff
\stex_sms_allow:N \rustexBREAK
%    \end{macrocode}
%
% \begin{macro}[pTF]{\stex_if_smsmode:}
%    \begin{macrocode}
\bool_new:N \g_@@_bool
\bool_set_false:N \g_@@_bool
\prg_new_conditional:Nnn \stex_if_smsmode: { p, T, F, TF } {
  \bool_if:NTF \g_@@_bool \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_sms_allow_import:Nn, \stex_sms_allow_import_env:nn}
%    \begin{macrocode}
\tl_new:N \g_@@_allowed_import_tl
\seq_new:N \g_@@_allowed_import_env_seq
\cs_new_protected:Nn \stex_sms_allow_import:Nn {
  \tl_gput_right:Nn \g_@@_allowed_import_tl {#1}
  \tl_set:cn{\tl_to_str:n{#1}~-~smsmode} {#2}
}
\cs_new_protected:Nn \stex_sms_allow_import_env:nn {
  \exp_args:NNx \seq_gput_right:Nn \g_@@_allowed_import_env_seq {\tl_to_str{#1}}
  \tl_set:cn{\tl_to_str:n{#1}~-~env~-~smsmode} {#2}
}

\tl_new:N \g_stex_sms_import_code
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_file_in_smsmode:nn,\stex_file_in_smsmode:on}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_in_smsmode:n { \stex_suppress_html:n {
  \vbox_set:Nn \l_tmpa_box {
    \bool_set_true:N \g_@@_bool
    \bool_set_false:N \_stex_html_do_output_bool
    #1
  }
  \box_clear:N \l_tmpa_box
} }

\quark_new:N \q_@@_break

\cs_new_protected:Nn \_@@_start_smsmode:n {
  \everyeof{\q_@@_break\exp_not:N}
  \exp_after:wN \exp_after:wN \exp_after:wN
  \stex_smsmode_do:
  \cs:w @ @ input\cs_end: "#1" \relax
}

\cs_new_protected:Nn \stex_file_in_smsmode:nn {
  \seq_gclear:N \l_@@_importmodules_seq
  \seq_gclear:N \l_@@_sigmodules_seq
  \tl_clear:N \g_stex_sms_import_code
  \group_begin:
    #2
    \stex_filestack_push:n{#1}
    \_@@_in_smsmode:n {
      \let \_@@_do_aux_curr:N \_@@_do_aux_imports:N
      \tl_map_inline:Nn \g_@@_allowed_import_tl {
        \use:c{\tl_to_str:n{##1}~-~smsmode}
      }
      \seq_map_inline:Nn \g_@@_allowed_import_env_seq {
        \use:c{\tl_to_str:n{##1}~-~env~-~smsmode}
      }
      \_@@_start_smsmode:n{#1}
    }
    \g_stex_sms_import_code
    \_@@_in_smsmode:n {
      \let \_@@_do_aux_curr:N \_@@_do_aux_normal:N
      \_@@_start_smsmode:n{#1}
    }
    \stex_filestack_pop:
  \group_end:
}
\cs_generate_variant:Nn \stex_file_in_smsmode:nn {on}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_smsmode_do:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_smsmode_do: {
  \stex_if_smsmode:T {
    \_@@_do:w
  }
}

\cs_new:Nn \_@@_check_cs:NNn {
  \exp_after:wN\if\exp_after:wN\relax\exp_not:N#3
  \exp_after:wN#1\exp_after:wN#3\else
  \exp_after:wN#2\fi
}

\cs_new_protected:Npn \_@@_do:w #1 {
  \exp_args:Nx \tl_if_empty:nTF { \tl_tail:n{ #1 }}{
    \_@@_check_cs:NNn \_@@_do_aux:N \_@@_do:w { #1 }
  }{
    \_@@_do:w
  }
}

\cs_new_protected:Nn \_@@_do_aux:N {
  \cs_if_eq:NNF #1 \q_@@_break {
    \_@@_do_aux_curr:N #1
  }
}

\cs_new_protected:Nn \_@@_do_aux_imports:N {
 % \stex_debug:nn{sms}{Checking~\tl_to_str:n{#1}~in~import}
  \tl_if_in:NnTF \g_@@_allowed_import_tl {#1} {
    \stex_debug:nn{sms}{Executing~\tl_to_str:n{#1}~in~import}
    #1
  }{
    \cs_if_eq:NNTF \begin #1 {
      \_@@_check_begin:Nn \g_@@_allowed_import_env_seq
    }{
      \cs_if_eq:NNTF \end #1 {
        \_@@_check_end:Nn \g_@@_allowed_import_env_seq
      }{
        \_@@_do:w
      }
    }
  }
}

\cs_new_protected:Nn \_@@_do_aux_normal:N {
 % \stex_debug:nn{sms}{Checking~\tl_to_str:n{#1}~in~sms~mode}
  \tl_if_in:NnTF \g_@@_allowed_tl {#1} {
    \stex_debug:nn{sms}{Executing~\tl_to_str:n{#1}}
    #1\_@@_do:w
  }{
    \tl_if_in:NnTF \g_@@_allowed_escape_tl {#1} {
      \stex_debug:nn{sms}{Executing~escaped~\tl_to_str:n{#1}}
      #1
    }{
      \cs_if_eq:NNTF \begin #1 {
        \_@@_check_begin:Nn \g_@@_allowedenvs_seq
      }{
        \cs_if_eq:NNTF \end #1 {
          \_@@_check_end:Nn \g_@@_allowedenvs_seq
        }{
          \_@@_do:w
        }
      }
    }
  }
}

\cs_new_protected:Nn \_@@_check_begin:Nn {
 % \stex_debug:nn{sms}{Checking~environment~#2}
  \seq_if_in:NxTF #1 { \tl_to_str:n{#2} }{
    \stex_debug:nn{sms}{Environment~#2}
    \begin{#2}
  }{
    \_@@_do:w
  }
}
\cs_new_protected:Nn \_@@_check_end:Nn {
%  \stex_debug:nn{sms}{Checking~end~environment~#2}
  \seq_if_in:NxTF #1 { \tl_to_str:n{#2} }{
    \stex_debug:nn{sms}{End~Environment~#2}
    \end{#2}\_@@_do:w
  }{
    \str_if_eq:nnTF{#2}{document} \endinput \_@@_do:w
  }
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Modules}
%
% \begin{sfragment}{The smodule-environment}
%    \begin{macrocode}
%<@@=stex_modules>
%    \end{macrocode}
%
% \begin{variable}{\l_stex_current_module_str}
%  The current module:
%    \begin{macrocode}
\str_new:N \l_stex_current_module_str
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\stex_current_module_prop:}
%    \begin{macrocode}
\cs_new:Nn \stex_current_module_prop: {
  \exp_after:wN \exp_not:N \cs:w c_stex_module_\l_stex_current_module_str _prop \cs_end:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_stex_all_modules_seq}
%   Stores all modules currently in scope
%    \begin{macrocode}
\seq_new:N \l_stex_all_modules_seq
%    \end{macrocode}
% \end{variable}
%
%
% \begin{macro}{\stex_every_module:n}
%    \begin{macrocode}
%<@@=stex_module_setup>
\tl_set:Nn \g_stex_every_module_tl {
  \stex_metagroup_new:o \l_stex_current_module_str
}
\cs_new_protected:Nn \stex_every_module:n {
  \tl_gput_right:Nn \g_stex_every_module_tl { #1 }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_module_setup:n}
% Sets up a new module:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_get_uri_str:n {
  \str_clear:N \l_@@_ns_str
  \stex_map_uri:Nnnnn \l_stex_current_ns_uri {
    \str_set:Nx \l_@@_ns_str{##1\c_colon_str/}
  }{
    \seq_set_split:Nnn \l_@@_seq / {##1}
    \seq_pop_right:NN \l_@@_seq \l_@@_seg
    \exp_args:No \str_if_eq:nnF \l_@@_seg {#1} {
      \seq_put_right:No \l_@@_seq \l_@@_seg
    }
    \tl_put_right:Nx \l_@@_ns_str {\seq_use:Nn \l_@@_seq /}
  }{}{}
}

\cs_new_protected:Nn \_@@_setup_top_nosig:n {  
  \stex_if_module_exists:nTF{\l_@@_ns_str?#1}{
    \stex_debug:nn{modules}{(already exists)}
  }{
    \prop_clear:N \l_@@_prop
    \prop_put:Nnn \l_@@_prop {name} { #1 }
    \prop_put:Nno \l_@@_prop {ns} \l_@@_ns_str
    \tl_gclear:c{c_stex_module_ \l_@@_ns_str ? #1 _code}
    \tl_gclear:c{c_stex_module_ \l_@@_ns_str ? #1 _dependencies }
    \tl_gclear:c{c_stex_module_ \l_@@_ns_str ? #1 _declarations }
    \tl_gclear:c{c_stex_module_ \l_@@_ns_str ? #1 _notations }
    % \stex_debug:nn{module}{creating~c_stex_module_ \l_@@_ns_str ? #1 _prop}
    \prop_gset_eq:cN {c_stex_module_ \l_@@_ns_str ? #1 _prop}\l_@@_prop
  }
  \str_set:Nx \l_stex_current_module_str {\l_@@_ns_str?#1}
  \seq_put_right:No \l_stex_all_modules_seq \l_stex_current_module_str
}

\cs_new_protected:Nn \_@@_setup_top_sig:n {
  \stex_if_module_exists:nTF{\l_@@_ns_str?#1}{
    \stex_debug:nn{modules}{(already exists)}
  }{
    \stex_debug:nn{modules}{(needs loading)}
    \TODO
  }    
  \stex_if_smsmode:F { % WHY?
    \stex_activate_module:x {
      \l_stex_module_ns_str ? #1
    }
  }
  \str_set:Nx\l_stex_current_module_str{\l_@@_ns_str?#1}
}

\cs_new_protected:Nn \_@@_setup_top:n {
  \_@@_get_uri_str:n{#1}
  \stex_debug:nn{module}{Module~URI:~\l_@@_ns_str?#1}
  \str_if_empty:NTF \l_stex_key_sig_str
  \_@@_setup_top_nosig:n \_@@_setup_top_sig:n {#1}
  \g_stex_every_module_tl
  \_@@_load_meta:
}

\cs_new_protected:Nn \_@@_setup_nested:n {
  \str_set:Nx \l_@@_ns_str {\prop_item:cn{
    c_stex_module_ \l_stex_current_module_str _prop
  }{ns}}
  \exp_args:Nx \_@@_setup_top_nosig:n {\prop_item:cn{
    c_stex_module_ \l_stex_current_module_str _prop
  }{name} / #1}
  \stex_debug:nn{module}{Nested~Module~URI:~\l_stex_current_module_str}
  \seq_put_right:No \l_stex_all_modules_seq \l_stex_current_module_str
  \stex_metagroup_new:o \l_stex_current_module_str
}

\bool_new:N \l_stex_in_meta_bool
\bool_set_false:N \l_stex_in_meta_bool

\cs_new_protected:Nn \_@@_load_meta: {
  \tl_if_empty:NF \l_stex_metatheory_uri {
    \stex_execute_in_module:x{
      \stex_pseudogroup_with:nn{\l_stex_in_meta_bool}{
        \stex_activate_module:n {\stex_uri_use:N \l_stex_metatheory_uri }
      }
    }
  }
}

\cs_new_protected:Npn \stex_module_setup:n {
  \stex_if_in_module:TF \_@@_setup_nested:n \_@@_setup_top:n
}

%<@@=stex_modules>
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_close_module:}
%    \begin{macrocode}
\cs_new:Nn \stex_close_module: {
  \stex_if_smsmode:T { 
    \stex_persist:x{
      \prop_set_from_keyval:cn {c_stex_module_\l_stex_current_module_str _prop} {
        \exp_after:wN \prop_to_keyval:N \cs:w c_stex_module_\l_stex_current_module_str _prop\cs_end:
      }

      \tl_set:cn{c_stex_module_\l_stex_current_module_str _dependencies}{
        \use:c{c_stex_module_\l_stex_current_module_str _dependencies}
      }
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _declarations}{
        \use:c{c_stex_module_\l_stex_current_module_str _declarations}
      }
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _notations}{
        \exp_after:wN \exp_after:wN \exp_after:wN \exp_not:n
        \exp_after:wN \exp_after:wN \exp_after:wN
        { \cs:w c_stex_module_\l_stex_current_module_str _notations \cs_end: }
      }
      \tl_set:cn{c_stex_module_\l_stex_current_module_str _code}{
        \exp_after:wN \exp_after:wN \exp_after:wN \exp_not:n
        \exp_after:wN \exp_after:wN \exp_after:wN
        { \cs:w c_stex_module_\l_stex_current_module_str _code \cs_end: }
      }
    }
  }
  \stex_debug:nn{module}{
    Closing~module~\l_stex_current_module_str^^J
    Code:~\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _code\endcsname^^J
    Imports:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _dependencies\endcsname^^J
    Declarations:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _declarations\endcsname^^J
    Notations:\expandafter\meaning\csname c_stex_module_\l_stex_current_module_str _notations\endcsname^^J
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{variable}{\l_stex_metatheory_uri}
%    \begin{macrocode}
\tl_new:N \l_stex_metatheory_uri
%    \end{macrocode}
% \end{variable}
%
% \begin{macro}{\setmetatheory}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_set_metatheory:nn {
  %\stex_import_module_uri:nn { #1 } { #2 }
  %\stex_import_require_module:nnnn 
  %{ \l_stex_import_ns_str } { \l_stex_import_archive_str } 
  %{ \l_stex_import_path_str } { \l_stex_import_name_str }
  %\str_set:Nx \l_stex_metatheory_str { \l_stex_import_ns_str ? \l_stex_import_name_str }
  \TODO
}

\NewDocumentCommand \setmetatheory {O{} m}{
  \_@@_set_metatheory:nn { #1 }{ #2 }
  \stex_smsmode_do:
}
%    \end{macrocode}
% \end{macro}
%
% Keys and key handling:
%
%    \begin{macrocode}
\stex_keys_define:nnnn{smodule}{
  \str_clear:N \l_stex_key_sig_str
}{
  %meta          .str_set_x:N  = \l_stex_key_metatheory_str ,
  meta          .code:n       = {
    \str_if_empty:nTF {#1}{
      \tl_clear:N \l_stex_metatheory_uri
    }{
      \stex_uri_resolve:Nx \l_stex_metatheory_uri { #1 }
    }
  },
  ns            .code:n       = {
    \stex_uri_resolve:Nx \l_stex_current_ns_uri { #1 }
  } ,
  lang          .code:n       = {
    \stex_set_language:n { #1 }
  } ,
  sig           .str_set_x:N  = \l_stex_key_sig_str ,
  creators      .code:n       = {} , % todo ?
  contributors  .code:n       = {} , % todo ?
  srccite       .code:n       = {}   % todo ?
}{id, title, style, deprecate}
%    \end{macrocode}
%
% \begin{environment}{smodule}
%    \begin{macrocode}
\stex_new_stylable_env:nnnnnnn {module} {O{} m}{
  \stex_keys_set:nn { smodule }{ #1 }
  \_stex_do_deprecation:n{#2}
  \exp_args:Nx \stex_module_setup:n { \tl_to_str:n{ #2 } }

  \stex_if_do_html:T {
    \begin{stex_annotate_env} {stex:theory} {
      \l_stex_current_module_str
    }
    \stex_annotate_invisible:nnn{stex:header}{}{
      \stex_annotate:nnn{stex:language}{ \l_stex_current_language_str}{}
      \stex_annotate:nnn{stex:signature}{ \l_stex_key_sig_str }{}
      \tl_if_empty:NF \l_stex_metatheory_uri {
        \stex_annotate:nnn{stex:metatheory}{ \stex_uri_use:N \l_stex_metatheory_uri }
      }
      %\str_if_empty:NF \thisstyle {
      %  \stex_annotate:nnn{stex:type}{\thisstyle}{}
      %}
    }
  }
  \stex_if_smsmode:F {
    \str_set_eq:NN \thismoduleuri \l_stex_current_module_str
    \tl_set:Nn \thismodulename {#2}
    \stex_style_apply:
  }
  \stex_smsmode_do:
}{
  \stex_close_module:
  \stex_if_smsmode:F \stex_style_apply:
  \stex_if_do_html:T{ \end{stex_annotate_env} }
}{}{}{s}

\stex_sms_allow_env:n{smodule}
%    \end{macrocode}
% \end{environment}
%
%
% \begin{macro}[pTF]{\stex_if_in_module:}
% Are we currently in a module?
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_in_module: {p, T, F, TF} {
  \str_if_empty:NTF \l_stex_current_module_str
    \prg_return_false: \prg_return_true:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}[pTF]{\stex_if_module_exists:n}
% Does a module with this URI exist?
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_module_exists:n {p, T, F, TF} {
  \prop_if_exist:cTF { c_stex_module_#1_prop }
    \prg_return_true: \prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_do_up_to_module:n,\stex_do_up_to_module:x}
% Execute code in the current module (i.e. as if the \cs{begin}\Arg{smodule}
% was the current tex group)
%    \begin{macrocode}
\cs_new_protected:Nn \stex_do_up_to_module:n {
  \exp_args:No \stex_metagroup_do_in:nn \l_stex_current_module_str {#1}
}
\cs_generate_variant:Nn \stex_do_up_to_module:n {x}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_to_current_module:n,\stex_add_to_current_module:x}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_add_to_current_module:n {
  \tl_gput_right:cn {c_stex_module_\l_stex_current_module_str _code} { #1 }
}
\cs_generate_variant:Nn \stex_add_to_current_module:n {x}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_module_dependency:nnn, \stex_add_module_dependency:x}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_morphism:nnnn {
  \exp_not:N \_stex_morphism:nnnn
  {#1}{#2}{#3}{\exp_not:n{#4}}
  %\msg_error:nnn{stex}{error/misused-importmodule}{#1:#2}
}
\cs_new_protected:Nn \stex_add_module_dependency:nnnn {
  \tl_gput_left:cn {c_stex_module_\l_stex_current_module_str _dependencies} {
    \_stex_morphism:nnnn{#1}{#2}{#3}{#4}
  }
}
\cs_generate_variant:Nn \stex_add_module_dependency:nnnn {nonn,oonn}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_iterate_modules:nn,\stex_iterate_all_modules:nn}
%    \begin{macrocode}

% TODO refactor maybe

\cs_new_protected:Nn \stex_iterate_all_modules:nn {
  \_@@_iterate_setup:n{#2}
  \_@@_iterate_modules:nn{#2}{
    \clist_map_inline:nn {#1} {
      \exp_args:NNo\seq_if_in:NnF \l_@@_mod_seq {##1}{
        \exp_args:Nno \_stex_morphism:nnnn {}{##1}{}{}
        \_@@_iterate_module:n{##1}
      }
    }
  }
}

\cs_new_protected:Nn \stex_iterate_modules:nn {
  \_@@_iterate_setup:n{#2}
  \stex_pseudogroup_with:nn{\_stex_morphism:nnnn}{
    \cs_set:Npn \_stex_morphism:nnnn ##1 ##2 ##3 ##4 {
      \bool_if:NT \l_@@_mod_bool {
        %\stex_debug:nn{}{Checking~##2~<:~#1}
        \stex_str_if_ends_with:nnT{##2}{#1}{
          %\stex_debug:nn{}{true}
          \exp_args:No \_@@_cs:nnnn{\l_@@_prefix_str##1}{##2}{##3}{##4}
        }
        \tl_if_empty:nTF{##1}{
          \_@@_iterate_module:n{##2}
        }{
          \stex_pseudogroup:nn{
            \str_put_right:Nn \l_@@_prefix_str{##1/}
            \_@@_iterate_module:n{##2}
          }{
            \stex_pseudogroup_restore:N \l_@@_prefix_str
          }
        }
      }
    }
    \seq_map_inline:Nn \l_stex_all_modules_seq {
      \exp_args:NNo\seq_if_in:NnF \l_@@_mod_seq {##1}{
        \exp_args:Nno \_stex_morphism:nnnn {}{##1}{}{}
        \_@@_iterate_module:n{##1}
      }
    }
  }
  \l_@@_mod_tl
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_iterate_modules:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_iterate_modules:n {
  \_@@_iterate_modules:nn{#1}{
    \str_if_empty:NF \l_stex_current_module_str {
      \exp_args:Nno \_stex_morphism:nnnn {} \l_stex_current_module_str{top}{}
      \exp_args:No \_@@_iterate_module:n \l_stex_current_module_str
    }
    \bool_if:NT \l_@@_mod_bool {
      \seq_map_inline:Nn \l_stex_all_modules_seq {
        \exp_args:NNo\seq_if_in:NnF \l_@@_mod_seq {##1}{
          \exp_args:Nno \_stex_morphism:nnnn {}{##1}{}{}
          \_@@_iterate_module:n{##1}
        }
      }
    }
  }
}

\cs_new_protected:Nn \_@@_iterate_setup:n {
  \seq_clear:N \l_@@_mod_seq
  \bool_set_true:N \l_@@_mod_bool
  \tl_clear:N \l_@@_mod_tl
  \str_clear:N \l_@@_prefix_str
  \cs_set:Npn \stex_iterate_break: {\bool_set_false:N \l_@@_mod_bool}
  \cs_set:Npn \stex_iterate_break:n ##1 {
    \stex_iterate_break:
    \tl_set:Nn \l_@@_mod_tl {##1}
  }
  \cs_set:Npn \_@@_cs:nnnn ##1 ##2 ##3 ##4 { #1 }

}

\cs_new_protected:Nn \_@@_iterate_modules:nn {
  \_@@_iterate_setup:n {#1}
  \stex_pseudogroup_with:nn{\_stex_morphism:nnn}{
    \cs_set:Npn \_stex_morphism:nnnn ##1 ##2 ##3 ##4 {
      \bool_if:NT \l_@@_mod_bool {
        \exp_args:No \_@@_cs:nnnn{\l_@@_prefix_str##1}{##2}{##3}{##4}
        \tl_if_empty:nTF{##1}{
          \_@@_iterate_module:n{##2}
        }{
          \stex_pseudogroup:nn{
            \str_put_right:Nn \l_@@_prefix_str{##1/}
            \_@@_iterate_module:n{##2}
          }{
            \stex_pseudogroup_restore:N \l_@@_prefix_str
          }
        }
      }
    }
  #2
  }
  \l_@@_mod_tl
}

\cs_new_protected:Nn \_@@_iterate_module:n {
  \bool_if:NT \l_@@_mod_bool {
    \exp_args:NNo\seq_if_in:NnF \l_@@_mod_seq {\l_@@_prefix_str #1}{
      \seq_put_right:No \l_@@_mod_seq {\l_@@_prefix_str #1}
      \use:c{c_stex_module_#1_dependencies}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_add_module_decl:nnnnnnN}
% \begin{arguments}
%   \item \Arg{Macro name}
%   \item \Arg{Name}
%   \item \Arg{arity}
%   \item \{(\Arg{Arg num}\Arg{Arg str}\Arg{Arg name})$^\ast$\}
%   \item Definiens
%   \item type
%   \item Return
%   \item Command
% \end{arguments}
%    \begin{macrocode}
\cs_new:Nn \_stex_symbol:nnnnnnnN {
  \exp_not:N \_stex_symbol:nnnnnnnN
  {#1}{#2}{#3}{#4}{\exp_not:n{#5}}{\exp_not:n{#6}}{\exp_not:n{#7}}#8
}

\cs_new_protected:Nn \stex_add_module_decl:nnnnnnnN {
  \tl_gput_left:cn {c_stex_module_\l_stex_current_module_str _declarations} {
    \_stex_symbol:nnnnnnnN{#1}{#2}{#3}{#4}{#5}{#6}{#7}#8
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_iterate_decls:n}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_iterate_decls:n {
  \cs_set:Npn \_@@_sym_cs:nnnnnnnnN 
  ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 ##9 {
    #1
  }
  \stex_pseudogroup_with:nn{\_stex_symbol:nnnnnnnN}{
    \stex_iterate_modules:n{
      \cs_set:Npn \_stex_symbol:nnnnnnnN 
      ####1 ####2 ####3 ####4 ####5 ####6 ####7 ####8 {
        \bool_if:NT \l_@@_mod_bool {
          \_@@_sym_cs:nnnnnnnnN {##2}{####1}{####2}{####3}
          {####4}{####5}{####6}{####7}####8
        }
      }
      ##4
      \use:c{c_stex_module_##2_declarations}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_iterate_decls:nn,\stex_iterate_all_decls:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_iterate_all_decls:nn {
  \cs_set:Npn \_@@_sym_cs:nnnnnnnnN 
  ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 ##9 {
    #2
  }
  \stex_pseudogroup_with:nn{\_stex_symbol:nnnnnnnN}{
    \stex_iterate_all_modules:nn{#1}{
      \cs_set:Npn \_stex_symbol:nnnnnnnN
      ####1 ####2 ####3 ####4 ####5 ####6 ####7 ####8 {
        \bool_if:NT \l_@@_mod_bool {
          \_@@_sym_cs:nnnnnnnnN {##2}{####1}{####2}{####3}
          {####4}{####5}{####6}{####7}####8
        }
      }
      ##4
      \use:c{c_stex_module_##2_declarations}
    }
  }
}

\cs_new_protected:Nn \stex_iterate_decls:nn {
  \cs_set:Npn \_@@_sym_cs:nnnnnnnnN 
  ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 ##9 {
    #2
  }
  \stex_pseudogroup_with:nn{\_stex_symbol:nnnnnnnN}{
    \stex_iterate_modules:nn{#1}{
      \cs_set:Npn \_stex_symbol:nnnnnnnN
      ####1 ####2 ####3 ####4 ####5 ####6 ####7 ####8 {
        \bool_if:NT \l_@@_mod_bool {
          \_@@_sym_cs:nnnnnnnnN {##2}{####1}{####2}{####3}
          {####4}{####5}{####6}{####7}####8
        }
      }
      ##4
      \use:c{c_stex_module_##2_declarations}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_add_module_notation:nnnnn, \stex_add_module_notation:eoexo}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_notation:nnnnn {
  \exp_not:N \_stex_notation:nnnnn
  {#1}{#2}{#3}{\exp_not:n{#4}}{\exp_not:n{#5}}
}
\cs_new_protected:Nn \stex_add_module_notation:nnnnn {
  \tl_gput_right:cn {c_stex_module_\l_stex_current_module_str _notations} {
    \_stex_notation:nnnnn{#1}{#2}{#3}{#4}{#5}
  }
}
\cs_generate_variant:Nn \stex_add_module_notation:nnnnn {eoexo}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_iterate_all_notations:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_iterate_all_notations:nn {
  \stex_pseudogroup_with:nn{\_stex_notation:nnnnn}{
    \cs_set:Npn \_stex_notation:nnnnn ##1 ##2 ##3 ##4 ##5 {
      #2
    }
    \stex_iterate_all_modules:nn{#1}{
      \use:c{c_stex_module_##2_notations}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_execute_in_module:n,\stex_execute_in_module:x}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_execute_in_module:n { \stex_if_in_module:TF {
  \stex_add_to_current_module:n { #1 }
  \stex_do_up_to_module:n { #1 }
}{ #1 }}
\cs_generate_variant:Nn \stex_execute_in_module:n {x}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXexport}
%    \begin{macrocode}
\NewDocumentCommand \STEXexport {} {
  \ExplSyntaxOn
  \_@@_export:n
}
\cs_new_protected:Nn \_@@_export:n {
  \ignorespacesandpars#1\ExplSyntaxOff
  \stex_add_to_current_module:n { \ignorespacesandpars#1}
  \stex_smsmode_do:
}
%    \end{macrocode}
% Only allowed in modules, and allowed (escaped) in sms mode:
%    \begin{macrocode}
\stex_deactivate_macro:Nn \STEXexport {module~environments}
\stex_sms_allow_escape:N \STEXexport
\stex_every_module:n {\stex_reactivate_macro:N \STEXexport}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_current_namespace:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_get_current_namespace: {
  \stex_uri_from_current_file_nolang:Nn \l_stex_current_ns_uri {source-base}
  %\stex_debug:nn{modules}{Namespace~URI:~\stex_uri_use:N \l_stex_current_ns_uri}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{environment}{mmtinterface}
%    \begin{macrocode}
\NewDocumentEnvironment { mmtinterface } { O{} m m } {
  \TODO
}{}
%    \end{macrocode}
% \end{environment}
%
% \begin{macro}{\stex_activate_module:n,\stex_activate_module:o,\stex_activate_module:x}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_activate_module:n {
  \seq_if_in:NnF \l_stex_all_modules_seq { #1 } {
    \stex_debug:nn{modules}{Activating~module~#1}
    \seq_put_right:Nn \l_stex_all_modules_seq { #1 }
    \use:c{ c_stex_module_#1_code }
    % \TODO % morphisms
  }
}
\cs_generate_variant:Nn \stex_activate_module:n {o,x}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Structural Features}
%    \begin{macrocode}
%<@@=stex_features>
%    \end{macrocode}
%
% \begin{environment}{structural_feature_module}
%    \begin{macrocode}
\newenvironment{structural_feature_module}[3]{
  \stex_module_setup:n {#1}
  \stex_if_do_html:T {
    \begin{stex_annotate_env} {stex:feature:#2} {
      \l_stex_current_module_str
    }
  }
  #3
}{
  \tl_gset_eq:NN \g_stex_last_feature_str \l_stex_current_module_str
  \stex_close_module:
  \stex_if_do_html:T{
    \end{stex_annotate_env}
  }
}
%    \end{macrocode}
% \end{environment}
%
% \end{sfragment}
%
% \end{sfragment}
%
%
% \begin{sfragment}{Inheritance}
%
% \begin{sfragment}{\cs{importmodule}/\cs{usemodule}}
%    \begin{macrocode}
%<@@=stex_importmodule>
%    \end{macrocode}
%
% \begin{macro}{\stex_import_module_uri:nn}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_import_module_uri:nn {
  \stex_debug:nn{importmodule}{URI:~>#1<~>#2<}
  \exp_args:NNnx \seq_set_split:Nnn \_@@_seq ? { \tl_to_str:n{ #2 } }
  \seq_pop_right:NN \_@@_seq \l_stex_import_name_str
  \str_set:Nx \l_stex_import_path_str { \seq_use:Nn \_@@_seq ? }
  \tl_if_empty:nTF { #1 } {
    \stex_debug:nn{importmodule}{No~archive}
    \prop_if_exist:NTF \l_stex_current_repository_prop {
      \stex_debug:nn{importmodule}{Picking~current~archive}
      \str_set:Nx \l_stex_import_archive_str {
        \prop_item:Nn \l_stex_current_repository_prop { id }
      }
    }{
      \str_clear:N \l_stex_import_archive_str
      \str_if_empty:NTF \l_stex_import_path_str {
        \stex_debug:nn{importmodule}{Empty~Path}
        \str_set:Nx \l_stex_import_path_str {
          \stex_file_use:N \g_stex_current_file / ..
        }
      }{
        \stex_debug:nn{importmodule}{Resolving~path~\l_stex_import_path_str~relative~to~\stex_file_use:N \g_stex_current_file}
        \stex_file_resolve:Nx \l_@@_seq { \stex_file_use:N \g_stex_current_file / .. / \l_stex_import_path_str}
        \str_set:Nx \l_stex_import_path_str {
          \stex_file_use:N \l_@@_seq
        }
        \stex_debug:nn{importmodule}{...yields~\l_stex_import_path_str}
      }
    }
  } {
    \stex_debug:nn{importmodule}{Archive~#1}
    \str_set:Nx \l_stex_import_archive_str { #1 }
    \stex_require_repository:o \l_stex_import_archive_str
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\stex_import_require_module:nnn}
%    \begin{macrocode}
\cs_new_protected:Npn \stex_import_require_module:nnn #1 {
  \stex_debug:nn{importmodule}{Requiring~>#1<}
  \tl_if_empty:nTF { #1 } {
    \str_clear:N \l_@@_archive_str
    \str_set:Nn \l_@@_uri {file:}
    \_@@_get_module:nnn {}
  }{
    \str_set:Nx \l_@@_archive_str {#1}
    \str_set:Nx \l_@@_uri { \prop_item:cn{ c_stex_mathhub_ #1 _manifest_prop}{ ns } }
    \str_set:Nx \l_@@_str { \stex_file_use:N \c_stex_mathhub_file / #1 / source }
    \exp_args:No \_@@_get_module:nnn \l_@@_str
  }
}
\cs_generate_variant:Nn \stex_import_require_module:nnn {ooo}

\cs_new_protected:Nn \_@@_get_module:nnn {
  \tl_if_empty:nF {#2}{
    \str_set:Nx \l_@@_uri {\l_@@_uri / #2}
  }
  \stex_debug:nn{importmodule}{~>#1<^^J>#2<^^J>#3<^^J>\l_@@_uri<}
  \stex_if_module_exists:nF {\l_@@_uri?#3} {
    \_@@_get_from_file:nnn{#1}{#2}{#3}
  }
  \str_set:Nx \l_stex_import_ns_str {\l_@@_uri?#3}
  \stex_activate_module:o \l_stex_import_ns_str
}

\cs_new_protected:Nn \_@@_get_from_file:nnn {
  \stex_file_resolve:Nx \l_@@_seq { \tl_if_empty:nF{ #1 }{ #1 / } #2 }
  \str_set:Nx \l_@@_str {\stex_file_use:N \l_@@_seq}
  \stex_debug:nn{imports}{Looking~for~\l_@@_uri?#3...}
  \_@@_check_file:nn{ .tex }{
    \_@@_check_file:nn{. \l_stex_current_language_str .tex}{
      \_@@_check_file:nn{.en.tex}{
        \_@@_check_file:nn{/#3.tex}{
          \_@@_check_file:nn{/#3.\l_stex_current_language_str .tex}{
            \_@@_check_file:nn{/#3.en.tex}{
              \msg_error:nnx{stex}{error/unknownmodule}{\l_@@_uri?#3}
            }
          }
        }
      }
    }
  }
  \_@@_load_file:n{#3}
}

\cs_new_protected:Nn \_@@_load_file:n {
  \stex_file_in_smsmode:on \l_@@_str {
    \seq_clear:N \l_stex_all_modules_seq
    \str_clear:N \l_stex_current_module_str
    \str_if_empty:NF \l_@@_archive_str {
      \stex_set_current_repository:n \l_@@_archive_str
    }
    \stex_debug:nn{modules}{Loading~\l_@@_str}
  }
  \stex_if_module_exists:nF {\l_@@_uri?#1} {
    \msg_error:nnx{stex}{error/unknownmodule}{\l_@@_uri?#1}
  }
}

\cs_new_protected:Npn \_@@_check_file:nn #1 {
  \stex_debug:nn{imports}{Checking~\l_@@_str #1}
  \IfFileExists{ \l_@@_str #1 }{
    \stex_debug:nn{imports}{Success}
    \str_set:Nx \l_@@_str { \l_@@_str #1 }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\usemodule}
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnnn {usemodule} { O{} m } {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \stex_import_require_module:ooo
    \l_stex_import_archive_str
    \l_stex_import_path_str
    \l_stex_import_name_str
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn 
      {stex:usemodule} \l_stex_import_ns_str {}
  }
  \stex_if_smsmode:F{
    \group_begin:
    \tl_set_eq:NN \thismoduleuri \l_stex_import_ns_str
    \tl_set_eq:NN \thismodulename \l_stex_import_name_str
    \tl_clear:N \thisstyle
    \stex_style_apply:
    \group_end:
  }
}{}{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\importmodule}
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnnn{importmodule} { O{} m } {
  \_@@_import_module:nn {#1}{#2}
  \stex_smsmode_do:
}{}{}
\stex_deactivate_macro:Nn \importmodule {module~environments}

\cs_new_protected:Nn \_@@_import_module:nn {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \stex_import_require_module:ooo
    \l_stex_import_archive_str
    \l_stex_import_path_str
    \l_stex_import_name_str
  \stex_execute_in_module:x{ 
    \stex_activate_module:n{\l_stex_import_ns_str}
  }
  \stex_add_module_dependency:nonn
    {}{\l_stex_import_ns_str}{import}{}
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn 
      {stex:import} \l_stex_import_ns_str {}
  }
  \stex_if_smsmode:F{
    \group_begin:
    \tl_set_eq:NN \thismoduleuri \l_stex_import_ns_str
    \tl_set_eq:NN \thismodulename \l_stex_import_name_str
    \tl_clear:N \thisstyle
    \stex_style_apply:
    \group_end:
  }
}

\cs_new_protected:Nn \_@@_import_module_presms:nn {
  \stex_import_module_uri:nn { #1 }{ #2 }
  \tl_gput_right:Nx \g_stex_sms_import_code {
    \stex_import_require_module:nnn 
      {\l_stex_import_archive_str}
      {\l_stex_import_path_str}
      {\l_stex_import_name_str}
  }
}
\stex_sms_allow_escape:N \importmodule
\stex_every_module:n {\stex_reactivate_macro:N \importmodule}
\stex_sms_allow_import:Nn \importmodule {
  \stex_reactivate_macro:N \importmodule
  \let \_@@_import_module:nn \_@@_import_module_presms:nn
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\MMTinclude}
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnnn{MMTinclude} {m}{
  \stex_annotate_invisible:nnn{stex:import}{#1}{}
}{}{}
\stex_every_module:n {\stex_reactivate_macro:N \MMTinclude}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Theory Morphisms}
%
% \end{sfragment}
%
%
%
% \end{sfragment}
%
%
% \begin{sfragment}{Symbols}
%
% \begin{sfragment}{Declarations}
%    \begin{macrocode}
%<@@=stex_symdecl>
%    \end{macrocode}
% Some setup:
%    \begin{macrocode}
\cs_new_protected:Npn \STEXInternalSymbolAfterInvokationTL {}
\cs_new_protected:Npn \STEXInternalAssocArgMarkerI {}
\cs_new_protected:Npn \STEXInternalAssocArgMarkerII {}

\stex_get_env:Nn\_@@_env_str{STEX_CHECKTERMS}
\str_if_empty:NF\_@@_env_str{
  \exp_args:No \str_if_eq:nnF \_@@_env_str{false}{
    \bool_set_true:N \c_stex_check_terms_bool
  }
}
%    \end{macrocode}
%
% \begin{macro}[pTF]{\stex_if_check_terms:}
%    \begin{macrocode}
\prg_new_conditional:Nnn \stex_if_check_terms: {p, T, F, TF} {
  \bool_if:NTF \c_stex_check_terms_bool {
    \stex_html_backend:TF\prg_return_false:{
      \stex_if_smsmode:TF\prg_return_false:\prg_return_true:
    }
  }\prg_return_false:
}
%    \end{macrocode}
% \end{macro}
%
% |symdecl| arguments:
%    \begin{macrocode}
\stex_keys_define:nnnn{decl}{
  \str_clear:N \l_stex_key_name_str
  \str_clear:N \l_stex_key_args_str
  \tl_clear:N \l_stex_key_type_tl
  \tl_clear:N \l_stex_key_def_tl
  \clist_clear:N \l_stex_key_argnames_clist
  \str_clear:N \l_stex_key_args_str
  \str_clear:N \l_stex_key_role_str
  \str_clear:N \l_stex_key_reorder_str
  \str_clear:N \l_stex_key_assoc_str
  \str_clear:N \l_stex_key_intent_str
  \tl_clear:N \l_stex_key_return_tl
  \clist_clear:N \l_stex_key_argtypes_tl
}{
  name      .str_set:N  = \l_stex_key_name_str ,

  args      .str_set:N  = \l_stex_key_args_str ,
  reorder   .str_set:N  = \l_stex_key_reorder_str ,
  argnames  .clist_set:N  = \l_stex_key_argnames_clist ,
  assoc     .choices:nn   = {bin,binl,binr,pre,conj,pwconj}
    {\str_set:Nx \l_stex_key_assoc_str \l_keys_choice_tl},
  intent    .str_set_x:N  = \l_stex_key_intent_str ,
  return    .tl_set:N     = \l_stex_key_return_tl ,
  argtypes  .clist_set:N  = \l_stex_key_argtypes_tl ,

  type      .tl_set:N     = \l_stex_key_type_tl  ,
  def       .tl_set:N     = \l_stex_key_def_tl   ,
  role      .str_set:N     = \l_stex_key_role_str   ,

  align     .code:n       = {},
  gfc       .code:n       = {}
}{style,deprecate}
% \_stex_do_deprecation:n{#2}
%    \end{macrocode}
%
% \begin{macro}{\stex_decl_parse_arity:}
%    \begin{macrocode}
\int_new:N \l_stex_args_count
\int_new:N \l_stex_assoc_args_count
\cs_new_protected:Nn \stex_decl_parse_arity: {
  \int_zero:N \l_stex_args_count
  \int_zero:N \l_stex_assoc_args_count
  \str_map_inline:Nn \l_stex_key_args_str {
    \str_case:nnF ##1 {
      0 { \str_map_break: }
      1 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {1}
        \str_set:Nn \l_stex_key_args_str {i}
      } }
      2 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {2}
        \str_set:Nn \l_stex_key_args_str {ii}
      } }
      3 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {3}
        \str_set:Nn \l_stex_key_args_str {iii}
      } }
      4 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {4}
        \str_set:Nn \l_stex_key_args_str {iiii}
      } }
      5 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {5}
        \str_set:Nn \l_stex_key_args_str {iiiii}
      } }
      6 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {6}
        \str_set:Nn \l_stex_key_args_str {iiiiii}
      } }
      7 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {7}
        \str_set:Nn \l_stex_key_args_str {iiiiiii}
      } }
      8 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {8}
        \str_set:Nn \l_stex_key_args_str {iiiiiiii}
      } }
      9 { \str_map_break:n{
        \int_set:Nn \l_stex_args_count {9}
        \str_set:Nn \l_stex_key_args_str {iiiiiiiii}
      } }
      i {\int_incr:N \l_stex_args_count}
      b {\int_incr:N \l_stex_args_count}
      a {\int_incr:N \l_stex_args_count \int_incr:N \l_stex_assoc_args_count}
      B {\int_incr:N \l_stex_args_count \int_incr:N \l_stex_assoc_args_count}
    }{
      \msg_error:nnxx{stex}{error/wrongargs}{
        \l_stex_current_module_str ? \l_stex_key_name_str
      }{##1}
    }
  }
}

\cs_new_protected:Nn \_stex_symdecl_do_argnames: {
  \seq_clear:N \l_stex_argnames_seq
  \int_step_inline:nn \l_stex_args_count {
    \clist_if_empty:NTF \l_stex_key_argnames_clist {
      \exp_args:NNo \seq_put_right:Nn \l_stex_argnames_seq {\c_dollar_str##1}
    }{
      \clist_pop:NN \l_stex_key_argnames_clist \l_@@_tmp
      \exp_args:NNx \seq_put_right:Nn \l_stex_argnames_seq {
        \c_dollar_str\exp_args:No\tl_to_str:n\l_@@_tmp
      }
    }
  }
} 
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symdecl}
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnnn {symdecl} { s m O{}} {
  \stex_keys_set:nn{decl}{#3}
  \IfBooleanTF #1 {
    \str_clear:N \l_stex_macroname_str
  }{
    \str_set:Nx \l_stex_macroname_str { #2 }
  }
  \stex_symdecl_top:n{#2}

  \stex_if_smsmode:F{
    \group_begin:
    \tl_set:Nx \thisdecluri {\l_stex_current_module_str ? \l_stex_key_name_str}
    \tl_set_eq:NN \thisdeclname \l_stex_key_name_str
    \tl_clear:N \thisstyle
    \stex_style_apply:
    \group_end:
  }
  \stex_smsmode_do:
}{}{}
\stex_deactivate_macro:Nn \symdecl {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \symdecl}
\stex_sms_allow_escape:N \symdecl
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_symdecl_top:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_stex_symdecl_add_decl: {
  \exp_args:Nnx \use:nn {\stex_add_module_decl:nnnnnnnN}{
    {\l_stex_macroname_str}
    {\l_stex_key_name_str}
    {\int_use:N \l_stex_args_count}
    {\l_stex_get_symbol_args_tl}
    {\exp_args:No \exp_not:n \l_stex_key_def_tl}
    {\exp_args:No \exp_not:n \l_stex_key_type_tl}
    {\exp_args:No \exp_not:n \l_stex_key_return_tl}
    \stex_invoke_symbol:
  }
  \_stex_symdecl_macro:
}

\cs_new_protected:Nn \_stex_symdecl_check_terms: {
  \stex_if_check_terms:T{
    \vbox_set:Nn \l_tmpa_box {
      \group_begin:
        \stex_debug:nn{check_terms}{Checking~type...}
        {$\l_stex_key_type_tl$}
        \stex_debug:nn{check_terms}{Checking~definiens...}
        {$\l_stex_key_def_tl$}
      \group_end:
    }
  }
}
\cs_new_protected:Nn \_stex_symdecl_html: {
  \stex_if_do_html:T {
    \stex_annotate_invisible:nnn {stex:symdecl} {
      \l_stex_current_module_str ? \l_stex_key_name_str
    }{
      \stex_annotate_invisible:nnn{stex:args}{\l_stex_key_args_str}{}
      \str_if_empty:NF \l_stex_macroname_str {
        \stex_annotate_invisible:nnn{stex:macroname}{\l_stex_macroname_str}{}
      }
      \tl_if_empty:NF \l_stex_key_type_tl {
        \stex_annotate_invisible:nnn{stex:type}{}{$\l_stex_key_type_tl$}
      }
      \tl_if_empty:NF \l_stex_key_def_tl {
        \stex_annotate_invisible:nnn{stex:definiens}{}{$\l_stex_key_def_tl$}
      }
      \str_if_empty:NF \l_stex_key_assoc_str {
        \stex_annotate_invisible:nnn{stex:assoctype}{\l_stex_key_assoc_str}{}
      }
      \str_if_empty:NF \l_stex_key_reorder_str {
        \stex_annotate_invisible:nnn{stex:reorderargs}{\l_stex_key_reorder_str}{}
      }
    }
  }
}

\cs_new_protected:Nn \_stex_symdecl_macro: {
  \str_if_empty:NF \l_stex_macroname_str {
    \stex_execute_in_module:x {
      \protected \tl_set:cn {\l_stex_macroname_str}{
        \_stex_invoke_symbol:nnnnnnnN
          {\l_stex_current_module_str}
          {\l_stex_key_name_str}
          {\int_use:N \l_stex_args_count}
          {\l_stex_get_symbol_args_tl}
          {\exp_args:No \exp_not:n \l_stex_key_def_tl}
          {\exp_args:No \exp_not:n \l_stex_key_type_tl}
          {\exp_args:No \exp_not:n \l_stex_key_return_tl}
          \stex_invoke_symbol:
      } 
    }
  }
}

\cs_new_protected:Nn \stex_symdecl_top:n {
  \str_if_empty:NT \l_stex_key_name_str {
    \str_set:Nx \l_stex_key_name_str { #1 }
  }
  \stex_symdecl_do:
  \_stex_symdecl_check_terms:
  \_stex_symdecl_add_decl:
  \_stex_symdecl_html:
}
%    \end{macrocode}
%
% \end{macro}
%
%
% \begin{macro}{\stex_symdecl_do:}
% Requires the above keys and \cs{l_stex_macroname_str} to be
% set first
%    \begin{macrocode}
\cs_new_protected:Nn \stex_symdecl_do: {
  \_stex_do_deprecation:n \l_stex_key_name_str
  \stex_decl_parse_arity:
  \_stex_symdecl_do_argnames:
  \_stex_symdecl_do_args:
}

\cs_new_protected:Nn \_stex_symdecl_do_args: {
  \tl_clear:N \l_stex_get_symbol_args_tl
  \int_step_inline:nn \l_stex_args_count {
    \tl_put_right:Nn \l_stex_get_symbol_args_tl {##1}
    \tl_put_right:Nx \l_stex_get_symbol_args_tl {
      \str_item:Nn \l_stex_key_args_str {##1}
    }
    \tl_put_right:Nx \l_stex_get_symbol_args_tl {
      {\seq_item:Nn \l_stex_argnames_seq {##1}}
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\textsymdecl}
%    \begin{macrocode}
\stex_new_stylable_cmd:nnnnn {textsymdecl} {m O{} m} {
  \TODO
}{}{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_symbol:n}
%    \begin{macrocode}

\cs_new_protected:Nn \stex_get_symbol:n {
  \str_clear:N \l_stex_get_symbol_mod_str
  \str_clear:N \l_stex_get_symbol_name_str
  \cs_if_exist:cTF { #1 }{
    \cs_set_eq:Nc \l_@@_cs { #1 }
    % command name
    \exp_args:Nx \tl_if_empty:nTF { \cs_argument_spec:N \l_@@_cs }{
      % ...that takes no arguments
      \exp_args:Nx \cs_if_eq:NNTF {\tl_head:N \l_@@_cs}
        \_stex_invoke_symbol:nnnnnnnN
        \_@@_get_symbol_from_cs:
        {\_@@_get_symbol_from_string:n { #1 }}
    }{
      \_@@_get_symbol_from_string:n { #1 }
    }
  }{
    \_@@_get_symbol_from_string:n { #1 }
  }
  \str_if_empty:NT \l_stex_get_symbol_name_str {
    \msg_error:nnn{stex}{error/unknownsymbol}{#1}
  }
}

\int_new:N \l_stex_get_symbol_arity_int
\cs_new_protected:Nn \_@@_get_symbol_from_cs: {
  \stex_debug:nn{symbols}{Getting~from~cs...}
  \stex_pseudogroup_with:nn{\_stex_invoke_symbol:nnnnnnnN}{
    \cs_set:Npn \_stex_invoke_symbol:nnnnnnnN ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
      \str_set:Nn \l_stex_get_symbol_mod_str {##1}
      \str_set:Nn \l_stex_get_symbol_name_str {##2}
      \int_set:Nn \l_stex_get_symbol_arity_int {##3}
      \tl_set:Nn \l_stex_get_symbol_args_tl {##4}
      \tl_set:Nn \l_stex_get_symbol_def_tl {##5}
      \tl_set:Nn \l_stex_get_symbol_type_tl {##6}
      \tl_set:Nn \l_stex_get_symbol_return_tl {##7}
      \tl_set_eq:NN \l_stex_get_symbol_invoke_cs ##8
    }
    \l_@@_cs
  }
}

\cs_new_protected:Nn \_@@_get_symbol_from_string:n {
  \stex_debug:nn{symbols}{Getting~from~string~#1...}
  \seq_set_split:Nnn \l_@@_seq ? {#1}
  \seq_pop_right:NN \l_@@_seq \l_@@_name
  \seq_if_empty:NTF \l_@@_seq {
    \exp_args:No \_@@_get_from_one_string:n {#1}
  }{
    \exp_args:NNx \exp_args:Nno \_@@_get_symbol_from_modules:nn {
      \seq_use:Nn \l_@@_seq ?
    } \l_@@_name
  }
}

\cs_new_protected:Nn \_@@_get_symbol_from_modules:nn {
  \stex_debug:nn{symbols}{Getting~#2~in~#1...}
  \stex_iterate_decls:nn{#1}{
    %\stex_debug:nn{symbols}{>#2==##2<...}
    \bool_lazy_or:nnT
      {\str_if_eq_p:nn{#2}{##2}}
      {\str_if_eq_p:nn{#2}{##3}}{
        \stex_iterate_break:n{
          \str_set:Nn \l_stex_get_symbol_mod_str {##1}
          \str_set:Nn \l_stex_get_symbol_name_str {##3}
          \int_set:Nn \l_stex_get_symbol_arity_int {##4}
          \tl_set:Nn \l_stex_get_symbol_args_tl {##5}
          \tl_set:Nn \l_stex_get_symbol_def_tl {##6}
          \tl_set:Nn \l_stex_get_symbol_type_tl {##7}
          \tl_set:Nn \l_stex_get_symbol_return_tl {##8}
          \tl_set_eq:NN \l_stex_get_symbol_invoke_cs ##9
        }
    }
  }
}

\cs_new_protected:Nn \_@@_get_from_one_string:n {
  \stex_debug:nn{symbols}{Getting~#1~anywhere...}
  \stex_iterate_decls:n{
    %\stex_debug:nn{symbols}{>#1==##2~|~#1==##3<...}
    \bool_lazy_or:nnT
      {\str_if_eq_p:nn{#1}{##2}}
      {\str_if_eq_p:nn{#1}{##3}}{
        \stex_iterate_break:n{
          \str_set:Nn \l_stex_get_symbol_mod_str {##1}
          \str_set:Nn \l_stex_get_symbol_name_str {##3}
          \int_set:Nn \l_stex_get_symbol_arity_int {##4}
          \tl_set:Nn \l_stex_get_symbol_args_tl {##5}
          \tl_set:Nn \l_stex_get_symbol_def_tl {##6}
          \tl_set:Nn \l_stex_get_symbol_type_tl {##7}
          \tl_set:Nn \l_stex_get_symbol_return_tl {##8}
          \tl_set_eq:NN \l_stex_get_symbol_invoke_cs ##9
        }
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Notations}
%    \begin{macrocode}
%<@@=stex_notations>
%    \end{macrocode}
%
% |notation| arguments:
%    \begin{macrocode}
\stex_keys_define:nnnn{notation}{
  \str_clear:N \l_stex_key_variant_str
  \str_clear:N \l_stex_key_prec_str
  \str_clear:N \l_stex_key_op_tl
  \str_clear:N \l_stex_key_hints_str
}{
  variant    .str_set_x:N  = \l_stex_key_variant_str ,
  prec       .str_set_x:N  = \l_stex_key_prec_str ,
  op         .tl_set:N     = \l_stex_key_op_tl ,
  hints      .str_set_x:N  = \l_stex_key_hints_str ,
  unknown    .code:n       = {
    \str_set:Nx \l_stex_key_variant_str \l_keys_key_str
  }
}{style}
% \_stex_do_deprecation:n{#2}
%    \end{macrocode}
%
% \begin{macro}{\notation}
%    \begin{macrocode}
\quark_new:N \_stex_args_end:

\cs_new:Nn \_stex_notation_make_args: {
  \_stex_make_args_with:N \_@@_make_arg:nnnw
}
\cs_new:Nn \_stex_make_args_with:N {
  \exp_after:wN \_stex_make_args_i:Nw
  \exp_after:wN #1
  \l_stex_get_symbol_args_tl \_stex_args_end:
}

\cs_new:Npn \_stex_make_args_i:Nw #1 #2 \_stex_args_end: {
  \tl_if_empty:nF {#2}{
    #1 #2 \_stex_args_end:
  }
}
\cs_new:Npn \_@@_make_arg:nnnw #1 #2 #3 #4 \_stex_args_end:  {
  \str_case:nnF #2 {
    a {{
        a\c_math_subscript_token{#1,1},
        a\c_math_subscript_token{#1,2}
      }}
    B {{
        B\c_math_subscript_token{#1,1},
        B\c_math_subscript_token{#1,2}
      }}
  }{
    {{#2}\c_math_subscript_token{#1}}
  }
  \_stex_make_args_i:Nw \_@@_make_arg:nnnw #4 \_stex_args_end:
}

\cs_new_protected:Nn \_stex_notation_styledefs: {
  \str_set_eq:NN\thisnotationvariant\l_stex_key_variant_str
  \str_set:Nn \thisdeclname \l_stex_get_symbol_name_str
  \tl_set:Nx \thisdecluri {\l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str}
  \def\thisnotation{
    $
    \tl_set_eq:NN \stex_current_symbol_str\thisdecluri
    \exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
      \_stex_notation_make_args:
    }$
  }
}

\cs_new_protected:Nn \_stex_notation_set_default:{
  \stex_execute_in_module:x{
    \cs_set_eq:cc{l_stex_notation_
      \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str 
      _cs}{
      l_stex_notation_
        \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str
      _ \l_stex_key_variant_str _cs
    }
    \tl_if_empty:NF \l_stex_key_op_tl {
      \cs_set_eq:cc{l_stex_notation_
        \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str
        _op__cs}{
        l_stex_notation_
        \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str
        _op_
        \l_stex_key_variant_str _cs
      }
    }
  }
}

\stex_new_stylable_cmd:nnnnn {notation} { s m O{}} {
  \stex_keys_set:nn{notation}{#3}
  %\stex_get_symbol:n{#2}
  \stex_get_symbol_or_var:n{#2}
  \str_if_empty:NTF \l_stex_get_symbol_mod_str {
    \stex_notation_do:nn {
      \_stex_notation_check:
      \str_set_eq:NN \l_stex_key_name_str \l_stex_get_symbol_name_str
      \exp_args:No\_stex_vardecl_notation_macro:n{\l_stex_get_symbol_name_str}
  
      \group_begin:
      \tl_set_eq:NN \thisvarname \l_stex_get_symbol_name_str
      \tl_clear:N \thisstyle
      \str_set_eq:NN\thisnotationvariant\l_stex_key_variant_str
      \def\thisnotation{
        $\let\stex_current_symbol_str\thisvarname
          \def\comp{\_comp}\exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
          \_stex_notation_make_args:
        }$
      }
      \stex_style_apply:
      \group_end:
    }
  }{
    \stex_notation_top:nnn{
      \l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str
    }{
      \stex_if_smsmode:F{
        \group_begin:
        \_stex_notation_styledefs:
        \IfBooleanTF#1{
          \_stex_notation_set_default:
        }{}
        \stex_style_apply:
        \group_end:
      }
      \stex_smsmode_do:
    }
  }
}{}{}

\stex_deactivate_macro:Nn \notation {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \notation}
\stex_sms_allow_escape:N \notation
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_notation_top:nnn}
%    \begin{macrocode}

\cs_new_protected:Nn \_stex_notation_check: {
  \stex_if_check_terms:T{
    \vbox_set:Nn \l_tmpa_box {
      \group_begin:
      \str_set:Nn \stex_current_symbol_str {test}
      \tl_set:Nn \STEXInternalSymbolAfterInvokationTL {}
      \cs_set:Npn \comp ##1 {##1}
      \stex_debug:nn{check_terms}{Checking~notation...}
        ${
          \exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
            \_stex_notation_make_args:
          }
        }$
      \group_end:
    }
  }
}

\cs_new_protected:Nn \_stex_notation_add:n {
  \stex_add_module_notation:eoexo{#1}\l_stex_key_variant_str
    {\int_use:N \l_stex_args_count}{
    \stex_macro_body:N \l_stex_notation_macrocode_cs
  }\l_stex_key_op_tl
  \cs_set_eq:cN {l_stex_notation_
    #1 _
    \l_stex_key_variant_str _cs
  }\l_stex_notation_macrocode_cs
  \stex_execute_in_module:x {
    \exp_after:wN \stex_macro_definition:N 
    \cs:w 
      l_stex_notation_#1_
      \l_stex_key_variant_str _cs
    \cs_end:
    \exp_not:N\cs_if_exist:cF {l_stex_notation_#1__cs}{
      \cs_set_eq:cc{l_stex_notation_#1__cs}{
        l_stex_notation_#1_
        \l_stex_key_variant_str _cs
      }
    }
    \tl_if_empty:NF \l_stex_key_op_tl {
      \tl_set:cn {l_stex_notation_#1_op_
      \l_stex_key_variant_str _cs}{
        \exp_not:N\comp{\exp_args:No\exp_not:n\l_stex_key_op_tl}
      }
      \exp_not:N\cs_if_exist:cF {l_stex_notation_#1_op__cs}{
        \cs_set_eq:cc{l_stex_notation_#1_op__cs}{
          l_stex_notation_#1_op_
          \l_stex_key_variant_str _cs
        }
      }
    }
  }
}

\cs_new_protected:Npn \stex_notation_top:nnn #1 #2 {
  \stex_notation_do:nn {
    \_stex_notation_check:
    \_stex_notation_add:n{#1}
    \_@@_do_html:n{#1}
    #2
  }
}

\cs_new:Npn \_@@_make_arg_html:nnnw #1 #2 #3 #4 \_stex_args_end: {
  \str_case:nnF #2 {
    a {{
      \stex_annotate:nnn{stex:argmarker}{#1 a}{},
      \stex_annotate:nnn{stex:argmarker}{#1 b}{}
    }}
    B {{
      \stex_annotate:nnn{stex:argmarker}{#1 a}{},
      \stex_annotate:nnn{stex:argmarker}{#1 b}{}
    }}
  }{
    {
      \stex_annotate:nnn{stex:argmarker}{#1}{}
    }
  }
  \_stex_make_args_i:Nw \_@@_make_arg_html:nnnw #4 \_stex_args_end:
}

\cs_new_protected:Nn \_@@_do_html_inner:n {
  \stex_annotate_invisible:nnn { stex:notation }{#1}{
    \stex_annotate:nnn {stex:notationfragment}\l_stex_key_variant_str{}
    \stex_annotate:nnn {stex:precedence}\l_stex_key_prec_str{}
    \stex_annotate:nnn{stex:notationcomp}{}{$
      \tl_set:Nn \stex_current_symbol_str {#1}
      \exp_args:Nne \use:nn \l_stex_notation_macrocode_cs{
        \_stex_make_args_with:N \_@@_make_arg_html:nnnw
      }
      $
    }
    \tl_if_empty:NF \l_stex_key_op_tl {
      \stex_annotate:nnn{stex:notationopcomp}{}{
        $\l_stex_key_op_tl$
      }
    }
  }
}

\cs_new_protected:Nn \_@@_do_html:n {
  \stex_if_do_html:T {
    \_@@_do_html_inner:n
  }
}
%    \end{macrocode}
% \end{macro}
%
%
%
% \begin{macro}{\stex_notation_do:nn}
% requires the above keys, \cs{l_stex_get_symbol_arity_int}, and
% \cs{l_stex_get_symbol_args_tl}
%    \begin{macrocode}
\cs_new_protected:Npn \stex_notation_do:nn {
  \int_compare:nNnTF \l_stex_get_symbol_arity_int = 0
  \stex_notation_const_do:nn \stex_notation_fun_do:nn
}

\cs_new_protected:Nn \stex_notation_const_do:nn {
  \stex_debug:nn{notation}{Constant~notation~\exp_not:n{#2}}
  % precedences
  \seq_clear:N \l_@@_precs_seq
  \str_if_empty:NTF \l_stex_key_prec_str {
    \tl_set:No \l_@@_opprec_tl { \neginfprec }
  }{
    \str_if_eq:onTF \l_stex_key_prec_str {nobrackets}{
      \tl_set:No \l_@@_opprec_tl { \neginfprec }
    }{
      \tl_set_eq:NN \l_@@_opprec_tl \l_stex_key_prec_str
    }
  }
  %\let \stex_current_symbol_str \relax
  \exp_args:NNe
  \cs_set_nopar:Npn \l_stex_notation_macrocode_cs {
    %\STEXInternalExecuteReturnII{
      \STEXInternalTermMathOMSiii 
        { \l_stex_key_variant_str }
        { \l_@@_opprec_tl } 
        { \exp_not:n { #2 } }
        \STEXInternalSymbolAfterInvokationTL
    %}{\exp_args:No\exp_not:n\l_stex_get_symbol_return_tl}
  }
  \stex_debug:nn{notation}{Notation:~\meaning\l_stex_notation_macrocode_cs}
  #1
}

\int_new:N \l_@@_currarg_int
\cs_new_protected:Nn \stex_notation_fun_do:nn {
  %\stex_debug:nn{notation}{Function~notation~\tl_to_str:n{#2}}
  \seq_clear:N \l_@@_precs_seq

  \str_if_empty:NTF \l_stex_key_prec_str {
    \tl_set:Nn \l_@@_opprec_tl { 0 }
    \int_step_inline:nn \l_stex_get_symbol_arity_int {
      \seq_put_right:Nn \l_@@_precs_seq {0}
    }
  }{
    \str_if_eq:onTF \l_stex_key_prec_str {nobrackets}{
      \stex_debug:nn{notation}{No~brackets}
      \tl_set:No \l_@@_opprec_tl { \neginfprec }
      \int_step_inline:nn \l_stex_get_symbol_arity_int {
        \exp_args:NNo \seq_put_right:Nn \l_@@_precs_seq \infprec
      }
    }\_@@_parse_precs:
  }

  \_@@_oma_or_omb:n{#2}


  \tl_set_eq:NN \l_@@_rem_args \l_stex_get_symbol_args_tl
  %\int_zero:N \l_@@_currarg_int
  \seq_set_eq:NN \l_@@_rem_precs_seq \l_@@_precs_seq
  \tl_clear:N \l_@@_dummys_tl
  \tl_set:Nn \l_@@_after_tl{#1}

  \stex_debug:nn{notation}{Doing~notation^^J\l_stex_get_symbol_args_tl^^J
    \meaning\l_@@_precs_seq^^J\the\l_stex_get_symbol_arity_int
  }
  \_@@_args:
}

\cs_new:Npn \_@@_check_b:nnnw #1 #2 #3 #4 \_stex_args_end: {
  \str_case:nn #2 {
    b {\let\_@@_do_ab_next:n \_@@_do_omb:n}
    B {\let\_@@_do_ab_next:n \_@@_do_omb:n}
  }
  \_stex_make_args_i:Nw \_@@_check_b:nnnw #4 \_stex_args_end:
}

\cs_new_protected:Nn \_@@_oma_or_omb:n {
  \let\_@@_do_ab_next:n \_@@_do_oma:n
  \_stex_make_args_with:N \_@@_check_b:nnnw
  \_@@_do_ab_next:n{#1}
}

\cs_new_protected:Nn \_@@_finalize: {
  \exp_args:Nnx \use:nn {
    \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
    \cs_set_nopar:Npn \l_stex_get_symbol_arity_int
  }{{
    \exp_after:wN \exp_after:wN \exp_after:wN
    \exp_not:n \exp_after:wN \exp_after:wN \exp_after:wN 
    { \exp_after:wN \l_stex_notation_macrocode_cs \l_@@_dummys_tl}
  }}
  \stex_debug:nn{notation}{Notation:~\meaning\l_stex_notation_macrocode_cs}
  \l_@@_after_tl
}

\cs_new_protected:Npn \_@@_do_next_arg:nnnw #1 #2 #3 #4 \_stex_args_end: {
  \tl_set:Nn \l_@@_rem_args {#4}
  \str_if_eq:nnTF {#2}{a}{
    \_@@_assoc_arg:nnn{#1}{a}
  }{
    \str_if_eq:nnTF {#2}{B}{
      \_@@_assoc_arg:nnn{#1}{B}
    }{
      \_@@_simple_arg:nn{#1}{#2}
    }
  }
}

\cs_new_protected:Nn \_@@_args: {
  \tl_if_empty:NTF \l_@@_rem_args \_@@_finalize: {
    \exp_after:wN \_@@_do_next_arg:nnnw \l_@@_rem_args \_stex_args_end:
  }
}

\cs_new_protected:Nn \_@@_simple_arg:nn {
  \seq_pop_left:NN \l_@@_rem_precs_seq \l_@@_prec_str
  \tl_put_right:Nx \l_@@_dummys_tl {{
    \STEXInternalTermMathArgiii
      {#2#1}
      {\l_@@_prec_str}
      {#### #1}
  }}
  \_@@_args:
}

\cs_new:Npn \_@@_make_simple_arg:nnnw #1 #2 #3 #4 \_stex_args_end: {
  \str_case:nnF #2 {
    a {{}}
    B {{}}
  }{{
    \STEXInternalTermMathArgiii{#2#1}{
      \seq_item:Nn \l_@@_precs_seq #1
    }{######## #1}
  }}
  \_stex_make_args_i:Nw \_@@_make_simple_arg:nnnw #4 \_stex_args_end:
}

\cs_new_protected:Nn \_@@_assoc_arg:nnn {
  \cs_generate_from_arg_count:NNnn \l_tmpa_cs \cs_set:Npn
    \l_stex_get_symbol_arity_int {\exp_not:n{#3}}
  \exp_args:Nne \use:nn{\def\l_tmpa_cs##1 ##2}{{
    \exp_args:NNe \use:nn \l_tmpa_cs {\_stex_make_args_with:N  \_@@_make_simple_arg:nnnw}
  }}

  \seq_pop_left:NN \l_@@_rem_precs_seq \l_@@_prec_str
  \tl_put_right:Nx \l_@@_dummys_tl { {
    \STEXInternalTermMathAssocArgiiiii
      { #1 }
      { \l_@@_prec_str }
      { #### #1 }
      { \l_tmpa_cs \STEXInternalAssocArgMarkerI \STEXInternalAssocArgMarkerII }
      {#2}
  } }
  \_@@_args:
}

\cs_new_protected:Nn \_@@_do_omb:n {
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
  \cs_set:Npn \l_stex_get_symbol_arity_int } { {
    %\STEXInternalExecuteReturnII{
      \STEXInternalTermMathOMBiii
        { \l_stex_key_variant_str }
        { \l_@@_opprec_tl } 
        { \exp_not:n { #1  } }
      \STEXInternalSymbolAfterInvokationTL
    % }{\exp_args:No\exp_not:n\l_stex_get_symbol_return_tl}
  } }
}

\cs_new_protected:Nn \_@@_do_oma:n {
  \exp_args:Nne \use:nn
  {
  \cs_generate_from_arg_count:NNnn \l_stex_notation_macrocode_cs
  \cs_set:Npn \l_stex_get_symbol_arity_int } { {
    %\STEXInternalExecuteReturnII{
      \STEXInternalTermMathOMAiii
        { \l_stex_key_variant_str }
        { \l_@@_opprec_tl } 
        { \exp_not:n { #1 } }
        \STEXInternalSymbolAfterInvokationTL
    %  }{\exp_args:No\exp_not:n\l_stex_get_symbol_return_tl}
  } }
}

\cs_new_protected:Nn \_@@_parse_precs: {
  \stex_debug:nn{notation}{parsing~precedence~\l_stex_key_prec_str}
  \seq_set_split:NnV \l_@@_seq ; \l_stex_key_prec_str
  \seq_pop_left:NNTF \l_@@_seq \l_@@_str {
    \tl_set_eq:NN \l_@@_opprec_tl \l_@@_str
    \seq_pop_left:NNT \l_@@_seq \l_@@_str {
      \exp_args:NNo \seq_set_split:NnV \l_@@_seq 
        {\tl_to_str:n{x}} \l_@@_str
    }
  }{
    \tl_set:No \l_@@_opprec_tl { 0 }
  }
  \int_step_inline:nn \l_stex_get_symbol_arity_int {
    \seq_pop_left:NNTF \l_@@_seq \l_@@_str {
      \seq_put_right:No \l_@@_precs_seq \l_@@_str
    }{
      \seq_put_right:No \l_@@_precs_seq \l_@@_opprec_tl
    }
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symdef}
%    \begin{macrocode}
\stex_keys_define:nnnn{symdef}{}{}{decl,notation}

\cs_new_protected:Nn \_stex_symdef_styledefs: {
  \tl_set:Nx \thisdecluri {\l_stex_current_module_str ? \l_stex_key_name_str}
  \tl_set_eq:NN \thisdeclname \l_stex_key_name_str
  \tl_clear:N \thisstyle
  \str_set_eq:NN\thisnotationvariant\l_stex_key_variant_str
  \def\thisnotation{
    $\let\stex_current_symbol_str\thisdecluri
      \def\comp{\_comp}\exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
      \_stex_notation_make_args:
    }$
  }
}

\stex_new_stylable_cmd:nnnnn {symdef} { m O{}} {
  \stex_keys_set:nn{symdef}{#2}
  \str_set:Nx \l_stex_macroname_str { #1 }
  \stex_symdecl_top:n{#1}

  \int_set:Nn \l_stex_get_symbol_arity_int {\l_stex_args_count}
  \stex_debug:nn{symdef}{Doing~\l_stex_current_module_str ? \l_stex_key_name_str}
  \stex_notation_top:nnn{
    \l_stex_current_module_str ? \l_stex_key_name_str
  }{
    \stex_if_smsmode:F{
      \group_begin:
      \_stex_symdef_styledefs:
      \stex_style_apply:
      \group_end:
    }
    \stex_smsmode_do:
  }
}{}{}

\stex_deactivate_macro:Nn \symdef {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \symdef}
\stex_sms_allow_escape:N \symdef
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
% \begin{sfragment}{Variables}
%    \begin{macrocode}
%<@@=stex_vars>
%    \end{macrocode}
%
% \begin{macro}{\vardef}
%    \begin{macrocode}
\tl_new:N \l_stex_variables_seq
\cs_new_protected:Nn \_stex_variable:nnnnnnnN {}

\cs_new_protected:Nn \_stex_vardecl_add: {
  \tl_put_left:Nx \l_stex_variables_seq {
    \_stex_variable:nnnnnnnN
    {\l_stex_macroname_str}
    {\l_stex_key_name_str}
    {\int_use:N \l_stex_args_count}
    {\l_stex_get_symbol_args_tl}
    {\exp_args:No \exp_not:n \l_stex_key_def_tl}
    {\exp_args:No \exp_not:n \l_stex_key_type_tl}
    {\exp_args:No \exp_not:n \l_stex_key_return_tl}
    \stex_invoke_symbol:
  }
}
\cs_new_protected:Nn \_stex_vardecl_macro: {
  \tl_set:cx{\l_stex_macroname_str}{
    \_stex_invoke_variable:nnnnnnN
      {\l_stex_key_name_str}
      {\int_use:N \l_stex_args_count}
      {\l_stex_get_symbol_args_tl}
      {\exp_args:No \exp_not:n \l_stex_key_def_tl}
      {\exp_args:No \exp_not:n \l_stex_key_type_tl}
      {\exp_args:No \exp_not:n \l_stex_key_return_tl}
      \stex_invoke_symbol:
  }
}

\cs_new_protected:Nn \_stex_vardecl_html: {
  % TODO
}

\cs_new_protected:Nn \_stex_vardecl_notation_macro:n {
  \cs_set_eq:cN {l_stex_notation_
    \l_stex_key_name_str _
    \l_stex_key_variant_str _cs
  }\l_stex_notation_macrocode_cs
  \cs_if_exist:cF {l_stex_notation_\l_stex_key_name_str __cs}{
    \cs_set_eq:cc{l_stex_notation_\l_stex_key_name_str __cs}{
      l_stex_notation_\l_stex_key_name_str _
      \l_stex_key_variant_str _cs
    }
  }
  \tl_if_empty:NF \l_stex_key_op_tl {
    \tl_set:cx {l_stex_notation_\l_stex_key_name_str _op_
    \l_stex_key_variant_str _cs}{
      \exp_not:N\comp{\exp_args:No\exp_not:n\l_stex_key_op_tl}
    }
    \cs_if_exist:cF {l_stex_notation_#1_op__cs}{
      \cs_set_eq:cc{l_stex_notation_#1_op__cs}{
        l_stex_notation_\l_stex_key_name_str _op_
        \l_stex_key_variant_str _cs
      }
    }
  }
}

\stex_new_stylable_cmd:nnnnn {vardef} { m O{}} {
  \stex_keys_set:nn{symdef}{#2}
  \str_set:Nx \l_stex_macroname_str { #1 }
  \str_if_empty:NT \l_stex_key_name_str {
    \str_set:Nx \l_stex_key_name_str { #1 }
  }

  \stex_symdecl_do:
  \_stex_symdecl_check_terms:
  \_stex_vardecl_add:
  \_stex_vardecl_macro:
  \_stex_vardecl_html:

  \int_set:Nn \l_stex_get_symbol_arity_int {\l_stex_args_count}
  \stex_debug:nn{vardef}{Doing~\l_stex_key_name_str}
  \tl_set_eq:NN \l_stex_get_symbol_return_tl \l_stex_key_return_tl

  \stex_notation_do:nn {
    \_stex_notation_check:
    \_stex_vardecl_notation_macro:n{#1}

    \group_begin:
    \tl_set_eq:NN \thisvarname \l_stex_key_name_str
    \tl_clear:N \thisstyle
    \str_set_eq:NN\thisnotationvariant\l_stex_key_variant_str
    \def\thisnotation{
      $\let\stex_current_symbol_str\thisvarname
        \def\comp{\_comp}\exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
        \_stex_notation_make_args:
      }$
    }
    \stex_style_apply:
    \group_end:
  }
}{}{}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_get_symbol_or_var:n}
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_set_vars:nnnnnnN {
  \stex_debug:nn{symbols}{Variable~#1~found}
  \cs_set:Npn \_stex_variable:nnnnnnnN ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {}
  \str_clear:N \l_stex_get_symbol_mod_str
  \str_set:Nn \l_stex_get_symbol_name_str {#1}
  \int_set:Nn \l_stex_get_symbol_arity_int {#2}
  \tl_set:Nn \l_stex_get_symbol_args_tl {#3}
  \tl_set:Nn \l_stex_get_symbol_def_tl {#4}
  \tl_set:Nn \l_stex_get_symbol_type_tl {#5}
  \tl_set:Nn \l_stex_get_symbol_return_tl {#6}
  \tl_set_eq:NN \l_stex_get_symbol_invoke_cs #7
}

\cs_new_protected:Nn \stex_get_symbol_or_var:n {
  \str_clear:N \l_stex_get_symbol_name_str
  \stex_pseudogroup_with:nn{\_stex_variable:nnnnnnnN}{
    \cs_set:Npn \_stex_variable:nnnnnnnN ##1 ##2 ##3 ##4 ##5 ##6 ##7 ##8 {
      \str_if_eq:nnTF{#1}{##1}{
        \_@@_set_vars:nnnnnnN{##2}{##3}{##4}{##5}{##6}{##7}##8
      }{
        \str_if_eq:nnT{#1}{##2}{
          \_@@_set_vars:nnnnnnN{##2}{##3}{##4}{##5}{##6}{##7}##8
        }
      }
    }
    \l_stex_variables_seq
  }
  \str_if_empty:NT \l_stex_get_symbol_name_str {
    \stex_debug:nn{symbols}{No~variable~#1~found}
    \stex_get_symbol:n{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
%
% \begin{sfragment}{Sequences}
%    \begin{macrocode}
%<@@=stex_seqs>
%    \end{macrocode}
%
% \begin{macro}{\varseq}
%    \begin{macrocode}
\int_new:N \l_@@_seq_arity_int
\stex_new_stylable_cmd:nnnnn {varseq}{m O{} m m} {
  \stex_keys_set:nn{symdef}{#2}
  \str_set:Nx \l_stex_macroname_str { #1 }
  \str_if_empty:NT \l_stex_key_name_str {
    \str_set:Nx \l_stex_key_name_str { #1 }
  }
  \str_if_empty:NT \l_stex_key_args_str {
    \str_set:Nn \l_stex_key_args_str {1}
  }
  \clist_set:Nn \l_@@_index_clist { #3 }
  \clist_set:Nn \l_@@_range_clist { #4 }
  \int_set:Nn \l_@@_seq_arity_int {\clist_count:n{ #3 }}

  %\tl_set_eq:NN \l_@@_type_tl \l_stex_key_type_tl
  %\tl_set:Nx \l_stex_key_type_tl {{\l_@@_index_clist}{\exp_args:No \exp_not:n \l_@@_range_clist}}

  \stex_symdecl_do:
  \int_compare:nNnT \l_stex_args_count < \l_@@_seq_arity_int {
    \TODO Error
  }
  \exp_args:Nx \str_if_eq:nnF {\exp_args:Ne \tl_head:n {\tl_tail:N \l_stex_get_symbol_args_tl}}{i}{
    \TODO Error
  }
  \_@@_varseq_html:
  \_@@_check_terms:
  \_@@_add_varseq:
  \_@@_varseq_macro:

  \stex_debug:nn{vardef}{Doing~\l_stex_key_name_str}
  \tl_set_eq:NN \l_stex_get_symbol_return_tl \l_stex_key_return_tl

  \tl_set:Nn \l_@@_do_next: {
    \int_set:Nn \l_stex_get_symbol_arity_int {\l_stex_args_count}
    \stex_notation_do:nn {
      \_stex_notation_check:
      \_stex_vardecl_notation_macro:n{#1}
  
      \group_begin:
      \tl_set_eq:NN \thisvarname \l_stex_key_name_str
      \tl_clear:N \thisstyle
      \str_set_eq:NN\thisnotationvariant\l_stex_key_variant_str
      \def\thisnotation{
        $\let\stex_current_symbol_str\thisvarname
          \def\comp{\_comp}\exp_args:Nne \use:nn{\l_stex_notation_macrocode_cs}{
          \_@@_make_args:
        }$
      }
      \stex_style_apply:
      \group_end:
    }
  }

  \int_compare:nNnTF \l_stex_args_count > \l_@@_seq_arity_int {
    \int_set:Nn \l_stex_get_symbol_arity_int \l_@@_seq_arity_int
    \str_set_eq:NN \l_@@_name_str \l_stex_key_name_str
    \exp_args:NNo \str_set:Nn \l_stex_key_name_str {\l_stex_key_name_str!}
    \tl_set_eq:NN \l_@@_args_tl \l_stex_get_symbol_args_tl
    \tl_set:Nx \l_stex_get_symbol_args_tl {
      \int_step_function:nN \l_@@_seq_arity_int \_@@_make_argls:n
    }
    \stex_notation_do:nn {
      \_stex_vardecl_notation_macro:n{#1!}
      \int_set:Nn \l_stex_get_symbol_arity_int \l_stex_args_count
      \str_set_eq:NN \l_stex_key_name_str \l_@@_name_str
      \tl_set_eq:NN \l_stex_get_symbol_args_tl \l_@@_args_tl 
      \l_@@_do_next:
    }
  }{
    \l_@@_do_next:
  }
}{}{}

\cs_new:Nn \_@@_make_argls:n {
  #1\tl_to_str:n{i}{\c_dollar_str#1}
}

\cs_new_protected:Nn \_@@_add_varseq: { 
  \tl_put_left:Nx \l_stex_variables_seq {
    \_stex_variable:nnnnnnnN
    {\l_stex_macroname_str}
    {\l_stex_key_name_str}
    {\int_use:N \l_stex_args_count}
    {\l_stex_get_symbol_args_tl}
    {\exp_args:No \exp_not:n \l_stex_key_def_tl}
    {\int_use:N \l_@@_seq_arity_int {\l_@@_index_clist}{\exp_args:No \exp_not:n \l_@@_range_clist}}
    {\exp_args:No \exp_not:n \l_stex_key_return_tl}
    \stex_invoke_sequence:
  }
  \int_compare:nNnF \l_stex_args_count > \l_@@_seq_arity_int {
    \tl_put_left:Nx \l_stex_variables_seq {
      \_stex_variable:nnnnnnnN
      {\l_stex_macroname_str!}
      {\l_stex_key_name_str!}
      {1}
      {i1{\c_dollar_str 1}}
      {\exp_args:No \exp_not:n \l_stex_key_def_tl}
      {\int_use:N \l_@@_seq_arity_int {\l_@@_index_clist}{\exp_args:No \exp_not:n \l_@@_range_clist}}
      {}
      \stex_invoke_sequence:
    }
  }
}

\cs_new_protected:Nn \_@@_varseq_macro: { 
  \tl_set:cx{\l_stex_macroname_str}{
    \_stex_invoke_variable:nnnnnnN
      {\l_stex_key_name_str}
      {\int_use:N \l_stex_args_count}
      {\l_stex_get_symbol_args_tl}
      {\exp_args:No \exp_not:n \l_stex_key_def_tl}
      {\int_use:N \l_@@_seq_arity_int {\l_@@_index_clist}{\exp_args:No \exp_not:n \l_@@_range_clist}}
      {\exp_args:No \exp_not:n \l_stex_key_return_tl}
      \stex_invoke_sequence:
  }
  \int_compare:nNnF \l_stex_args_count > \l_@@_seq_arity_int {
    \tl_set:cx{\l_stex_macroname_str}{
      \_stex_invoke_variable:nnnnnnN
      {\l_stex_macroname_str!}
      {\l_stex_key_name_str!}
      {1}
      {i1{\c_dollar_str 1}}
      {\exp_args:No \exp_not:n \l_stex_key_def_tl}
      {\int_use:N \l_@@_seq_arity_int {\l_@@_index_clist}{\exp_args:No \exp_not:n \l_@@_range_clist}}
      {}
      \stex_invoke_sequence:
    }
  }
}

\cs_new_protected:Nn \_@@_make_args: { \TODO }
\cs_new_protected:Nn \_@@_check_terms: { }%\TODO }
\cs_new_protected:Nn \_@@_varseq_html: { }%\TODO }

\cs_new:Npn \stex_make_seq_clist:w #1 #2 #3 #4 #5 #6 \stex_invoke_sequence: {
  \TODO
}


\cs_new_protected:Nn \stex_invoke_sequence: {
  \exp_after:wN \_@@_setup:nnn \STEXInteralCurrentType
  \peek_charcode_remove:NTF ! {
    \peek_charcode:NTF [ \_@@_doop:w { \_@@_doop:w [] }
  }\_@@_do_first:
}

\cs_new_protected:Nn \_@@_setup:nnn{
  \int_set:Nn \l_@@_seq_arity_int {#1}
  \clist_set:Nn \l_@@_index_clist {#2}
  \clist_set:Nn \l_@@_range_clist {#3}
}


\cs_new_protected:Npn \_@@_doop:w [#1] {
  \stex_debug:nn {Here}{Do~op}
  \_@@_get_index_notation:n{#1}
  % TODO different criterion?
  \int_compare:nNnTF{\clist_count:N\l_@@_range_clist}=1{
    \peek_charcode:NTF [ \_@@_doop_in:w { \_@@_doop_in:w[] }
  }{
    \peek_charcode:NTF [ \_@@_doop_range:w { \_@@_doop_range:w[] }
  }
}

\cs_new_protected:Nn \_@@_doop_arg_range:n {
  \tl_if_eq:nnTF{#1}{\ellipses}{
    \clist_put_right:Nx \l_@@_clist {
      \exp_not:n{
        \tl_clear:N \STEXInternalSymbolAfterInvokationTL
        \def\comp{\_varcomp}
        \str_set:Nn \stex_current_symbol_str
      }{\stex_current_symbol_str}
      \exp_not:N #1
    }
  }{
    \clist_put_right:Nx \l_@@_clist {
      \exp_not:n{
        \tl_clear:N \STEXInternalSymbolAfterInvokationTL
        \def\comp{\_varcomp}
        \str_set:Nn \stex_current_symbol_str
      }{\stex_current_symbol_str}
      \exp_after:wN\exp_not:n\exp_after:wN{ \l_@@_cs #1 }
    }
  }
}

\cs_new_protected:Npn \_@@_doop_range:w [#1] {
  \bool_set_true:N \l_stex_allow_semantic_bool
  \clist_clear:N \l_@@_clist
  \clist_map_function:NN \l_@@_range_clist \_@@_doop_arg_range:n
  \exp_args:Nnx \use:nn{\symuse{Metatheory?stex-sequence}[#1]}{
    {
      \exp_args:No \exp_not:n \l_@@_clist
    }
  }
  \STEXInternalSymbolAfterInvokationTL
}

\cs_new:Nn \_@@_doop_arg_idx:n {
  {\exp_not:n{#1}}
}

\cs_new_protected:Npn \_@@_doop_in:w [#1] {
  \bool_set_true:N \l_stex_allow_semantic_bool
  \exp_args:Nnx \use:nn{\symuse{Metatheory?stex-sequence-in}[#1]}{
    {
      \exp_args:NNe \exp_args:No \exp_not:n {
        \exp_not:n{
          \tl_clear:N \STEXInternalSymbolAfterInvokationTL
          \def\comp{\_varcomp}
          \str_set:Nn \stex_current_symbol_str
        }
       {\stex_current_symbol_str}
      \exp_args:Nne \use:nn {\exp_not:N \l_@@_cs} {\clist_map_function:NN \l_@@_index_clist \_@@_doop_arg_idx:n}}
    }
    { \exp_args:No \exp_not:n \l_@@_index_clist}
    { \exp_args:No \exp_not:n \l_@@_range_clist }
  }
  \STEXInternalSymbolAfterInvokationTL
}

\cs_new_protected:Nn \_@@_get_index_notation:n {
  \cs_if_exist:cTF {l_stex_notation_\stex_current_symbol_str! _#1_cs}{
    \cs_set_eq:Nc \l_@@_cs {l_stex_notation_\stex_current_symbol_str! _#1_cs}
  }{
    \int_compare:nNnTF \l_@@_seq_arity_int = \STEXInternalCurrentArityStr {
      \cs_if_exist:cTF {l_stex_notation_\stex_current_symbol_str _#1_cs}{
        \cs_set_eq:Nc \l_@@_cs {l_stex_notation_\stex_current_symbol_str _#1_cs}
      }{
        \msg_error:nnxx{stex}{error/nonotation}{\stex_current_symbol_str}{#1}
      }
    }{
      \msg_error:nnxx{stex}{error/nonotation}{\stex_current_symbol_str}{#1}
    }
  }
}


\cs_new:Nn \_@@_do_first_arg:n {{\exp_not:n{## #1}}}
\cs_new_protected:Nn \_@@_do_first: {
  \exp_args:Nnx \use:nn{
  \cs_generate_from_arg_count:NNnn \l_@@_cs \cs_set:Npn
  \l_@@_seq_arity_int} {{
    \tl_set:Nn \exp_not:N \l_@@_first_args_tl {
      \int_step_function:nN \l_@@_seq_arity_int \_@@_do_first_arg:n
    }
    \exp_not:N \_@@_do_first_next:
  }}
  \l_@@_cs
}
\cs_new_protected:Nn \_@@_do_first_next: {
  \peek_charcode_remove:NTF ! {
    \peek_charcode:NTF [ \_@@_do_one:w {\_@@_do_one:w []}
  }{
    \peek_charcode:NTF [ \_@@_do_all:w {\_@@_do_all:w []}
    \exp_after:wN \_@@_do_all: \l_@@_first_args_tl
  }
}

\cs_new_protected:Npn \_@@_do_one:w [#1] {
  \stex_debug:nn {Here}{Do~one}
  \_@@_get_index_notation:n{#1}
  \exp_args:Nno\use:nn{\l_@@_cs}\l_@@_first_args_tl
}

\cs_new_protected:Npn \_@@_do_all:w [#1] {
  \stex_debug:nn {Here}{Do~all}
  \exp_args:Nno\use:nn{\_stex_invoke_notation:w [#1]}\l_@@_first_args_tl
}
%    \end{macrocode}
% \end{macro}
%
% \end{sfragment}
%
%
% \begin{sfragment}{Expressions}
%    \begin{macrocode}
%<@@=stex_expr>
%    \end{macrocode}
%
% \begin{macro}{\infprec,\neginfprec}
%    \begin{macrocode}
\tl_const:Nx \infprec {\int_use:N \c_max_int}
\tl_const:Nx \neginfprec {-\int_use:N \c_max_int}
\bool_new:N \l_stex_allow_semantic_bool
\bool_set_true:N \l_stex_allow_semantic_bool
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_invoke_symbol:nnnnnnnN}
%    \begin{macrocode}

\cs_new_protected:Nn \_@@_setup:nnnnnn {
  \group_begin:
  \bool_set_false:N \l_stex_allow_semantic_bool
  \def\comp{#1}
  \tl_set:Nn \STEXInternalSymbolAfterInvokationTL {
    %\bool_set_true:N \l_stex_allow_semantic_bool
    \group_end:
  }
  \str_set:Nn \stex_current_symbol_str {#2} 
  \str_set:Nn \STEXInternalCurrentArityStr{ #3 }
  \tl_set:Nn \STEXInternalCurrentArgsTl{ #4 }
  %    \seq_set_split:Nnn\STEXInternalCurrentArgnamesSeq , { #5 }
  \tl_set:Nn \STEXInteralCurrentReturn{ #5 }
  \tl_set:Nn \STEXInteralCurrentType{ #6 }
}

\cs_new_protected:Nn \_stex_invoke_symbol:nnnnnnnN {
  \bool_if:NTF \l_stex_allow_semantic_bool{
    \stex_html_backend:T{\ifvmode\indent\fi}
    \_@@_setup:nnnnnn{\_comp}{#1?#2}{#3}{#4}{#7}{#6}
    #8%\stex_invoke_symbol:
  }{
    \msg_error:nnxx{stex}{error/notallowed}{#2}{\stex_current_symbol_str}
  }
}
\cs_generate_variant:Nn \_stex_invoke_symbol:nnnnnnnN {ooxooooN}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\_stex_invoke_variable:nnnnnn}
%    \begin{macrocode}

\cs_new_protected:Nn \_stex_invoke_variable:nnnnnnN {
  \bool_if:NTF \l_stex_allow_semantic_bool{
    \stex_html_backend:T{\ifvmode\indent\fi}
    \_@@_setup:nnnnnn{\_varcomp}{#1}{#2}{#3}{#6}{#5}
    #7
  }{
    \msg_error:nnxx{stex}{error/notallowed}{#2}{\stex_current_symbol_str}
  }
}

%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\stex_invoke_symbol:}
%    \begin{macrocode}
\cs_new_protected:Nn \stex_invoke_symbol: {
  \stex_debug:nn{expressions}{Invoking~\stex_current_symbol_str}
  \mode_if_math:TF \@@_invoke_math: \@@_invoke_text:
}

\cs_new_protected:Nn \@@_invoke_text: {
  \stex_debug:nn{expressions}{text~mode}
  \peek_charcode_remove:NTF ! \@@_invoke_op_custom:n \@@_invoke_custom:n
}

\cs_new_protected:Nn \@@_invoke_math: {
  \stex_debug:nn{expressions}{math~mode}
  \peek_charcode_remove:NTF ! {
    % operator
    \peek_charcode_remove:NTF * \@@_invoke_op_custom:n {
      % op notation
      \peek_charcode:NTF [ \@@_invoke_op_notation:w {
        \@@_invoke_op_notation:w []
      }
    }
  }{
    \peek_charcode_remove:NTF * \@@_invoke_custom:n {
      % normal
      \peek_charcode:NTF [ \_stex_invoke_notation:w {
        \_stex_invoke_notation:w []
      }
    }
  }
}

\cs_new:Nn \_@@_return_arg:n {
  \tl_put_right:Nn \exp_not:N \l_@@_return_args_tl {{#### #1}}
}

\cs_new_protected:Nn \@@_invoke_return_maybe:n {
  \tl_clear:N \l_@@_return_args_tl
  \tl_set:Nn \l_@@_return_this_tl {#1}
  \exp_args:Nnx \use:n {
  \cs_generate_from_arg_count:NNnn \_@@_ret_cs
    \cs_set:Npn \STEXInternalCurrentArityStr } {
      \int_step_function:nN \STEXInternalCurrentArityStr \_@@_return_arg:n
      \_@@_invoke_return_next:
    }
  \_@@_ret_cs
}

\cs_new_protected:Nn \_@@_invoke_return_next: {
  \peek_charcode_remove:NTF ! {
    \exp_after:wN \l_@@_return_this_tl \l_@@_return_args_tl
  }\_@@_invoke_return:
}

\cs_new_protected:Nn \@@_invoke_return: {
  \exp_args:Nnx \use:n {
  \cs_generate_from_arg_count:NNnn \_@@_ret_cs
    \cs_set:Npn \STEXInternalCurrentArityStr } {
      %\exp_not:N \exp_not:n {
        %\exp_not:n{\tl_set:Nn \this}{\exp_args:No \exp_not:n \l_@@_return_this_tl!}
        \exp_args:No \exp_not:n \STEXInteralCurrentReturn
      %}
    }
  %\stex_debug:nn{return}{1:~\meaning\_@@_ret_cs^^J\exp_args:No \exp_not:n \l_@@_return_args_tl }
  \exp_args:Nnx \use:nn {
    \exp_after:wN \STEXInternalSymbolAfterInvokationTL\_@@_ret_cs
  }{
    \exp_args:No \exp_not:n \l_@@_return_args_tl
    {
      \_@@_setup:nnnnnn{
        \exp_args:No \exp_not:n \comp
      }{
        \stex_current_symbol_str
      }{
        \STEXInternalCurrentArityStr
      }{
        \STEXInternalCurrentArgsTl
      }{}{}
      \exp_args:No \exp_not:n \l_@@_return_this_tl
      \exp_args:No \exp_not:n \l_@@_return_args_tl
    }
  }
}

\cs_new_protected:Nn \@@_invoke_op_custom:n {
  \stex_debug:nn{expressions}{custom~op}
  \TODO
}

\cs_new_protected:Nn \@@_invoke_custom:nn {
  \stex_debug:nn{expressions}{custom~notation}
  \TODO
}

\cs_new_protected:Npn \@@_invoke_op_notation:w [#1] {
  \stex_debug:nn{expressions}{op~notation}
  \cs_if_exist:cTF{l_stex_notation_\stex_current_symbol_str _op_#1_cs}{
    \STEXInternalTermMathOMSiii{#1}{\neginfprec}{\use:c{l_stex_notation_\stex_current_symbol_str _op_#1_cs}}
    \STEXInternalSymbolAfterInvokationTL
  }{
    \int_compare:nNnTF \STEXInternalCurrentArityStr = 0 {
      \tl_clear:N \STEXInteralCurrentReturn
      \_stex_invoke_notation:w [#1]
    }{
      \msg_error:nnxx{stex}{error/noop}{\stex_current_symbol_str}{#1}
    }
  }
}

\cs_new_protected:Npn \_stex_invoke_notation:w [#1] {
  \stex_debug:nn{expressions}{using~notation~#1~for~\stex_current_symbol_str}
  \cs_if_exist:cTF{l_stex_notation_\stex_current_symbol_str _#1_cs}{
    \tl_if_empty:NTF \STEXInteralCurrentReturn {
      \use:c{l_stex_notation_\stex_current_symbol_str _#1_cs}
    }{
      \exp_args:Ne \@@_invoke_return_maybe:n{
        \exp_args:Nne \use:n {\exp_not:N \use:c}{l_stex_notation_\stex_current_symbol_str _#1_cs}
      }
    }
  }{
    \msg_error:nnxx{stex}{error/nonotation}{\stex_current_symbol_str}{#1}
  }
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{macro}{\STEXInternalTermMathArgiii,\STEXInternalTermMathOMSiii,\STEXInternalTermMathOMAiii,\STEXInternalTermMathOMBiii}
%    \begin{macrocode}

\cs_new_protected:Nn \_stex_term_arg:nn {
  \stex_annotate:nnn{ stex:arg }{ #1 }{ #2 }
}

\cs_new_protected:Npn \STEXInternalTermMathArgiii #1 #2 #3 {
  \group_begin:
    \let \stex_current_symbol_str \undefined
    \int_set:Nn \l_@@_downprec { #2 }
    \bool_set_true:N \l_stex_allow_semantic_bool
    \_stex_term_arg:nn { #1 }{ #3 }
  \group_end:
}


\cs_new_protected:Npn \STEXInternalTermMathAssocArgiiiii #1 #2 #3 #4 #5 {
  \tl_if_empty:nTF{#3}{
    \STEXInternalTermMathArgiii{#5#1}{#2}{}
  }{
    % TODO: check whether #3 is sequence
    \tl_clear:N \l_@@_ret_tl
    \_@@_assoc_simple:nnnnn{#1}{#2}{#3}{#4}{#5}
  }
}

\int_new:N \l_@@_assoc_count
\cs_new_protected:Nn \_@@_assoc_simple:nnnnn {
  \group_begin:
    \int_set:Nn \l_@@_assoc_count {1}
    \_@@_assoc_simple_inner:nnnnn{#1}{#2}{#3}{#4}{#5}
  \group_end:
}

\quark_new:N \_@@_end:
\cs_new:Npn \_@@_head:w #1,#2\_@@_end:{\exp_after:wN\exp_not:n\exp_after:wN{\exp_not:n{#1}}}
\cs_new:Npn \_@@_tail:w #1,#2\_@@_end:{\exp_after:wN\exp_not:n\exp_after:wN{#2}}

\newtoks\l_stex_assoc_toks_i
\newtoks\l_stex_assoc_toks_ii

\cs_new_protected:Nn \_@@_assoc_simple_inner:nnnnn {
  \int_compare:nNnTF {\clist_count:n {#3}} = 1 {
    \STEXInternalTermMathArgiii{A#5#1\int_use:N\l_@@_assoc_count}{#2}{#3}
  }{
    \group_begin:
    \exp_args:Nx \l_stex_assoc_toks_i {
      \STEXInternalTermMathArgiii{A#5#1\int_use:N\l_@@_assoc_count}{#2}{
        \_@@_head:w #3 \_@@_end:
      }
    }
    \exp_args:Nx \l_stex_assoc_toks_ii {
      \_@@_assoc_simple_inner:nnnnn{#1}{#2}
        {\_@@_tail:w#3\_@@_end:}{\exp_not:n{#4}}{#5}
    }
    %\stex_pseudogroup_with:nn{\STEXInternalAssocArgMarkerI\STEXInternalAssocArgMarkerII}{
      \cs_set:Npn \STEXInternalAssocArgMarkerI {
        \the \l_stex_assoc_toks_i
      }
      \int_incr:N \l_@@_assoc_count
      \cs_set:Npn \STEXInternalAssocArgMarkerII {
        \the \l_stex_assoc_toks_ii
      }
      #4
    %}
    \group_end:
  }
}

%\cs_new_protected:Nn \_stex_term_omv:n {
%  \stex_annotate:nnn{ stex:OMV }\stex_current_symbol_str{
%    #1
%  }
%}

\cs_new_protected:Nn \_stex_term_oms:n {
  \stex_annotate:nnn{ stex:OMID }\stex_current_symbol_str{
    #1
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMSiii #1 #2 #3 {
  \_@@_maybe_brackets:nn{#2}{
    \_stex_term_oms:n{#3}
  }
}

\cs_new_protected:Nn \_stex_term_oma:n {
  \stex_annotate:nnn{ stex:OMA }\stex_current_symbol_str{
    #1
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMAiii #1 #2 #3 { 
  \_@@_maybe_brackets:nn{#2}{
    \_stex_term_oma:n{#3}
  }
}

\cs_new_protected:Nn \_stex_term_omb:n {
  \stex_annotate:nnn{ stex:OMBIND }\stex_current_symbol_str{
    #1
  }
}

\cs_new_protected:Npn \STEXInternalTermMathOMBiii #1 #2 #3 { 
  \_@@_maybe_brackets:nn{#2}{
    \_stex_term_omb:nn{#3}
  }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\dobrackets}
%    \begin{macrocode}
\int_new:N \l_@@_downprec
\int_set_eq:NN \l_@@_downprec \infprec
\tl_set:Nn \l_@@_left_bracket_str (
\tl_set:Nn \l_@@_right_bracket_str )
\bool_new:N \l_@@_brackets_done_bool

\cs_new_protected:Nn \_@@_maybe_brackets:nn {
  \bool_if:NTF \l_@@_brackets_done_bool {
    \bool_set_false:N \l_@@_brackets_done_bool
    #2
  } {
    \int_compare:nNnTF { #1 } > \l_@@_downprec {
      \bool_if:NTF \l_stex_inparray_bool { #2 }{
        \stex_debug:nn{dobrackets}{ #1 > \l_@@_downprec;~\tl_to_str:n{#2}}
        \dobrackets { #2 }
      }
    }{ #2 }
  }
}

%\RequirePackage{scalerel}
\cs_new_protected:Npn \dobrackets #1 {
  %\ThisStyle{\if D\m@switch
  %    \exp_args:Nnx \use:nn
  %    { \exp_after:wN \left\l_@@_left_bracket_str #1 } 
  %    { \exp_not:N\right\l_@@_right_bracket_str }
  %  \else
  \stex_pseudogroup_with:nn{\l_@@_brackets_done_bool\l_@@_downprec}{ 
    \bool_set_true:N \l_@@_brackets_done_bool
    \int_set:Nn \l_@@_downprec \infprec
    \comp\l_@@_left_bracket_str 
    #1
  }
  \comp\l_@@_right_bracket_str
  %\fi}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\withbrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \withbrackets #1 #2 #3 {
  \stex_pseudogroup_with:nn{\l_@@_left_bracket_str\l_@@_right_bracket_str}{
    \tl_set:Nn \l_@@_left_bracket_str { #1 }
    \tl_set:Nn \l_@@_right_bracket_str { #2 }
    #3
  }
}
%    \end{macrocode}
% \end{macro}
%

% \begin{macro}{\dowithbrackets}
%    \begin{macrocode}
\cs_new_protected:Npn \dowithbrackets #1 #2 #3 {
  \withbrackets{#1}{#2}{\dobrackets{#3}}
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\STEXinvisible}
%    \begin{macrocode}
\cs_new_protected:Npn \STEXinvisible #1 {
  \stex_annotate_invisible:n { #1 }
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symuse}
%    \begin{macrocode}
\cs_new_protected:Npn \symuse #1 {
  \stex_get_symbol:n{#1}
  \_stex_invoke_symbol:ooxooooN
  \l_stex_get_symbol_mod_str
  \l_stex_get_symbol_name_str
  {\int_use:N \l_stex_get_symbol_arity_int}
  \l_stex_get_symbol_args_tl
  \l_stex_get_symbol_def_tl
  \l_stex_get_symbol_type_tl
  \l_stex_get_symbol_return_tl
  \l_stex_get_symbol_invoke_cs
}
%    \end{macrocode}
% \end{macro}
%
% \begin{macro}{\symname,\sn,\sns,\Symname,\Sn,\Sns,\symref,\sr}
%    \begin{macrocode}
\NewDocumentCommand \symref { m m} {
  \_@@_do_ref:nn{#1}{#2}
}
\let\sr\symref

\stex_keys_define:nnnn{symname}{
  \tl_clear:N \l_stex_key_pre_tl
  \tl_clear:N \l_stex_key_post_tl
  %\tl_clear:N \l_stex_key_proot_tl
}{
  pre    .tl_set:N   = \l_stex_key_pre_tl ,
  post   .tl_set:N   = \l_stex_key_post_tl ,
  root   .code:n     = {}%.tl_set:N   = \l_stex_key_root_tl
}{}

\NewDocumentCommand \symname { O{} m} {
  \stex_keys_set:nn{symname}{#1}
  \_@@_do_ref:nn{#2}{
    \l_stex_key_pre_tl\l_stex_get_symbol_name_str\l_stex_key_post_tl
  }
}
\let\sn\symname
\protected\def\sns{\symname[post=s]}

\NewDocumentCommand \Symname { O{} m} {
  \stex_keys_set:nn{symname}{#1}
  \_@@_do_ref:nn{#2}{
    \l_stex_key_pre_tl\exp_after:wN\_@@_capitalize:n\l_stex_get_symbol_name_str\l_stex_key_post_tl
  }
}
\cs_new_protected:Nn \_@@_capitalize:n {
  \uppercase{#1}
}
\let\Sn\Symname
\protected\def\Sns{\Symname[post=s]}

\cs_new:Npn \_@@_split_slash: #1/#2/#3\_stex_args_end: {
 \tl_if_empty:nTF{#3}{
  #2
 }{
  \_@@_split_slash: #2/#3/\_stex_args_end:
 }
}


\cs_new_protected:Nn \_@@_do_ref:nn {
  \stex_html_backend:T{\ifvmode\indent\fi}
  \group_begin:
  \stex_get_symbol:n{#1}
  \bool_if:NTF \l_stex_allow_semantic_bool{
    \str_set:Nx\stex_current_symbol_str
      {\l_stex_get_symbol_mod_str ? \l_stex_get_symbol_name_str}
    \str_if_in:NnT \l_stex_get_symbol_name_str / {
      \str_set:Nx \l_stex_get_symbol_name_str {
        \exp_after:wN \_@@_split_slash: \l_stex_get_symbol_name_str
        /\_stex_args_end:
      }
    }
    \def\comp{\_comp}
    \let\compemph@uri\symrefemph@uri
    \_stex_term_oms:n{\comp{#2}}
  }{
    \msg_error:nnnx{stex}{error/notallowed}{#1}{\stex_current_symbol_str}
  }
  \group_end:
}
%    \end{macrocode}
% \end{macro}
%
%
% \begin{sfragment}{Highlighting}
%    \begin{macrocode}
%<@@=stex_notationcomps>
%    \end{macrocode}
%
% \begin{macro}{\comp,\compemph@uri,\compemph,\defemph,\defemph@uri,\symrefemph,\symrefemph@uri,\varemph,\varemph@uri}
%    \begin{macrocode}
\cs_new_protected:Npn \_comp #1 {
  \str_if_empty:NF \stex_current_symbol_str {
    \stex_html_backend:TF {
      \stex_annotate:nnn { stex:comp }{}{ #1 }
    }{
      \exp_args:Nnx \compemph@uri { #1 } { \stex_current_symbol_str }
    }
  }
}

\cs_new_protected:Npn \_varcomp #1 {
  \str_if_empty:NF \stex_current_symbol_str {
    \stex_html_backend:TF {
      \stex_annotate:nnn { stex:varcomp }{}{ #1 }
    }{
      \exp_args:Nnx \varemph@uri { #1 } { \stex_current_symbol_str }
    }
  }
}

\cs_new_protected:Npn \comp {}

\cs_new_protected:Npn \compemph@uri #1 #2 {
    \compemph{ #1 }
}

\cs_new_protected:Npn \compemph #1 {
    #1
}

\cs_new_protected:Npn \defemph@uri #1 #2 {
    \defemph{#1}
}

\cs_new_protected:Npn \defemph #1 {
    \textbf{#1}
}

\cs_new_protected:Npn \symrefemph@uri #1 #2 {
    \symrefemph{#1}
}

\cs_new_protected:Npn \symrefemph #1 {
    \emph{#1}
}

\cs_new_protected:Npn \varemph@uri #1 #2 {
    \varemph{#1}
}

\cs_new_protected:Npn \varemph #1 {
    #1
}
%    \end{macrocode}
% \end{macro}
%
%
% \end{sfragment}
%
% \end{sfragment}
%
% \end{sfragment}
%
% \begin{sfragment}{Mathematical Structures}
%    \begin{macrocode}
%<@@=stex_structures>
%    \end{macrocode}
%
% \begin{environment}{mathstructure}
%    \begin{macrocode}
\stex_new_stylable_env:nnnnnnn {mathstructure}{m O{}}{
  \tl_if_empty:nTF {#2} {
    \str_set:Nn \l_@@_name_str {#1}
  }{
    \str_set:Nn \l_@@_name_str {#2}
  }
  \exp_args:Nno 
  \begin{structural_feature_module}{\l_@@_name_str-structure}{structure}{
    \protected\def\this{}
  }
}{
  \end{structural_feature_module}
  \_@@_do_externals:
  
  \exp_args:Nnx \use:nn { \stex_add_module_decl:nnnnnnnN }
    { {#1}{\l_@@_name_str}{0}{}{defed}{\g_stex_last_feature_str}}
    {}\stex_invoke_structure:

  \stex_execute_in_module:x {
    \protected \tl_set:cn{#1}{
      \_stex_invoke_symbol:nnnnnnnN
      {\l_stex_current_module_str}
      {\l_@@_name_str}{0}{}{defed}{\g_stex_last_feature_str}{}
      \stex_invoke_structure:
    }
  }
}{}{}{}

\stex_sms_allow_env:n{mathstructure}
\stex_deactivate_macro:Nn \mathstructure {module~environments}
\stex_every_module:n {\stex_reactivate_macro:N \mathstructure}

\cs_new_protected:Nn \_@@_do_externals: {
  \tl_set:Nn \l_@@_replace_this_tl {####1}
  \exp_args:No \stex_iterate_all_decls:nn{\g_stex_last_feature_str}{
    \_@@_external_decl:nnnn{##5}{##4}{##3}{##8}
  }
  %\exp_args:No \stex_iterate_all_notations:nn{\g_stex_last_feature_str}{
  %  \stex_debug:nn{Here!}{^^J
  %  1:\tl_to_str:n{##1}^^J
  %  2:\tl_to_str:n{##2}^^J
  %  3:\tl_to_str:n{##3}^^J
  %  4:\tl_to_str:n{##4}^^J
  %  5:\tl_to_str:n{##5}
  %  }
  %  \exp_args:Nno \stex_str_if_starts_with:nnT
  %    {##1}{\g_stex_last_feature_str}{
  %    \exp_args:Nx \_@@_external_notation:nnnnn {
  %      \str_range:nnn{##1}{\str_count:N \g_stex_last_feature_str + 2}{-1}
  %    }{##3}{##4}{##5}{##2}
  %  }
  %}
}

\cs_new_protected:Nn \_@@_external_decl:nnnn {
  \stex_debug:nn{structure}{
    Generating~external~declaration~\l_@@_name_str/#3~in~
    \l_stex_current_module_str
  }
  \tl_set:Nn \l_stex_get_symbol_args_tl {#1}
  \exp_args:Nnx \use:nn {\stex_add_module_decl:nnnnnnnN} {
    {}{\l_@@_name_str/#3}{\int_eval:n{#2 + 1}}
    {1i{\tl_to_str:n{$this}}\tl_if_empty:nF{#1}{\_stex_make_args_with:N \_@@_shift_argls:nnnw}}
    {defed}{typed}
  }{#4}\stex_invoke_outer_field:
}
\iffalse$\fi

\cs_new:Npn \_@@_shift_argls:nnnw #1 #2 #3 #4 \_stex_args_end: {
  \int_eval:n{#1+1}#2{#3}
  \_stex_make_args_i:Nw \_@@_shift_argls:nnnw #4 \_stex_args_end:
}
%    \end{macrocode}
% \end{environment}
%
% Invoking structures:
%    \begin{macrocode}
\cs_new_protected:Nn \stex_invoke_structure: {
  \exp_args:No \_stex_invoke_structure:nn \STEXInteralCurrentType {}
}

\cs_new_protected:Nn \_stex_invoke_structure:nn {
  \stex_debug:nn{structure}{invoking~structure~#1<\tl_to_str:n{#2}>}
  \peek_charcode:NTF < {
    \_@@_invoke_merge:nnw{#1}{#2}
  }{
    \peek_charcode_remove:NTF ! {
      \peek_charcode:NTF [ {
        \_@@_maybe_notation:nnw{#1}{#2}
      }{
        \_@@_maybe_notation:nnw{#1}{#2}[]
      }
    }{
      \_@@_invoke_this:nnn{#1}{#2}
    }
  }
}

\cs_new_protected:Npn \_@@_invoke_merge:nnw #1 #2 < #3 > {
  \tl_if_empty:nTF{#2}{
    \_stex_invoke_structure:nn{#1}{#3}
  }{
    \tl_if_empty:nTF{#3}{
      \_stex_invoke_structure:nn{#1}{#2}
    }{
      \_stex_invoke_structure:nn{#1}{#2,#3}
    }
  }
}
%    \end{macrocode}
%
% Preparing anonymous records:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_make_prop:nn {
  \_@@_make_prop:n{ #1 }
  \tl_if_empty:nF{ #2 }{
    \_@@_make_prop_assigns:n{#2}
  }
  \_@@_make_term:nn{#1}{#2}
}

\cs_new_protected:Nn \_@@_make_prop:n {
  \prop_clear:N \l_@@_prop
  \seq_clear:N \l_@@_seq
  \_@@_prop_do_decls:n{#1}
  \_@@_prop_do_notations:n{#1}
}

\cs_new_protected:Nn \_@@_prop_do_notations:n {
  \stex_iterate_all_notations:nn{#1}{
    \seq_if_in:NnT \l_@@_seq {##1}{
      \seq_set_split:Nnn \l_@@_tmp_seq ? {##1}
      \seq_pop_right:NN \l_@@_tmp_seq \l_@@_name
      \str_set:Nx \l_@@_name {
        this?[\seq_use:Nn \l_@@_tmp_seq ?]/\l_@@_name
      }
      \cs_if_exist:cF{l_stex_notation_\l_@@_name __cs}{
        \cs_generate_from_arg_count:cNnn{l_stex_notation_\l_@@_name __cs}
        \cs_set_nopar:Npn {##3}{##4}
      }
      \tl_if_empty:nF{##5}{
        \cs_if_exist:cF{l_stex_notation_\l_@@_name _op__cs}{
          \tl_set:cn{l_stex_notation_\l_@@_name _op__cs}{\comp{##5}}
        }
      }
    }
  }
}

\cs_new_protected:Nn \_@@_prop_do_decls:n {
  \stex_iterate_all_decls:nn{#1}{
    \tl_if_empty:nTF{##2}{
      \prop_if_in:NnF \l_@@_prop {##3} {
        \seq_put_left:Nn \l_@@_seq{##1?##3}
        \prop_put:Nnn \l_@@_prop {##3}{
          {}{
            \_stex_invoke_symbol:nnnnnnnN
            {this}
            {[##1]/##3}
            {##4}{##5}{##6}{##7}{##8}##9
          }
        }
      }
    }{
      \prop_if_in:NnF\l_@@_prop {##2} {
        \seq_put_left:Nn \l_@@_seq{##1?##3}
        \prop_put:Nnn \l_@@_prop {##2}{
          {##3}{
            \_stex_invoke_symbol:nnnnnnnN
            {this}
            {[##1]/##3}
            {##4}{##5}{##6}{##7}{##8}##9
          }
        }
        \tl_set:cn{##2}{
          \_stex_invoke_symbol:nnnnnnnN
          {this}
          {[##1]/##3}
          {##4}{##5}{##6}{##7}{##8}##9
        }
      }
    }
  }
}

\cs_new_protected:Nn \_@@_make_prop_assigns:n {
  \keyval_parse:NNn\TODO\_@@_make_prop_assign:nn{#1}
}
\cs_new_protected:Nn \_@@_make_prop_assign:nn {
  \prop_if_in:NnTF \l_@@_prop {#1}{
    \exp_args:Nne \use:nn {\_@@_make_prop_assign_replace:nnnn {#1}{#2}}
    {\prop_item:Nn \l_@@_prop {#1}}
  }{
    \TODO Error
  }
}
\cs_new_protected:Nn \_@@_make_prop_assign_replace:nnnn {
  \prop_put:Nnn \l_@@_prop {#1}{{#3}{#2}}
}

\cs_new_protected:Nn \_@@_make_term:nn {
  \clist_clear:N \l_@@_clist
  %\str_if_exist:NT \stex_current_symbol_str {
    \clist_put_right:Nx \l_@@_clist {
      \stex_annotate:nnn{stex:OMS}{\stex_current_symbol_str}{}
    }
  %}
  \clist_map_inline:nn{#1}{
    \clist_put_right:Nn \l_@@_clist {
      \stex_annotate:nnn{stex:OMMOD}{##1}{}
    }
  }
  \tl_set:Nx \l_@@_type_cs {\symuse{Metatheory?module-type}{\l_@@_clist}}
  \tl_if_empty:nTF{#2}{
    \tl_put_right:Nn \l_@@_type_cs {{}}
  }{
    \_@@_make_term_assigns:n{#2}
  }
}

\cs_new_protected:Nn \_@@_make_term_assigns:n {
  \clist_clear:N \l_@@_clist
  \keyval_parse:NNn\TODO\_@@_make_term_assign:nn{#1}
  \tl_put_right:No \l_@@_type_cs{\exp_after:wN{\l_@@_clist}}
}

\cs_new_protected:Nn \_@@_make_term_assign:nn{
  \clist_put_right:Nx \l_@@_clist {
    \stex_annotate:nnn{stex:OML}{#1}{
      \stex_annotate:nnn{stex:def}{}{#2!}
    }
  }
}
%    \end{macrocode}
%
% Presenting structures:
%    \begin{macrocode}
\cs_new_protected:Npn \_@@_maybe_notation:nnw #1 #2 [ #3 ] {
  \cs_if_exist:cTF{l_stex_notation_\stex_current_symbol_str _#3_cs}{
    \use:c{l_stex_notation_\stex_current_symbol_str _#3_cs}
  }{
    \exp_args:Nnx \use:nn {\STEXInternalSymbolAfterInvokationTL}{
      \tl_set:Nn \exp_not:N \stex_current_symbol_str {\stex_current_symbol_str}
    }
    \tl_if_empty:nTF{#3}{
      \_@@_present:nn{#1}{#2}
    }{
      \_@@_present:nn{#1}{#2}[#3]
    }
  }
}

\cs_new_protected:Nn \_stex_structure_as_type:nn{
  \exp_args:Nno \use:n{\symuse{Metatheory?in-module}[hidden]{
    \mathstruct[#1]{#2}
  }}{\l_@@_type_cs}
}

% #1 module clist, #2 assignments
\cs_new_protected:Nn \_@@_present:nn {
  \stex_debug:nn{structure}{structure!}
  \group_begin:
  \tl_set:Nn \this{}
  \_@@_make_prop:nn{#1}{#2}
  \peek_charcode:NTF [ {
    \_@@_pres_not_or_fields:w
  }{
    \_@@_present_do:n{
      \_stex_structure_as_type:nn{}
    }
  }
}

% #1 modules; #2: assignments; #3 notation or fields
\cs_new_protected:Npn \_@@_pres_not_or_fields:w [ #1 ] {
  \stex_debug:nn{structure}{notation~or~fields?~#1}
  \int_compare:nNnTF {\clist_count:n {#1}} = 1 {
    \stex_debug:nn{structure}{notation~#1}
    \peek_charcode:NTF [ {
      \_@@_pres_not:nw{#1}
    }{
      \_@@_present_do:n{
        \_stex_structure_as_type:nn{#1}
      }
    }
  }{
    \stex_debug:nn{structure}{fields~#1}
    \peek_charcode:NTF [ {
      \_@@_pres_fields:nw{#1}
    }{
      \exp_args:No \_@@_present_do:nn{ \tl_to_str:n{#1} }{
        \_stex_structure_as_type:nn{}
      }
    }
  }
}

% #1: notation; #2: fields
\cs_new_protected:Npn \_@@_pres_not:nw #1 [ #2 ] {
  \stex_debug:nn{structure}{fields~#2}
  \exp_args:No \_@@_present_do:nn{ \tl_to_str:n{#2} }{
    \_stex_structure_as_type:nnn{#1}
  }
}

% #1: fields; #2: notation
\cs_new_protected:Npn \_@@_pres_fields:nw #1 [ #2 ] {
  \stex_debug:nn{structure}{notation~#2}
  \exp_args:No \_@@_present_do:nn{ \tl_to_str:n{#1} }{
    \_stex_structure_as_type:nnn{#2}
  }
} 

% First: fields, Second: Term
\cs_new_protected:Nn \_@@_present_do:nn {
  \clist_clear:N \l_@@_clist
  \cs_set:Npn \l_@@_cs ##1 ##2 ##3 {
    \stex_debug:nn{check}{##1~in~#1}
    \clist_if_in:nnT{#1}{##1}{
      \stex_debug:nn{check}{...yes}
      \clist_put_left:Nn \l_@@_clist { ##3! }
    }
  }
  \prop_map_inline:Nn \l_@@_prop { \l_@@_cs {##1} ##2}
  \exp_args:Nno \use:nn{#2}{\exp_after:wN{\l_@@_clist}}
  \group_end:
}

\cs_new_protected:Nn \_@@_present_do:n {
  \clist_clear:N \l_@@_clist
  \cs_set:Npn \l_@@_cs ##1 ##2 ##3 {
    \stex_debug:nn{empty?}{##2~(args:~\tl_to_str:n{##1},~\tl_to_str:n{##2},~\tl_to_str:n{##3})}
    \tl_if_empty:nF{##2}{
      \clist_put_left:Nn \l_@@_clist { ##3! }
    }
  }
  \prop_map_inline:Nn \l_@@_prop { \l_@@_cs {##1} ##2}
  \exp_args:Nno \use:nn{#1}{\exp_after:wN{\l_@@_clist}}
  \group_end:
}
%    \end{macrocode}
%
% Invoking record fields:
%    \begin{macrocode}
\cs_new_protected:Nn \_@@_invoke_this:nnn{
  \exp_args:Nnx \use:nn {\STEXInternalSymbolAfterInvokationTL}{
    \tl_set:Nn \exp_not:N \stex_current_symbol_str {\stex_current_symbol_str}
  }
  \peek_charcode_remove:NTF ! {
    #3
  }{
    \_@@_make_prop:nn{#1}{#2}
    \tl_set:Nx \this { 
      \group_begin:
      \cs_if_exist:NT \this {
        \def\exp_not:N\this{\exp_args:No \exp_not:n{\this}}
      }
      \_stex_term_arg:nn{this}{
        %\let \exp_not:N\stex_current_symbol_str \exp_not:N \undefined
        \bool_set_true:N \l_stex_allow_semantic_bool
        \symuse{Metatheory?in-module}[hidden]{\exp_not:n{#3}}{
          \def\exp_not:N\this{}\exp_args:No \exp_not:n \l_@@_type_cs
        }
      }
      \group_end:
    }
    \_stex_invoke_field:n
  }
}

\cs_new_protected:Nn \_stex_invoke_field:n {
  \prop_if_in:NnTF \l_@@_prop {#1}{
    \exp_args:Nnx \use:nn {\use_ii:nn} {\prop_item:Nn \l_@@_prop {#1}}
  }{
    \TODO error
  }
}

\cs_new_protected:Nn \stex_invoke_outer_field: {
  \stex_debug:nn{expressions}{Invoking~\stex_current_symbol_str}
  \mode_if_math:TF \_@@_invoke_outer_field_math: \__stex_expr_invoke_text:
}

\cs_new_protected:Nn \_@@_invoke_outer_field_math: {
  \stex_debug:nn{expressions}{math~mode}
  \peek_charcode_remove:NTF ! {
    % operator
    \peek_charcode_remove:NTF * \__stex_expr_invoke_op_custom:n {
      % op notation
      \peek_charcode:NTF [ \__stex_expr_invoke_op_notation:w {
        \__stex_expr_invoke_op_notation:w []
      }
    }
  }{
    \peek_charcode_remove:NTF * \__stex_expr_invoke_custom:n {
      % normal
      \peek_charcode:NTF [ \_@@_invoke_outer_notation:w {
        \_@@_invoke_outer_notation:w []
      }
    }
  }
}

% TODO adapt to inherited notations too!
\cs_new_protected:Npn \_@@_invoke_outer_notation:w [#1] {
  \stex_debug:nn{expressions}{using~notation~#1~for~\stex_current_symbol_str}
  \cs_if_exist:cTF{l_stex_notation_\stex_current_symbol_str _#1_cs}{
    \tl_if_empty:NTF \STEXInteralCurrentReturn {
      \use:c{l_stex_notation_\stex_current_symbol_str _#1_cs}
    }{
      \exp_args:Ne \__stex_expr_invoke_return_maybe:n{
        \exp_args:Nne \use:n {\exp_not:N \use:c}{l_stex_notation_\stex_current_symbol_str _#1_cs}
      }
    }
  }{
    \msg_error:nnxx{stex}{error/nonotation}{\stex_current_symbol_str}{#1}
  }
}

%    \end{macrocode}
%
% \end{sfragment}
%
% \begin{sfragment}{Metatheory}
%    \begin{macrocode}
%<@@=stex_meta>
\group_begin:
  \bool_set_false:N \_stex_html_do_output_bool
  \bool_set_false:N \c_stex_check_terms_bool
  \stex_uri_resolve:Nn \l_stex_current_ns_uri {http://mathhub.info/sTeX/meta}
  \stex_module_setup:n{Metatheory}
  
  % structures
  \symdef{in-module}[args=2,hidden]{#1\STEXinvisible{#2}}
  \symdecl*{module-type}[args=aa]
  \notation{module-type}{\comp{\mathtt{MOD}} #1 \comp{\oplus\{} #2 \comp\}}{##1 \comp, ##2}{##1 \comp, ##2}
  
  \symdecl{mathstruct}[name=mathematical-structure,args=a] % TODO
  \notation{mathstruct}[angle,prec=nobrackets]{\comp\langle #1 \comp\rangle}{##1 \comp, ##2}

  % sequences
  \symdef{ellipses}[ldots]{\comp{\ldots}}
  \symdef{stex-sequence-in}[parens,args=iai]{\comp(#1\comp)\c_math_subscript_token{#2\comp\in#3}}{##1\comp,##2}
  \symdef{stex-sequence}[comma,args=a]{#1}{##1\comp,##2}

  \stex_close_module:
  \stex_uri_add_module:NNn \l_stex_metatheory_uri \l_stex_current_ns_uri {Metatheory}
  \global \let \l_stex_metatheory_uri \l_stex_metatheory_uri
\group_end:
%    \end{macrocode}
%
% \end{sfragment}
%
%
% \begin{sfragment}{TODO}
%    \begin{macrocode}
%<@@=todo>

\let\stex_par:\par
\bool_new:N \l_stex_inparray_bool
%    \end{macrocode}
% \end{sfragment}
%
%
%
%
%
%    \begin{macrocode}
\stex_read_persist:
\cs_undefine:N \stex_read_persist:
%</package>
%    \end{macrocode}
% \end{implementation}
\endinput